!SESSION 2020-09-10 01:56:40.352 -----------------------------------------------
eclipse.buildId=4.16.0.I20200604-0540
java.version=14.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=fr_FR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

This is a continuation of log file D:\Projet\.metadata\.bak_0.log
Created Time: 2020-09-10 03:43:14.757

!ENTRY org.eclipse.jdt.ui 4 2 2020-09-10 03:43:14.762
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2020-09-10 03:43:14.769
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:43:14.818
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1)
			( !configuration.Emplac_Obstacle.contains() && !configuration.Emplac_Intrus.contains(new Point(intru.y,intru.x+1)) && !configuration.Emplac_Sac.contains(new Point(intru.y,intru.x+1))  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y,intru.x-1)) && !configuration.Emplac_Intrus.contains(new Point(intru.y,intru.x-1)) && !configuration.Emplac_Sac.contains(new Point(intru.y,intru.x-1))  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y+1,intru.x))&& !configuration.Emplac_Intrus.contains(new Point(intru.y+1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y+1,intru.x))  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Intrus.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-09-10 03:43:14.825
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-09-10 03:43:14.832
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:43:16.798
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			( !configuration.Emplac_Obstacle.contains() && !configuration.Emplac_Intrus.contains(new Point(intru.y,intru.x+1)) && !configuration.Emplac_Sac.contains(new Point(intru.y,intru.x+1))  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y,intru.x-1)) && !configuration.Emplac_Intrus.contains(new Point(intru.y,intru.x-1)) && !configuration.Emplac_Sac.contains(new Point(intru.y,intru.x-1))  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y+1,intru.x))&& !configuration.Emplac_Intrus.contains(new Point(intru.y+1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y+1,intru.x))  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Intrus.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2020-09-10 03:43:16.805
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2020-09-10 03:43:16.811
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:43:16.838
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			( !configuration.Emplac_Obstacle.contains() && !configuration.Emplac_Intrus.contains(new Point(intru.y,intru.x+1)) && !configuration.Emplac_Sac.contains(new Point(intru.y,intru.x+1))  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y,intru.x-1)) && !configuration.Emplac_Intrus.contains(new Point(intru.y,intru.x-1)) && !configuration.Emplac_Sac.contains(new Point(intru.y,intru.x-1))  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y+1,intru.x))&& !configuration.Emplac_Intrus.contains(new Point(intru.y+1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y+1,intru.x))  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Intrus.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:186)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-09-10 03:43:16.846
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:186)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-09-10 03:43:16.852
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:186)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:43:19.342
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			
			( !configuration.Emplac_Obstacle.contains() && !configuration.Emplac_Intrus.contains(new Point(intru.y,intru.x+1)) && !configuration.Emplac_Sac.contains(new Point(intru.y,intru.x+1))  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y,intru.x-1)) && !configuration.Emplac_Intrus.contains(new Point(intru.y,intru.x-1)) && !configuration.Emplac_Sac.contains(new Point(intru.y,intru.x-1))  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y+1,intru.x))&& !configuration.Emplac_Intrus.contains(new Point(intru.y+1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y+1,intru.x))  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Intrus.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2020-09-10 03:43:19.350
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2020-09-10 03:43:19.356
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:43:19.381
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			
			( !configuration.Emplac_Obstacle.contains() && !configuration.Emplac_Intrus.contains(new Point(intru.y,intru.x+1)) && !configuration.Emplac_Sac.contains(new Point(intru.y,intru.x+1))  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y,intru.x-1)) && !configuration.Emplac_Intrus.contains(new Point(intru.y,intru.x-1)) && !configuration.Emplac_Sac.contains(new Point(intru.y,intru.x-1))  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y+1,intru.x))&& !configuration.Emplac_Intrus.contains(new Point(intru.y+1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y+1,intru.x))  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Intrus.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:186)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-09-10 03:43:19.389
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:186)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-09-10 03:43:19.394
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:186)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:43:22.722
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			
			( !configuration.Emplac_Obstacle.contains() && !configuration.Emplac_Intrus.contains(new Point(intru.y,intru.x+1)) && !configuration.Emplac_Sac.contains(new Point(intru.y,intru.x+1))  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y,intru.x-1)) && !configuration.Emplac_Intrus.contains(new Point(intru.y,intru.x-1)) && !configuration.Emplac_Sac.contains(new Point(intru.y,intru.x-1))  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y+1,intru.x))&& !configuration.Emplac_Intrus.contains(new Point(intru.y+1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y+1,intru.x))  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Intrus.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-09-10 03:43:22.731
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-09-10 03:43:22.738
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:43:22.941
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			
			( !configuration.Emplac_Obstacle.contains() && !configuration.Emplac_Intrus.contains(new Point(intru.y,intru.x+1)) && !configuration.Emplac_Sac.contains(new Point(intru.y,intru.x+1))  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y,intru.x-1)) && !configuration.Emplac_Intrus.contains(new Point(intru.y,intru.x-1)) && !configuration.Emplac_Sac.contains(new Point(intru.y,intru.x-1))  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y+1,intru.x))&& !configuration.Emplac_Intrus.contains(new Point(intru.y+1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y+1,intru.x))  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Intrus.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-09-10 03:43:22.949
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-09-10 03:43:22.955
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:43:23.210
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(new Point(intru.y,intru.x+1)) && !configuration.Emplac_Sac.contains(new Point(intru.y,intru.x+1))  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y,intru.x-1)) && !configuration.Emplac_Intrus.contains(new Point(intru.y,intru.x-1)) && !configuration.Emplac_Sac.contains(new Point(intru.y,intru.x-1))  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y+1,intru.x))&& !configuration.Emplac_Intrus.contains(new Point(intru.y+1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y+1,intru.x))  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Intrus.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.internal.ui.text.java.PostfixCompletionProposalComputer.updateTemplateEngine(PostfixCompletionProposalComputer.java:153)
	at org.eclipse.jdt.internal.ui.text.java.PostfixCompletionProposalComputer.analyzeCoreContext(PostfixCompletionProposalComputer.java:121)
	at org.eclipse.jdt.internal.ui.text.java.PostfixCompletionProposalComputer.computeCompletionEngine(PostfixCompletionProposalComputer.java:110)
	at org.eclipse.jdt.internal.ui.text.java.AbstractTemplateCompletionProposalComputer.computeCompletionProposals(AbstractTemplateCompletionProposalComputer.java:71)
	at org.eclipse.jdt.internal.ui.text.java.CompletionProposalComputerDescriptor.computeCompletionProposals(CompletionProposalComputerDescriptor.java:345)
	at org.eclipse.jdt.internal.ui.text.java.CompletionProposalCategory.computeCompletionProposals(CompletionProposalCategory.java:340)
	at org.eclipse.jdt.internal.ui.text.java.ContentAssistProcessor.collectProposals(ContentAssistProcessor.java:333)
	at org.eclipse.jdt.internal.ui.text.java.ContentAssistProcessor.computeCompletionProposals(ContentAssistProcessor.java:289)
	at org.eclipse.jface.text.contentassist.AsyncCompletionProposalPopup.lambda$10(AsyncCompletionProposalPopup.java:351)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jface.text.contentassist.AsyncCompletionProposalPopup.lambda$9(AsyncCompletionProposalPopup.java:350)
	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java:1764)
	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.exec(CompletableFuture.java:1756)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:290)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1016)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1665)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1598)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:183)

!ENTRY org.eclipse.jdt.ui 2 0 2020-09-10 03:43:23.217
!MESSAGE The 'org.eclipse.jdt.ui.postfixCompletion' proposal computer from the 'org.eclipse.jdt.ui' plug-in did not complete normally. The extension has thrown a runtime exception.
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.internal.ui.text.java.PostfixCompletionProposalComputer.updateTemplateEngine(PostfixCompletionProposalComputer.java:153)
	at org.eclipse.jdt.internal.ui.text.java.PostfixCompletionProposalComputer.analyzeCoreContext(PostfixCompletionProposalComputer.java:121)
	at org.eclipse.jdt.internal.ui.text.java.PostfixCompletionProposalComputer.computeCompletionEngine(PostfixCompletionProposalComputer.java:110)
	at org.eclipse.jdt.internal.ui.text.java.AbstractTemplateCompletionProposalComputer.computeCompletionProposals(AbstractTemplateCompletionProposalComputer.java:71)
	at org.eclipse.jdt.internal.ui.text.java.CompletionProposalComputerDescriptor.computeCompletionProposals(CompletionProposalComputerDescriptor.java:345)
	at org.eclipse.jdt.internal.ui.text.java.CompletionProposalCategory.computeCompletionProposals(CompletionProposalCategory.java:340)
	at org.eclipse.jdt.internal.ui.text.java.ContentAssistProcessor.collectProposals(ContentAssistProcessor.java:333)
	at org.eclipse.jdt.internal.ui.text.java.ContentAssistProcessor.computeCompletionProposals(ContentAssistProcessor.java:289)
	at org.eclipse.jface.text.contentassist.AsyncCompletionProposalPopup.lambda$10(AsyncCompletionProposalPopup.java:351)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jface.text.contentassist.AsyncCompletionProposalPopup.lambda$9(AsyncCompletionProposalPopup.java:350)
	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java:1764)
	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.exec(CompletableFuture.java:1756)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:290)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1016)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1665)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1598)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:183)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:43:23.898
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(new Point(intru.y,intru.x+1)) && !configuration.Emplac_Sac.contains(new Point(intru.y,intru.x+1))  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y,intru.x-1)) && !configuration.Emplac_Intrus.contains(new Point(intru.y,intru.x-1)) && !configuration.Emplac_Sac.contains(new Point(intru.y,intru.x-1))  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y+1,intru.x))&& !configuration.Emplac_Intrus.contains(new Point(intru.y+1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y+1,intru.x))  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Intrus.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2020-09-10 03:43:23.905
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2020-09-10 03:43:23.912
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:43:23.939
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(new Point(intru.y,intru.x+1)) && !configuration.Emplac_Sac.contains(new Point(intru.y,intru.x+1))  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y,intru.x-1)) && !configuration.Emplac_Intrus.contains(new Point(intru.y,intru.x-1)) && !configuration.Emplac_Sac.contains(new Point(intru.y,intru.x-1))  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y+1,intru.x))&& !configuration.Emplac_Intrus.contains(new Point(intru.y+1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y+1,intru.x))  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Intrus.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:186)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-09-10 03:43:23.946
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:186)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-09-10 03:43:23.952
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:186)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:43:27.765
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(new Point(intru.y,intru.x+1)) && !configuration.Emplac_Sac.contains(new Point(intru.y,intru.x+1))  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y,intru.x-1)) && !configuration.Emplac_Intrus.contains(new Point(intru.y,intru.x-1)) && !configuration.Emplac_Sac.contains(new Point(intru.y,intru.x-1))  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y+1,intru.x))&& !configuration.Emplac_Intrus.contains(new Point(intru.y+1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y+1,intru.x))  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Intrus.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-09-10 03:43:27.773
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-09-10 03:43:27.779
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:43:29.350
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(new Point(intru.y,intru.x+1)) && !configuration.Emplac_Sac.contains(new Point(intru.y,intru.x+1))  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y,intru.x-1)) && !configuration.Emplac_Intrus.contains(new Point(intru.y,intru.x-1)) && !configuration.Emplac_Sac.contains(new Point(intru.y,intru.x-1))  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y+1,intru.x))&& !configuration.Emplac_Intrus.contains(new Point(intru.y+1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y+1,intru.x))  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Intrus.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-09-10 03:43:29.358
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-09-10 03:43:29.364
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:43:29.524
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(new Point(intru.y,intru.x+1)) && !configuration.Emplac_Sac.contains(new Point(intru.y,intru.x+1))  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y,intru.x-1)) && !configuration.Emplac_Intrus.contains(new Point(intru.y,intru.x-1)) && !configuration.Emplac_Sac.contains(new Point(intru.y,intru.x-1))  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y+1,intru.x))&& !configuration.Emplac_Intrus.contains(new Point(intru.y+1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y+1,intru.x))  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Intrus.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-09-10 03:43:29.531
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-09-10 03:43:29.537
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:43:29.884
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(p) && !configuration.Emplac_Sac.contains(new Point(intru.y,intru.x+1))  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y,intru.x-1)) && !configuration.Emplac_Intrus.contains(new Point(intru.y,intru.x-1)) && !configuration.Emplac_Sac.contains(new Point(intru.y,intru.x-1))  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y+1,intru.x))&& !configuration.Emplac_Intrus.contains(new Point(intru.y+1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y+1,intru.x))  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Intrus.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.internal.ui.text.java.PostfixCompletionProposalComputer.updateTemplateEngine(PostfixCompletionProposalComputer.java:153)
	at org.eclipse.jdt.internal.ui.text.java.PostfixCompletionProposalComputer.analyzeCoreContext(PostfixCompletionProposalComputer.java:121)
	at org.eclipse.jdt.internal.ui.text.java.PostfixCompletionProposalComputer.computeCompletionEngine(PostfixCompletionProposalComputer.java:110)
	at org.eclipse.jdt.internal.ui.text.java.AbstractTemplateCompletionProposalComputer.computeCompletionProposals(AbstractTemplateCompletionProposalComputer.java:71)
	at org.eclipse.jdt.internal.ui.text.java.CompletionProposalComputerDescriptor.computeCompletionProposals(CompletionProposalComputerDescriptor.java:345)
	at org.eclipse.jdt.internal.ui.text.java.CompletionProposalCategory.computeCompletionProposals(CompletionProposalCategory.java:340)
	at org.eclipse.jdt.internal.ui.text.java.ContentAssistProcessor.collectProposals(ContentAssistProcessor.java:333)
	at org.eclipse.jdt.internal.ui.text.java.ContentAssistProcessor.computeCompletionProposals(ContentAssistProcessor.java:289)
	at org.eclipse.jface.text.contentassist.AsyncCompletionProposalPopup.lambda$10(AsyncCompletionProposalPopup.java:351)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jface.text.contentassist.AsyncCompletionProposalPopup.lambda$9(AsyncCompletionProposalPopup.java:350)
	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java:1764)
	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.exec(CompletableFuture.java:1756)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:290)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1016)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1665)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1598)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:183)

!ENTRY org.eclipse.jdt.ui 2 0 2020-09-10 03:43:29.891
!MESSAGE The 'org.eclipse.jdt.ui.postfixCompletion' proposal computer from the 'org.eclipse.jdt.ui' plug-in did not complete normally. The extension has thrown a runtime exception.
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.internal.ui.text.java.PostfixCompletionProposalComputer.updateTemplateEngine(PostfixCompletionProposalComputer.java:153)
	at org.eclipse.jdt.internal.ui.text.java.PostfixCompletionProposalComputer.analyzeCoreContext(PostfixCompletionProposalComputer.java:121)
	at org.eclipse.jdt.internal.ui.text.java.PostfixCompletionProposalComputer.computeCompletionEngine(PostfixCompletionProposalComputer.java:110)
	at org.eclipse.jdt.internal.ui.text.java.AbstractTemplateCompletionProposalComputer.computeCompletionProposals(AbstractTemplateCompletionProposalComputer.java:71)
	at org.eclipse.jdt.internal.ui.text.java.CompletionProposalComputerDescriptor.computeCompletionProposals(CompletionProposalComputerDescriptor.java:345)
	at org.eclipse.jdt.internal.ui.text.java.CompletionProposalCategory.computeCompletionProposals(CompletionProposalCategory.java:340)
	at org.eclipse.jdt.internal.ui.text.java.ContentAssistProcessor.collectProposals(ContentAssistProcessor.java:333)
	at org.eclipse.jdt.internal.ui.text.java.ContentAssistProcessor.computeCompletionProposals(ContentAssistProcessor.java:289)
	at org.eclipse.jface.text.contentassist.AsyncCompletionProposalPopup.lambda$10(AsyncCompletionProposalPopup.java:351)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jface.text.contentassist.AsyncCompletionProposalPopup.lambda$9(AsyncCompletionProposalPopup.java:350)
	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java:1764)
	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.exec(CompletableFuture.java:1756)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:290)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1016)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1665)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1598)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:183)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:43:30.444
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(pd) && !configuration.Emplac_Sac.contains(new Point(intru.y,intru.x+1))  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y,intru.x-1)) && !configuration.Emplac_Intrus.contains(new Point(intru.y,intru.x-1)) && !configuration.Emplac_Sac.contains(new Point(intru.y,intru.x-1))  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y+1,intru.x))&& !configuration.Emplac_Intrus.contains(new Point(intru.y+1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y+1,intru.x))  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Intrus.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2020-09-10 03:43:30.451
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2020-09-10 03:43:30.458
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:43:30.485
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(pd) && !configuration.Emplac_Sac.contains(new Point(intru.y,intru.x+1))  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y,intru.x-1)) && !configuration.Emplac_Intrus.contains(new Point(intru.y,intru.x-1)) && !configuration.Emplac_Sac.contains(new Point(intru.y,intru.x-1))  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y+1,intru.x))&& !configuration.Emplac_Intrus.contains(new Point(intru.y+1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y+1,intru.x))  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Intrus.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:186)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-09-10 03:43:30.492
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:186)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-09-10 03:43:30.498
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:186)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:43:44.762
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(pd) && !configuration.Emplac_Sac.contains(new Point(intru.y,intru.x+1))  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y,intru.x-1)) && !configuration.Emplac_Intrus.contains(new Point(intru.y,intru.x-1)) && !configuration.Emplac_Sac.contains(new Point(intru.y,intru.x-1))  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y+1,intru.x))&& !configuration.Emplac_Intrus.contains(new Point(intru.y+1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y+1,intru.x))  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Intrus.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-09-10 03:43:44.769
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-09-10 03:43:44.775
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:43:45.077
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(pd) && !configuration.Emplac_Sac.contains(new Point(intru.y,intru.x+1))  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y,intru.x-1)) && !configuration.Emplac_Intrus.contains(new Point(intru.y,intru.x-1)) && !configuration.Emplac_Sac.contains(new Point(intru.y,intru.x-1))  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y+1,intru.x))&& !configuration.Emplac_Intrus.contains(new Point(intru.y+1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y+1,intru.x))  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Intrus.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-09-10 03:43:45.084
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-09-10 03:43:45.091
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:43:46.274
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(pd) && !configuration.Emplac_Sac.contains(p)  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y,intru.x-1)) && !configuration.Emplac_Intrus.contains(new Point(intru.y,intru.x-1)) && !configuration.Emplac_Sac.contains(new Point(intru.y,intru.x-1))  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y+1,intru.x))&& !configuration.Emplac_Intrus.contains(new Point(intru.y+1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y+1,intru.x))  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Intrus.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.internal.ui.text.java.PostfixCompletionProposalComputer.updateTemplateEngine(PostfixCompletionProposalComputer.java:153)
	at org.eclipse.jdt.internal.ui.text.java.PostfixCompletionProposalComputer.analyzeCoreContext(PostfixCompletionProposalComputer.java:121)
	at org.eclipse.jdt.internal.ui.text.java.PostfixCompletionProposalComputer.computeCompletionEngine(PostfixCompletionProposalComputer.java:110)
	at org.eclipse.jdt.internal.ui.text.java.AbstractTemplateCompletionProposalComputer.computeCompletionProposals(AbstractTemplateCompletionProposalComputer.java:71)
	at org.eclipse.jdt.internal.ui.text.java.CompletionProposalComputerDescriptor.computeCompletionProposals(CompletionProposalComputerDescriptor.java:345)
	at org.eclipse.jdt.internal.ui.text.java.CompletionProposalCategory.computeCompletionProposals(CompletionProposalCategory.java:340)
	at org.eclipse.jdt.internal.ui.text.java.ContentAssistProcessor.collectProposals(ContentAssistProcessor.java:333)
	at org.eclipse.jdt.internal.ui.text.java.ContentAssistProcessor.computeCompletionProposals(ContentAssistProcessor.java:289)
	at org.eclipse.jface.text.contentassist.AsyncCompletionProposalPopup.lambda$10(AsyncCompletionProposalPopup.java:351)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jface.text.contentassist.AsyncCompletionProposalPopup.lambda$9(AsyncCompletionProposalPopup.java:350)
	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java:1764)
	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.exec(CompletableFuture.java:1756)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:290)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1016)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1665)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1598)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:183)

!ENTRY org.eclipse.jdt.ui 2 0 2020-09-10 03:43:46.281
!MESSAGE The 'org.eclipse.jdt.ui.postfixCompletion' proposal computer from the 'org.eclipse.jdt.ui' plug-in did not complete normally. The extension has thrown a runtime exception.
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.internal.ui.text.java.PostfixCompletionProposalComputer.updateTemplateEngine(PostfixCompletionProposalComputer.java:153)
	at org.eclipse.jdt.internal.ui.text.java.PostfixCompletionProposalComputer.analyzeCoreContext(PostfixCompletionProposalComputer.java:121)
	at org.eclipse.jdt.internal.ui.text.java.PostfixCompletionProposalComputer.computeCompletionEngine(PostfixCompletionProposalComputer.java:110)
	at org.eclipse.jdt.internal.ui.text.java.AbstractTemplateCompletionProposalComputer.computeCompletionProposals(AbstractTemplateCompletionProposalComputer.java:71)
	at org.eclipse.jdt.internal.ui.text.java.CompletionProposalComputerDescriptor.computeCompletionProposals(CompletionProposalComputerDescriptor.java:345)
	at org.eclipse.jdt.internal.ui.text.java.CompletionProposalCategory.computeCompletionProposals(CompletionProposalCategory.java:340)
	at org.eclipse.jdt.internal.ui.text.java.ContentAssistProcessor.collectProposals(ContentAssistProcessor.java:333)
	at org.eclipse.jdt.internal.ui.text.java.ContentAssistProcessor.computeCompletionProposals(ContentAssistProcessor.java:289)
	at org.eclipse.jface.text.contentassist.AsyncCompletionProposalPopup.lambda$10(AsyncCompletionProposalPopup.java:351)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jface.text.contentassist.AsyncCompletionProposalPopup.lambda$9(AsyncCompletionProposalPopup.java:350)
	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java:1764)
	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.exec(CompletableFuture.java:1756)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:290)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1016)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1665)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1598)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:183)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:43:47.015
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(pd) && !configuration.Emplac_Sac.contains(pd)  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y,intru.x-1)) && !configuration.Emplac_Intrus.contains(new Point(intru.y,intru.x-1)) && !configuration.Emplac_Sac.contains(new Point(intru.y,intru.x-1))  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y+1,intru.x))&& !configuration.Emplac_Intrus.contains(new Point(intru.y+1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y+1,intru.x))  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Intrus.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2020-09-10 03:43:47.022
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2020-09-10 03:43:47.027
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:43:47.052
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(pd) && !configuration.Emplac_Sac.contains(pd)  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y,intru.x-1)) && !configuration.Emplac_Intrus.contains(new Point(intru.y,intru.x-1)) && !configuration.Emplac_Sac.contains(new Point(intru.y,intru.x-1))  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y+1,intru.x))&& !configuration.Emplac_Intrus.contains(new Point(intru.y+1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y+1,intru.x))  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Intrus.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:186)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-09-10 03:43:47.059
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:186)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-09-10 03:43:47.066
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:186)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:43:53.782
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(pd) && !configuration.Emplac_Sac.contains(pd)  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y,intru.x-1)) && !configuration.Emplac_Intrus.contains(new Point(intru.y,intru.x-1)) && !configuration.Emplac_Sac.contains(new Point(intru.y,intru.x-1))  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y+1,intru.x))&& !configuration.Emplac_Intrus.contains(new Point(intru.y+1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y+1,intru.x))  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Intrus.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-09-10 03:43:53.790
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-09-10 03:43:53.796
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:43:59.134
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			Point p
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(pd) && !configuration.Emplac_Sac.contains(pd)  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y,intru.x-1)) && !configuration.Emplac_Intrus.contains(new Point(intru.y,intru.x-1)) && !configuration.Emplac_Sac.contains(new Point(intru.y,intru.x-1))  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y+1,intru.x))&& !configuration.Emplac_Intrus.contains(new Point(intru.y+1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y+1,intru.x))  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Intrus.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.internal.ui.text.java.PostfixCompletionProposalComputer.updateTemplateEngine(PostfixCompletionProposalComputer.java:153)
	at org.eclipse.jdt.internal.ui.text.java.PostfixCompletionProposalComputer.analyzeCoreContext(PostfixCompletionProposalComputer.java:121)
	at org.eclipse.jdt.internal.ui.text.java.PostfixCompletionProposalComputer.computeCompletionEngine(PostfixCompletionProposalComputer.java:110)
	at org.eclipse.jdt.internal.ui.text.java.AbstractTemplateCompletionProposalComputer.computeCompletionProposals(AbstractTemplateCompletionProposalComputer.java:71)
	at org.eclipse.jdt.internal.ui.text.java.CompletionProposalComputerDescriptor.computeCompletionProposals(CompletionProposalComputerDescriptor.java:345)
	at org.eclipse.jdt.internal.ui.text.java.CompletionProposalCategory.computeCompletionProposals(CompletionProposalCategory.java:340)
	at org.eclipse.jdt.internal.ui.text.java.ContentAssistProcessor.collectProposals(ContentAssistProcessor.java:333)
	at org.eclipse.jdt.internal.ui.text.java.ContentAssistProcessor.computeCompletionProposals(ContentAssistProcessor.java:289)
	at org.eclipse.jface.text.contentassist.AsyncCompletionProposalPopup.lambda$10(AsyncCompletionProposalPopup.java:351)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jface.text.contentassist.AsyncCompletionProposalPopup.lambda$9(AsyncCompletionProposalPopup.java:350)
	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java:1764)
	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.exec(CompletableFuture.java:1756)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:290)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1016)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1665)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1598)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:183)

!ENTRY org.eclipse.jdt.ui 2 0 2020-09-10 03:43:59.142
!MESSAGE The 'org.eclipse.jdt.ui.postfixCompletion' proposal computer from the 'org.eclipse.jdt.ui' plug-in did not complete normally. The extension has thrown a runtime exception.
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.internal.ui.text.java.PostfixCompletionProposalComputer.updateTemplateEngine(PostfixCompletionProposalComputer.java:153)
	at org.eclipse.jdt.internal.ui.text.java.PostfixCompletionProposalComputer.analyzeCoreContext(PostfixCompletionProposalComputer.java:121)
	at org.eclipse.jdt.internal.ui.text.java.PostfixCompletionProposalComputer.computeCompletionEngine(PostfixCompletionProposalComputer.java:110)
	at org.eclipse.jdt.internal.ui.text.java.AbstractTemplateCompletionProposalComputer.computeCompletionProposals(AbstractTemplateCompletionProposalComputer.java:71)
	at org.eclipse.jdt.internal.ui.text.java.CompletionProposalComputerDescriptor.computeCompletionProposals(CompletionProposalComputerDescriptor.java:345)
	at org.eclipse.jdt.internal.ui.text.java.CompletionProposalCategory.computeCompletionProposals(CompletionProposalCategory.java:340)
	at org.eclipse.jdt.internal.ui.text.java.ContentAssistProcessor.collectProposals(ContentAssistProcessor.java:333)
	at org.eclipse.jdt.internal.ui.text.java.ContentAssistProcessor.computeCompletionProposals(ContentAssistProcessor.java:289)
	at org.eclipse.jface.text.contentassist.AsyncCompletionProposalPopup.lambda$10(AsyncCompletionProposalPopup.java:351)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jface.text.contentassist.AsyncCompletionProposalPopup.lambda$9(AsyncCompletionProposalPopup.java:350)
	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java:1764)
	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.exec(CompletableFuture.java:1756)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:290)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1016)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1665)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1598)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:183)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:43:59.148
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			Point p
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(pd) && !configuration.Emplac_Sac.contains(pd)  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y,intru.x-1)) && !configuration.Emplac_Intrus.contains(new Point(intru.y,intru.x-1)) && !configuration.Emplac_Sac.contains(new Point(intru.y,intru.x-1))  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y+1,intru.x))&& !configuration.Emplac_Intrus.contains(new Point(intru.y+1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y+1,intru.x))  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Intrus.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:186)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:186)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-09-10 03:43:59.155
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:186)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:186)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-09-10 03:43:59.162
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:186)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:186)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:43:59.320
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			Point pg
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(pd) && !configuration.Emplac_Sac.contains(pd)  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y,intru.x-1)) && !configuration.Emplac_Intrus.contains(new Point(intru.y,intru.x-1)) && !configuration.Emplac_Sac.contains(new Point(intru.y,intru.x-1))  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y+1,intru.x))&& !configuration.Emplac_Intrus.contains(new Point(intru.y+1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y+1,intru.x))  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Intrus.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.internal.ui.text.java.PostfixCompletionProposalComputer.updateTemplateEngine(PostfixCompletionProposalComputer.java:153)
	at org.eclipse.jdt.internal.ui.text.java.PostfixCompletionProposalComputer.analyzeCoreContext(PostfixCompletionProposalComputer.java:121)
	at org.eclipse.jdt.internal.ui.text.java.PostfixCompletionProposalComputer.computeCompletionEngine(PostfixCompletionProposalComputer.java:110)
	at org.eclipse.jdt.internal.ui.text.java.AbstractTemplateCompletionProposalComputer.computeCompletionProposals(AbstractTemplateCompletionProposalComputer.java:71)
	at org.eclipse.jdt.internal.ui.text.java.CompletionProposalComputerDescriptor.computeCompletionProposals(CompletionProposalComputerDescriptor.java:345)
	at org.eclipse.jdt.internal.ui.text.java.CompletionProposalCategory.computeCompletionProposals(CompletionProposalCategory.java:340)
	at org.eclipse.jdt.internal.ui.text.java.ContentAssistProcessor.collectProposals(ContentAssistProcessor.java:333)
	at org.eclipse.jdt.internal.ui.text.java.ContentAssistProcessor.computeCompletionProposals(ContentAssistProcessor.java:289)
	at org.eclipse.jface.text.contentassist.AsyncCompletionProposalPopup.lambda$10(AsyncCompletionProposalPopup.java:351)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jface.text.contentassist.AsyncCompletionProposalPopup.lambda$9(AsyncCompletionProposalPopup.java:350)
	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java:1764)
	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.exec(CompletableFuture.java:1756)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:290)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1016)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1665)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1598)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:183)

!ENTRY org.eclipse.jdt.ui 2 0 2020-09-10 03:43:59.327
!MESSAGE The 'org.eclipse.jdt.ui.postfixCompletion' proposal computer from the 'org.eclipse.jdt.ui' plug-in did not complete normally. The extension has thrown a runtime exception.
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.internal.ui.text.java.PostfixCompletionProposalComputer.updateTemplateEngine(PostfixCompletionProposalComputer.java:153)
	at org.eclipse.jdt.internal.ui.text.java.PostfixCompletionProposalComputer.analyzeCoreContext(PostfixCompletionProposalComputer.java:121)
	at org.eclipse.jdt.internal.ui.text.java.PostfixCompletionProposalComputer.computeCompletionEngine(PostfixCompletionProposalComputer.java:110)
	at org.eclipse.jdt.internal.ui.text.java.AbstractTemplateCompletionProposalComputer.computeCompletionProposals(AbstractTemplateCompletionProposalComputer.java:71)
	at org.eclipse.jdt.internal.ui.text.java.CompletionProposalComputerDescriptor.computeCompletionProposals(CompletionProposalComputerDescriptor.java:345)
	at org.eclipse.jdt.internal.ui.text.java.CompletionProposalCategory.computeCompletionProposals(CompletionProposalCategory.java:340)
	at org.eclipse.jdt.internal.ui.text.java.ContentAssistProcessor.collectProposals(ContentAssistProcessor.java:333)
	at org.eclipse.jdt.internal.ui.text.java.ContentAssistProcessor.computeCompletionProposals(ContentAssistProcessor.java:289)
	at org.eclipse.jface.text.contentassist.AsyncCompletionProposalPopup.lambda$10(AsyncCompletionProposalPopup.java:351)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jface.text.contentassist.AsyncCompletionProposalPopup.lambda$9(AsyncCompletionProposalPopup.java:350)
	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java:1764)
	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.exec(CompletableFuture.java:1756)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:290)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1016)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1665)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1598)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:183)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:43:59.732
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			Point pg
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(pd) && !configuration.Emplac_Sac.contains(pd)  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y,intru.x-1)) && !configuration.Emplac_Intrus.contains(new Point(intru.y,intru.x-1)) && !configuration.Emplac_Sac.contains(new Point(intru.y,intru.x-1))  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y+1,intru.x))&& !configuration.Emplac_Intrus.contains(new Point(intru.y+1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y+1,intru.x))  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Intrus.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-09-10 03:43:59.739
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-09-10 03:43:59.745
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:44:00.146
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			Point pg
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(pd) && !configuration.Emplac_Sac.contains(pd)  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y,intru.x-1)) && !configuration.Emplac_Intrus.contains(new Point(intru.y,intru.x-1)) && !configuration.Emplac_Sac.contains(new Point(intru.y,intru.x-1))  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y+1,intru.x))&& !configuration.Emplac_Intrus.contains(new Point(intru.y+1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y+1,intru.x))  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Intrus.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2020-09-10 03:44:00.153
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2020-09-10 03:44:00.159
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:44:10.696
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			Point pg 
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(pd) && !configuration.Emplac_Sac.contains(pd)  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y,intru.x-1)) && !configuration.Emplac_Intrus.contains(new Point(intru.y,intru.x-1)) && !configuration.Emplac_Sac.contains(new Point(intru.y,intru.x-1))  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y+1,intru.x))&& !configuration.Emplac_Intrus.contains(new Point(intru.y+1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y+1,intru.x))  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Intrus.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2020-09-10 03:44:10.703
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2020-09-10 03:44:10.708
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:44:10.733
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			Point pg 
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(pd) && !configuration.Emplac_Sac.contains(pd)  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y,intru.x-1)) && !configuration.Emplac_Intrus.contains(new Point(intru.y,intru.x-1)) && !configuration.Emplac_Sac.contains(new Point(intru.y,intru.x-1))  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y+1,intru.x))&& !configuration.Emplac_Intrus.contains(new Point(intru.y+1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y+1,intru.x))  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Intrus.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:186)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-09-10 03:44:10.740
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:186)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-09-10 03:44:10.746
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:186)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:44:10.926
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			Point pg 
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(pd) && !configuration.Emplac_Sac.contains(pd)  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y,intru.x-1)) && !configuration.Emplac_Intrus.contains(new Point(intru.y,intru.x-1)) && !configuration.Emplac_Sac.contains(new Point(intru.y,intru.x-1))  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y+1,intru.x))&& !configuration.Emplac_Intrus.contains(new Point(intru.y+1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y+1,intru.x))  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Intrus.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-09-10 03:44:10.932
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-09-10 03:44:10.938
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:44:10.967
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			Point pg 
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(pd) && !configuration.Emplac_Sac.contains(pd)  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y,intru.x-1)) && !configuration.Emplac_Intrus.contains(new Point(intru.y,intru.x-1)) && !configuration.Emplac_Sac.contains(new Point(intru.y,intru.x-1))  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y+1,intru.x))&& !configuration.Emplac_Intrus.contains(new Point(intru.y+1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y+1,intru.x))  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Intrus.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1015)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:811)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:678)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:670)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-09-10 03:44:10.974
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1015)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:811)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:678)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:670)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-09-10 03:44:10.979
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1015)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:811)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:678)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:670)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:44:13.749
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			Point pg = new Point(intru.y,intru.x+1)
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(pd) && !configuration.Emplac_Sac.contains(pd)  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y,intru.x-1)) && !configuration.Emplac_Intrus.contains(new Point(intru.y,intru.x-1)) && !configuration.Emplac_Sac.contains(new Point(intru.y,intru.x-1))  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y+1,intru.x))&& !configuration.Emplac_Intrus.contains(new Point(intru.y+1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y+1,intru.x))  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Intrus.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2020-09-10 03:44:13.755
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2020-09-10 03:44:13.761
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:44:13.879
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			Point pg = new Point(intru.y,intru.x+1)
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(pd) && !configuration.Emplac_Sac.contains(pd)  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y,intru.x-1)) && !configuration.Emplac_Intrus.contains(new Point(intru.y,intru.x-1)) && !configuration.Emplac_Sac.contains(new Point(intru.y,intru.x-1))  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y+1,intru.x))&& !configuration.Emplac_Intrus.contains(new Point(intru.y+1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y+1,intru.x))  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Intrus.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-09-10 03:44:13.886
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-09-10 03:44:13.892
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:44:15.788
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			Point pg = new Point(intru.y,intru.x+1);
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(pd) && !configuration.Emplac_Sac.contains(pd)  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y,intru.x-1)) && !configuration.Emplac_Intrus.contains(new Point(intru.y,intru.x-1)) && !configuration.Emplac_Sac.contains(new Point(intru.y,intru.x-1))  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y+1,intru.x))&& !configuration.Emplac_Intrus.contains(new Point(intru.y+1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y+1,intru.x))  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Intrus.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2020-09-10 03:44:15.795
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2020-09-10 03:44:15.801
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:44:15.827
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			Point pg = new Point(intru.y,intru.x+1);
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(pd) && !configuration.Emplac_Sac.contains(pd)  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y,intru.x-1)) && !configuration.Emplac_Intrus.contains(new Point(intru.y,intru.x-1)) && !configuration.Emplac_Sac.contains(new Point(intru.y,intru.x-1))  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y+1,intru.x))&& !configuration.Emplac_Intrus.contains(new Point(intru.y+1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y+1,intru.x))  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Intrus.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:186)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-09-10 03:44:15.834
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:186)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-09-10 03:44:15.840
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:186)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:44:17.208
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			Point pg = new Point(intru.y,intru.x+1);
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(pd) && !configuration.Emplac_Sac.contains(pd)  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y,intru.x-1)) && !configuration.Emplac_Intrus.contains(new Point(intru.y,intru.x-1)) && !configuration.Emplac_Sac.contains(new Point(intru.y,intru.x-1))  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y+1,intru.x))&& !configuration.Emplac_Intrus.contains(new Point(intru.y+1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y+1,intru.x))  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Intrus.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-09-10 03:44:17.215
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-09-10 03:44:17.220
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:44:17.266
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			Point pg = new Point(intru.y,intru.x+1);
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(pd) && !configuration.Emplac_Sac.contains(pd)  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y,intru.x-1)) && !configuration.Emplac_Intrus.contains(new Point(intru.y,intru.x-1)) && !configuration.Emplac_Sac.contains(new Point(intru.y,intru.x-1))  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y+1,intru.x))&& !configuration.Emplac_Intrus.contains(new Point(intru.y+1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y+1,intru.x))  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Intrus.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1015)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:811)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:678)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:670)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-09-10 03:44:17.272
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1015)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:811)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:678)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:670)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-09-10 03:44:17.278
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1015)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:811)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:678)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:670)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:44:17.303
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			Point pg = new Point(intru.y,intru.x+1);
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(pd) && !configuration.Emplac_Sac.contains(pd)  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y,intru.x-1)) && !configuration.Emplac_Intrus.contains(new Point(intru.y,intru.x-1)) && !configuration.Emplac_Sac.contains(new Point(intru.y,intru.x-1))  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y+1,intru.x))&& !configuration.Emplac_Intrus.contains(new Point(intru.y+1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y+1,intru.x))  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Intrus.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:186)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-09-10 03:44:17.310
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:186)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-09-10 03:44:17.317
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:186)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:44:18.576
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			Point pg = new Point(intru.y,intru.x+1);
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(pd) && !configuration.Emplac_Sac.contains(pd)  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y,intru.x-1)) && !configuration.Emplac_Intrus.contains(new Point(intru.y,intru.x-1)) && !configuration.Emplac_Sac.contains(new Point(intru.y,intru.x-1))  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y+1,intru.x))&& !configuration.Emplac_Intrus.contains(new Point(intru.y+1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y+1,intru.x))  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Intrus.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-09-10 03:44:18.583
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-09-10 03:44:18.589
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:44:18.621
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			Point pg = new Point(intru.y,intru.x+1);
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(pd) && !configuration.Emplac_Sac.contains(pd)  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y,intru.x-1)) && !configuration.Emplac_Intrus.contains(new Point(intru.y,intru.x-1)) && !configuration.Emplac_Sac.contains(new Point(intru.y,intru.x-1))  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y+1,intru.x))&& !configuration.Emplac_Intrus.contains(new Point(intru.y+1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y+1,intru.x))  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Intrus.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1015)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:811)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:678)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:670)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-09-10 03:44:18.628
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1015)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:811)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:678)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:670)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-09-10 03:44:18.634
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1015)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:811)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:678)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:670)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:44:21.321
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			Point pg = new Point(intru.y,intru.x+1);
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(pd) && !configuration.Emplac_Sac.contains(pd)  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y,intru.x-1)) && !configuration.Emplac_Intrus.contains(new Point(intru.y,intru.x-1)) && !configuration.Emplac_Sac.contains(new Point(intru.y,intru.x-1))  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y+1,intru.x))&& !configuration.Emplac_Intrus.contains(new Point(intru.y+1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y+1,intru.x))  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Intrus.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-09-10 03:44:21.328
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-09-10 03:44:21.334
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:44:21.364
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			Point pg = new Point(intru.y,intru.x+1);
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(pd) && !configuration.Emplac_Sac.contains(pd)  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y,intru.x-1)) && !configuration.Emplac_Intrus.contains(new Point(intru.y,intru.x-1)) && !configuration.Emplac_Sac.contains(new Point(intru.y,intru.x-1))  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y+1,intru.x))&& !configuration.Emplac_Intrus.contains(new Point(intru.y+1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y+1,intru.x))  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Intrus.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1015)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:811)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:678)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:670)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-09-10 03:44:21.371
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1015)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:811)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:678)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:670)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-09-10 03:44:21.377
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1015)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:811)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:678)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:670)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:44:27.421
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			Point pg = new Point(intru.y,intru.x+1);
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(pd) && !configuration.Emplac_Sac.contains(pd)  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y,intru.x-1)) && !configuration.Emplac_Intrus.contains(new Point(intru.y,intru.x-1)) && !configuration.Emplac_Sac.contains(new Point(intru.y,intru.x-1))  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y+1,intru.x))&& !configuration.Emplac_Intrus.contains(new Point(intru.y+1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y+1,intru.x))  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Intrus.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-09-10 03:44:27.429
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-09-10 03:44:27.435
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:44:28.651
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			Point pg = new Point(intru.y,intru.x+1);
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(pd) && !configuration.Emplac_Sac.contains(pd)  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y,intru.x-1)) && !configuration.Emplac_Intrus.contains(new Point(intru.y,intru.x-1)) && !configuration.Emplac_Sac.contains(new Point(intru.y,intru.x-1))  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y+1,intru.x))&& !configuration.Emplac_Intrus.contains(new Point(intru.y+1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y+1,intru.x))  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Intrus.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:446)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:373)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:333)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction$1.run(ClipboardOperationAction.java:281)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:72)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:278)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:121)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at jdk.internal.reflect.GeneratedMethodAccessor60.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:319)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:253)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:487)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:584)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:653)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:443)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.access$2(KeyBindingDispatcher.java:386)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1248)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1036)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1046)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1088)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1084)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1471)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4862)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4740)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4923)
	at org.eclipse.swt.internal.win32.OS.CallWindowProc(Native Method)
	at org.eclipse.swt.internal.BidiUtil.windowProc(BidiUtil.java:648)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3628)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1158)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1047)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:658)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:557)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:154)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:137)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:107)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1447)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-09-10 03:44:28.659
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:446)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:373)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:333)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction$1.run(ClipboardOperationAction.java:281)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:72)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:278)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:121)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at jdk.internal.reflect.GeneratedMethodAccessor60.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:319)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:253)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:487)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:584)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:653)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:443)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.access$2(KeyBindingDispatcher.java:386)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1248)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1036)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1046)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1088)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1084)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1471)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4862)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4740)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4923)
	at org.eclipse.swt.internal.win32.OS.CallWindowProc(Native Method)
	at org.eclipse.swt.internal.BidiUtil.windowProc(BidiUtil.java:648)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3628)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1158)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1047)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:658)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:557)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:154)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:137)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:107)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1447)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-09-10 03:44:28.666
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:446)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:373)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:333)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction$1.run(ClipboardOperationAction.java:281)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:72)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:278)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:121)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at jdk.internal.reflect.GeneratedMethodAccessor60.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:319)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:253)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:487)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:584)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:653)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:443)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.access$2(KeyBindingDispatcher.java:386)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1248)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1036)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1046)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1088)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1084)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1471)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4862)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4740)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4923)
	at org.eclipse.swt.internal.win32.OS.CallWindowProc(Native Method)
	at org.eclipse.swt.internal.BidiUtil.windowProc(BidiUtil.java:648)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3628)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1158)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1047)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:658)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:557)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:154)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:137)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:107)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1447)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:44:29.340
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			Point pg = new Point(intru.y,intru.x+1);
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(pd) && !configuration.Emplac_Sac.contains(pd)  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains() && !configuration.Emplac_Intrus.contains(new Point(intru.y,intru.x-1)) && !configuration.Emplac_Sac.contains(new Point(intru.y,intru.x-1))  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y+1,intru.x))&& !configuration.Emplac_Intrus.contains(new Point(intru.y+1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y+1,intru.x))  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Intrus.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2020-09-10 03:44:29.347
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2020-09-10 03:44:29.353
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:44:29.577
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			Point pg = new Point(intru.y,intru.x+1);
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(pd) && !configuration.Emplac_Sac.contains(pd)  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains() && !configuration.Emplac_Intrus.contains(new Point(intru.y,intru.x-1)) && !configuration.Emplac_Sac.contains(new Point(intru.y,intru.x-1))  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y+1,intru.x))&& !configuration.Emplac_Intrus.contains(new Point(intru.y+1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y+1,intru.x))  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Intrus.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-09-10 03:44:29.583
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-09-10 03:44:29.588
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:44:32.116
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			Point pg = new Point(intru.y,intru.x+1);
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(pd) && !configuration.Emplac_Sac.contains(pd)  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains() && !configuration.Emplac_Intrus.contains(new Point(intru.y,intru.x-1)) && !configuration.Emplac_Sac.contains(new Point(intru.y,intru.x-1))  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y+1,intru.x))&& !configuration.Emplac_Intrus.contains(new Point(intru.y+1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y+1,intru.x))  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Intrus.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-09-10 03:44:32.123
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-09-10 03:44:32.129
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:44:32.882
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			Point pg = new Point(intru.y,intru.x-1);
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(pd) && !configuration.Emplac_Sac.contains(pd)  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains() && !configuration.Emplac_Intrus.contains(new Point(intru.y,intru.x-1)) && !configuration.Emplac_Sac.contains(new Point(intru.y,intru.x-1))  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y+1,intru.x))&& !configuration.Emplac_Intrus.contains(new Point(intru.y+1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y+1,intru.x))  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Intrus.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2020-09-10 03:44:32.889
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2020-09-10 03:44:32.895
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:44:33.069
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			Point pg = new Point(intru.y,intru.x-1);
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(pd) && !configuration.Emplac_Sac.contains(pd)  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains() && !configuration.Emplac_Intrus.contains(new Point(intru.y,intru.x-1)) && !configuration.Emplac_Sac.contains(new Point(intru.y,intru.x-1))  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y+1,intru.x))&& !configuration.Emplac_Intrus.contains(new Point(intru.y+1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y+1,intru.x))  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Intrus.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-09-10 03:44:33.076
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
