!SESSION 2020-09-10 01:56:40.352 -----------------------------------------------
eclipse.buildId=4.16.0.I20200604-0540
java.version=14.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=fr_FR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

This is a continuation of log file D:\Projet\.metadata\.bak_1.log
Created Time: 2020-09-10 03:44:33.121

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-09-10 03:44:33.129
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:44:34.732
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			Point pg = new Point(intru.y,intru.x-1);
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(pd) && !configuration.Emplac_Sac.contains(pd)  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains() && !configuration.Emplac_Intrus.contains(new Point(intru.y,intru.x-1)) && !configuration.Emplac_Sac.contains(new Point(intru.y,intru.x-1))  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y+1,intru.x))&& !configuration.Emplac_Intrus.contains(new Point(intru.y+1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y+1,intru.x))  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Intrus.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-09-10 03:44:34.739
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-09-10 03:44:34.745
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:44:36.675
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			Point pg = new Point(intru.y,intru.x-1);
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(pd) && !configuration.Emplac_Sac.contains(pd)  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains() && !configuration.Emplac_Intrus.contains(new Point(intru.y,intru.x-1)) && !configuration.Emplac_Sac.contains(new Point(intru.y,intru.x-1))  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y+1,intru.x))&& !configuration.Emplac_Intrus.contains(new Point(intru.y+1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y+1,intru.x))  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Intrus.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-09-10 03:44:36.682
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-09-10 03:44:36.688
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:44:36.767
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			Point pg = new Point(intru.y,intru.x-1);
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(pd) && !configuration.Emplac_Sac.contains(pd)  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains() && !configuration.Emplac_Intrus.contains(new Point(intru.y,intru.x-1)) && !configuration.Emplac_Sac.contains(new Point(intru.y,intru.x-1))  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y+1,intru.x))&& !configuration.Emplac_Intrus.contains(new Point(intru.y+1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y+1,intru.x))  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Intrus.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-09-10 03:44:36.773
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-09-10 03:44:36.779
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:44:38.430
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			Point pg = new Point(intru.y,intru.x-1);
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(pd) && !configuration.Emplac_Sac.contains(pd)  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(pg) && !configuration.Emplac_Intrus.contains(new Point(intru.y,intru.x-1)) && !configuration.Emplac_Sac.contains(new Point(intru.y,intru.x-1))  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y+1,intru.x))&& !configuration.Emplac_Intrus.contains(new Point(intru.y+1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y+1,intru.x))  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Intrus.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2020-09-10 03:44:38.437
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2020-09-10 03:44:38.444
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:44:38.661
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			Point pg = new Point(intru.y,intru.x-1);
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(pd) && !configuration.Emplac_Sac.contains(pd)  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(pg) && !configuration.Emplac_Intrus.contains(new Point(intru.y,intru.x-1)) && !configuration.Emplac_Sac.contains(new Point(intru.y,intru.x-1))  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y+1,intru.x))&& !configuration.Emplac_Intrus.contains(new Point(intru.y+1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y+1,intru.x))  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Intrus.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-09-10 03:44:38.678
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-09-10 03:44:38.694
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:44:41.523
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			Point pg = new Point(intru.y,intru.x-1);
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(pd) && !configuration.Emplac_Sac.contains(pd)  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(pg) && !configuration.Emplac_Intrus.contains(new Point(intru.y,intru.x-1)) && !configuration.Emplac_Sac.contains(new Point(intru.y,intru.x-1))  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y+1,intru.x))&& !configuration.Emplac_Intrus.contains(new Point(intru.y+1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y+1,intru.x))  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Intrus.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-09-10 03:44:41.530
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-09-10 03:44:41.536
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:44:42.475
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			Point pg = new Point(intru.y,intru.x-1);
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(pd) && !configuration.Emplac_Sac.contains(pd)  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(pg) && !configuration.Emplac_Intrus.contains(pg) && !configuration.Emplac_Sac.contains(new Point(intru.y,intru.x-1))  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y+1,intru.x))&& !configuration.Emplac_Intrus.contains(new Point(intru.y+1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y+1,intru.x))  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Intrus.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2020-09-10 03:44:42.482
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2020-09-10 03:44:42.489
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:44:42.515
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			Point pg = new Point(intru.y,intru.x-1);
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(pd) && !configuration.Emplac_Sac.contains(pd)  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(pg) && !configuration.Emplac_Intrus.contains(pg) && !configuration.Emplac_Sac.contains(new Point(intru.y,intru.x-1))  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y+1,intru.x))&& !configuration.Emplac_Intrus.contains(new Point(intru.y+1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y+1,intru.x))  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Intrus.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:186)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-09-10 03:44:42.522
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:186)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-09-10 03:44:42.528
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:186)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:44:45.002
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			Point pg = new Point(intru.y,intru.x-1);
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(pd) && !configuration.Emplac_Sac.contains(pd)  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(pg) && !configuration.Emplac_Intrus.contains(pg) && !configuration.Emplac_Sac.contains(new Point(intru.y,intru.x-1))  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y+1,intru.x))&& !configuration.Emplac_Intrus.contains(new Point(intru.y+1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y+1,intru.x))  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Intrus.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-09-10 03:44:45.009
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-09-10 03:44:45.015
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:44:46.007
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			Point pg = new Point(intru.y,intru.x-1);
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(pd) && !configuration.Emplac_Sac.contains(pd)  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(pg) && !configuration.Emplac_Intrus.contains(pg) && !configuration.Emplac_Sac.contains(new Point(intru.y,intru.x-1))  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y+1,intru.x))&& !configuration.Emplac_Intrus.contains(new Point(intru.y+1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y+1,intru.x))  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Intrus.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-09-10 03:44:46.014
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-09-10 03:44:46.020
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:44:47.020
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			Point pg = new Point(intru.y,intru.x-1);
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(pd) && !configuration.Emplac_Sac.contains(pd)  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(pg) && !configuration.Emplac_Intrus.contains(pg) && !configuration.Emplac_Sac.contains(pg)  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y+1,intru.x))&& !configuration.Emplac_Intrus.contains(new Point(intru.y+1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y+1,intru.x))  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Intrus.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2020-09-10 03:44:47.028
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2020-09-10 03:44:47.034
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:44:47.248
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			Point pg = new Point(intru.y,intru.x-1);
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(pd) && !configuration.Emplac_Sac.contains(pd)  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(pg) && !configuration.Emplac_Intrus.contains(pg) && !configuration.Emplac_Sac.contains(pg)  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y+1,intru.x))&& !configuration.Emplac_Intrus.contains(new Point(intru.y+1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y+1,intru.x))  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Intrus.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-09-10 03:44:47.255
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-09-10 03:44:47.260
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:45:01.521
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			Point pg = new Point(intru.y,intru.x-1);
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(pd) && !configuration.Emplac_Sac.contains(pd)  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(pg) && !configuration.Emplac_Intrus.contains(pg) && !configuration.Emplac_Sac.contains(pg)  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y+1,intru.x))&& !configuration.Emplac_Intrus.contains(new Point(intru.y+1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y+1,intru.x))  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Intrus.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-09-10 03:45:01.528
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-09-10 03:45:01.534
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:45:05.711
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			Point pg = new Point(intru.y,intru.x-1);
			Point p
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(pd) && !configuration.Emplac_Sac.contains(pd)  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(pg) && !configuration.Emplac_Intrus.contains(pg) && !configuration.Emplac_Sac.contains(pg)  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y+1,intru.x))&& !configuration.Emplac_Intrus.contains(new Point(intru.y+1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y+1,intru.x))  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Intrus.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.internal.ui.text.java.PostfixCompletionProposalComputer.updateTemplateEngine(PostfixCompletionProposalComputer.java:153)
	at org.eclipse.jdt.internal.ui.text.java.PostfixCompletionProposalComputer.analyzeCoreContext(PostfixCompletionProposalComputer.java:121)
	at org.eclipse.jdt.internal.ui.text.java.PostfixCompletionProposalComputer.computeCompletionEngine(PostfixCompletionProposalComputer.java:110)
	at org.eclipse.jdt.internal.ui.text.java.AbstractTemplateCompletionProposalComputer.computeCompletionProposals(AbstractTemplateCompletionProposalComputer.java:71)
	at org.eclipse.jdt.internal.ui.text.java.CompletionProposalComputerDescriptor.computeCompletionProposals(CompletionProposalComputerDescriptor.java:345)
	at org.eclipse.jdt.internal.ui.text.java.CompletionProposalCategory.computeCompletionProposals(CompletionProposalCategory.java:340)
	at org.eclipse.jdt.internal.ui.text.java.ContentAssistProcessor.collectProposals(ContentAssistProcessor.java:333)
	at org.eclipse.jdt.internal.ui.text.java.ContentAssistProcessor.computeCompletionProposals(ContentAssistProcessor.java:289)
	at org.eclipse.jface.text.contentassist.AsyncCompletionProposalPopup.lambda$10(AsyncCompletionProposalPopup.java:351)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jface.text.contentassist.AsyncCompletionProposalPopup.lambda$9(AsyncCompletionProposalPopup.java:350)
	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java:1764)
	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.exec(CompletableFuture.java:1756)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:290)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1016)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1665)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1598)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:183)

!ENTRY org.eclipse.jdt.ui 2 0 2020-09-10 03:45:05.718
!MESSAGE The 'org.eclipse.jdt.ui.postfixCompletion' proposal computer from the 'org.eclipse.jdt.ui' plug-in did not complete normally. The extension has thrown a runtime exception.
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.internal.ui.text.java.PostfixCompletionProposalComputer.updateTemplateEngine(PostfixCompletionProposalComputer.java:153)
	at org.eclipse.jdt.internal.ui.text.java.PostfixCompletionProposalComputer.analyzeCoreContext(PostfixCompletionProposalComputer.java:121)
	at org.eclipse.jdt.internal.ui.text.java.PostfixCompletionProposalComputer.computeCompletionEngine(PostfixCompletionProposalComputer.java:110)
	at org.eclipse.jdt.internal.ui.text.java.AbstractTemplateCompletionProposalComputer.computeCompletionProposals(AbstractTemplateCompletionProposalComputer.java:71)
	at org.eclipse.jdt.internal.ui.text.java.CompletionProposalComputerDescriptor.computeCompletionProposals(CompletionProposalComputerDescriptor.java:345)
	at org.eclipse.jdt.internal.ui.text.java.CompletionProposalCategory.computeCompletionProposals(CompletionProposalCategory.java:340)
	at org.eclipse.jdt.internal.ui.text.java.ContentAssistProcessor.collectProposals(ContentAssistProcessor.java:333)
	at org.eclipse.jdt.internal.ui.text.java.ContentAssistProcessor.computeCompletionProposals(ContentAssistProcessor.java:289)
	at org.eclipse.jface.text.contentassist.AsyncCompletionProposalPopup.lambda$10(AsyncCompletionProposalPopup.java:351)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jface.text.contentassist.AsyncCompletionProposalPopup.lambda$9(AsyncCompletionProposalPopup.java:350)
	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java:1764)
	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.exec(CompletableFuture.java:1756)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:290)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1016)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1665)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1598)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:183)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:45:05.887
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			Point pg = new Point(intru.y,intru.x-1);
			Point pb
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(pd) && !configuration.Emplac_Sac.contains(pd)  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(pg) && !configuration.Emplac_Intrus.contains(pg) && !configuration.Emplac_Sac.contains(pg)  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y+1,intru.x))&& !configuration.Emplac_Intrus.contains(new Point(intru.y+1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y+1,intru.x))  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Intrus.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.internal.ui.text.java.PostfixCompletionProposalComputer.updateTemplateEngine(PostfixCompletionProposalComputer.java:153)
	at org.eclipse.jdt.internal.ui.text.java.PostfixCompletionProposalComputer.analyzeCoreContext(PostfixCompletionProposalComputer.java:121)
	at org.eclipse.jdt.internal.ui.text.java.PostfixCompletionProposalComputer.computeCompletionEngine(PostfixCompletionProposalComputer.java:110)
	at org.eclipse.jdt.internal.ui.text.java.AbstractTemplateCompletionProposalComputer.computeCompletionProposals(AbstractTemplateCompletionProposalComputer.java:71)
	at org.eclipse.jdt.internal.ui.text.java.CompletionProposalComputerDescriptor.computeCompletionProposals(CompletionProposalComputerDescriptor.java:345)
	at org.eclipse.jdt.internal.ui.text.java.CompletionProposalCategory.computeCompletionProposals(CompletionProposalCategory.java:340)
	at org.eclipse.jdt.internal.ui.text.java.ContentAssistProcessor.collectProposals(ContentAssistProcessor.java:333)
	at org.eclipse.jdt.internal.ui.text.java.ContentAssistProcessor.computeCompletionProposals(ContentAssistProcessor.java:289)
	at org.eclipse.jface.text.contentassist.AsyncCompletionProposalPopup.lambda$10(AsyncCompletionProposalPopup.java:351)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jface.text.contentassist.AsyncCompletionProposalPopup.lambda$9(AsyncCompletionProposalPopup.java:350)
	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java:1764)
	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.exec(CompletableFuture.java:1756)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:290)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1016)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1665)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1598)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:183)

!ENTRY org.eclipse.jdt.ui 2 0 2020-09-10 03:45:05.894
!MESSAGE The 'org.eclipse.jdt.ui.postfixCompletion' proposal computer from the 'org.eclipse.jdt.ui' plug-in did not complete normally. The extension has thrown a runtime exception.
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.internal.ui.text.java.PostfixCompletionProposalComputer.updateTemplateEngine(PostfixCompletionProposalComputer.java:153)
	at org.eclipse.jdt.internal.ui.text.java.PostfixCompletionProposalComputer.analyzeCoreContext(PostfixCompletionProposalComputer.java:121)
	at org.eclipse.jdt.internal.ui.text.java.PostfixCompletionProposalComputer.computeCompletionEngine(PostfixCompletionProposalComputer.java:110)
	at org.eclipse.jdt.internal.ui.text.java.AbstractTemplateCompletionProposalComputer.computeCompletionProposals(AbstractTemplateCompletionProposalComputer.java:71)
	at org.eclipse.jdt.internal.ui.text.java.CompletionProposalComputerDescriptor.computeCompletionProposals(CompletionProposalComputerDescriptor.java:345)
	at org.eclipse.jdt.internal.ui.text.java.CompletionProposalCategory.computeCompletionProposals(CompletionProposalCategory.java:340)
	at org.eclipse.jdt.internal.ui.text.java.ContentAssistProcessor.collectProposals(ContentAssistProcessor.java:333)
	at org.eclipse.jdt.internal.ui.text.java.ContentAssistProcessor.computeCompletionProposals(ContentAssistProcessor.java:289)
	at org.eclipse.jface.text.contentassist.AsyncCompletionProposalPopup.lambda$10(AsyncCompletionProposalPopup.java:351)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jface.text.contentassist.AsyncCompletionProposalPopup.lambda$9(AsyncCompletionProposalPopup.java:350)
	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java:1764)
	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.exec(CompletableFuture.java:1756)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:290)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1016)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1665)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1598)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:183)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:45:06.669
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			Point pg = new Point(intru.y,intru.x-1);
			Point pb
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(pd) && !configuration.Emplac_Sac.contains(pd)  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(pg) && !configuration.Emplac_Intrus.contains(pg) && !configuration.Emplac_Sac.contains(pg)  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y+1,intru.x))&& !configuration.Emplac_Intrus.contains(new Point(intru.y+1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y+1,intru.x))  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Intrus.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2020-09-10 03:45:06.676
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2020-09-10 03:45:06.682
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:45:06.708
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			Point pg = new Point(intru.y,intru.x-1);
			Point pb
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(pd) && !configuration.Emplac_Sac.contains(pd)  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(pg) && !configuration.Emplac_Intrus.contains(pg) && !configuration.Emplac_Sac.contains(pg)  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y+1,intru.x))&& !configuration.Emplac_Intrus.contains(new Point(intru.y+1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y+1,intru.x))  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Intrus.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:186)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-09-10 03:45:06.715
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:186)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-09-10 03:45:06.723
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:186)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:45:09.404
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			Point pg = new Point(intru.y,intru.x-1);
			Point pb
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(pd) && !configuration.Emplac_Sac.contains(pd)  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(pg) && !configuration.Emplac_Intrus.contains(pg) && !configuration.Emplac_Sac.contains(pg)  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y+1,intru.x))&& !configuration.Emplac_Intrus.contains(new Point(intru.y+1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y+1,intru.x))  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Intrus.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-09-10 03:45:09.411
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-09-10 03:45:09.417
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:45:09.448
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			Point pg = new Point(intru.y,intru.x-1);
			Point pb
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(pd) && !configuration.Emplac_Sac.contains(pd)  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(pg) && !configuration.Emplac_Intrus.contains(pg) && !configuration.Emplac_Sac.contains(pg)  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(intru.y+1,intru.x))&& !configuration.Emplac_Intrus.contains(new Point(intru.y+1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y+1,intru.x))  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Intrus.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1015)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:811)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:678)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:670)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-09-10 03:45:09.455
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1015)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:811)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:678)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:670)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-09-10 03:45:09.461
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1015)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:811)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:678)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:670)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:45:16.773
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			Point pg = new Point(intru.y,intru.x-1);
			Point pb = new Point(intru.y+1,intru.x)
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(pd) && !configuration.Emplac_Sac.contains(pd)  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(pg) && !configuration.Emplac_Intrus.contains(pg) && !configuration.Emplac_Sac.contains(pg)  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains()&& !configuration.Emplac_Intrus.contains(new Point(intru.y+1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y+1,intru.x))  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Intrus.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2020-09-10 03:45:16.781
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2020-09-10 03:45:16.787
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:45:16.812
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			Point pg = new Point(intru.y,intru.x-1);
			Point pb = new Point(intru.y+1,intru.x)
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(pd) && !configuration.Emplac_Sac.contains(pd)  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(pg) && !configuration.Emplac_Intrus.contains(pg) && !configuration.Emplac_Sac.contains(pg)  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains()&& !configuration.Emplac_Intrus.contains(new Point(intru.y+1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y+1,intru.x))  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Intrus.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:186)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-09-10 03:45:16.819
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:186)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-09-10 03:45:16.825
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:186)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:45:16.850
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			Point pg = new Point(intru.y,intru.x-1);
			Point pb = new Point(intru.y+1,intru.x)
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(pd) && !configuration.Emplac_Sac.contains(pd)  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(pg) && !configuration.Emplac_Intrus.contains(pg) && !configuration.Emplac_Sac.contains(pg)  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains()&& !configuration.Emplac_Intrus.contains(new Point(intru.y+1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y+1,intru.x))  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Intrus.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:186)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-09-10 03:45:16.856
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:186)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-09-10 03:45:16.863
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:186)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:45:17.814
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			Point pg = new Point(intru.y,intru.x-1);
			Point pb = new Point(intru.y+1,intru.x);
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(pd) && !configuration.Emplac_Sac.contains(pd)  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(pg) && !configuration.Emplac_Intrus.contains(pg) && !configuration.Emplac_Sac.contains(pg)  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains()&& !configuration.Emplac_Intrus.contains(new Point(intru.y+1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y+1,intru.x))  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Intrus.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2020-09-10 03:45:17.821
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2020-09-10 03:45:17.827
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:45:17.855
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			Point pg = new Point(intru.y,intru.x-1);
			Point pb = new Point(intru.y+1,intru.x);
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(pd) && !configuration.Emplac_Sac.contains(pd)  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(pg) && !configuration.Emplac_Intrus.contains(pg) && !configuration.Emplac_Sac.contains(pg)  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains()&& !configuration.Emplac_Intrus.contains(new Point(intru.y+1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y+1,intru.x))  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Intrus.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:186)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-09-10 03:45:17.862
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:186)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-09-10 03:45:17.868
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:186)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:45:19.201
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			Point pg = new Point(intru.y,intru.x-1);
			Point pb = new Point(intru.y+1,intru.x);
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(pd) && !configuration.Emplac_Sac.contains(pd)  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(pg) && !configuration.Emplac_Intrus.contains(pg) && !configuration.Emplac_Sac.contains(pg)  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains()&& !configuration.Emplac_Intrus.contains(new Point(intru.y+1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y+1,intru.x))  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Intrus.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-09-10 03:45:19.208
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-09-10 03:45:19.214
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:45:19.247
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			Point pg = new Point(intru.y,intru.x-1);
			Point pb = new Point(intru.y+1,intru.x);
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(pd) && !configuration.Emplac_Sac.contains(pd)  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(pg) && !configuration.Emplac_Intrus.contains(pg) && !configuration.Emplac_Sac.contains(pg)  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains()&& !configuration.Emplac_Intrus.contains(new Point(intru.y+1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y+1,intru.x))  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Intrus.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1015)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:811)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:678)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:670)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-09-10 03:45:19.253
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1015)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:811)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:678)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:670)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-09-10 03:45:19.259
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1015)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:811)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:678)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:670)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:45:19.283
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			Point pg = new Point(intru.y,intru.x-1);
			Point pb = new Point(intru.y+1,intru.x);
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(pd) && !configuration.Emplac_Sac.contains(pd)  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(pg) && !configuration.Emplac_Intrus.contains(pg) && !configuration.Emplac_Sac.contains(pg)  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains()&& !configuration.Emplac_Intrus.contains(new Point(intru.y+1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y+1,intru.x))  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Intrus.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:186)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-09-10 03:45:19.290
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:186)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-09-10 03:45:19.296
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:186)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:45:20.438
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			Point pg = new Point(intru.y,intru.x-1);
			Point pb = new Point(intru.y+1,intru.x);
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(pd) && !configuration.Emplac_Sac.contains(pd)  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(pg) && !configuration.Emplac_Intrus.contains(pg) && !configuration.Emplac_Sac.contains(pg)  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains()&& !configuration.Emplac_Intrus.contains(new Point(intru.y+1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y+1,intru.x))  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Intrus.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-09-10 03:45:20.444
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-09-10 03:45:20.450
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:45:23.858
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			Point pg = new Point(intru.y,intru.x-1);
			Point pb = new Point(intru.y+1,intru.x);
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(pd) && !configuration.Emplac_Sac.contains(pd)  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(pg) && !configuration.Emplac_Intrus.contains(pg) && !configuration.Emplac_Sac.contains(pg)  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(pb)&& !configuration.Emplac_Intrus.contains(new Point(intru.y+1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y+1,intru.x))  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Intrus.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2020-09-10 03:45:23.865
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2020-09-10 03:45:23.871
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:45:24.092
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			Point pg = new Point(intru.y,intru.x-1);
			Point pb = new Point(intru.y+1,intru.x);
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(pd) && !configuration.Emplac_Sac.contains(pd)  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(pg) && !configuration.Emplac_Intrus.contains(pg) && !configuration.Emplac_Sac.contains(pg)  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(pb)&& !configuration.Emplac_Intrus.contains(new Point(intru.y+1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y+1,intru.x))  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Intrus.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-09-10 03:45:24.098
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-09-10 03:45:24.104
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:45:27.185
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			Point pg = new Point(intru.y,intru.x-1);
			Point pb = new Point(intru.y+1,intru.x);
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(pd) && !configuration.Emplac_Sac.contains(pd)  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(pg) && !configuration.Emplac_Intrus.contains(pg) && !configuration.Emplac_Sac.contains(pg)  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(pb)&& !configuration.Emplac_Intrus.contains(new Point(intru.y+1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y+1,intru.x))  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Intrus.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-09-10 03:45:27.191
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-09-10 03:45:27.196
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:45:28.188
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			Point pg = new Point(intru.y,intru.x-1);
			Point pb = new Point(intru.y+1,intru.x);
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(pd) && !configuration.Emplac_Sac.contains(pd)  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(pg) && !configuration.Emplac_Intrus.contains(pg) && !configuration.Emplac_Sac.contains(pg)  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(pb)&& !configuration.Emplac_Intrus.contains(new Point(intru.y+1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y+1,intru.x))  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Intrus.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-09-10 03:45:28.195
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-09-10 03:45:28.202
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:45:28.899
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			Point pg = new Point(intru.y,intru.x-1);
			Point pb = new Point(intru.y+1,intru.x);
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(pd) && !configuration.Emplac_Sac.contains(pd)  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(pg) && !configuration.Emplac_Intrus.contains(pg) && !configuration.Emplac_Sac.contains(pg)  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(pb)&& !configuration.Emplac_Intrus.contains(pb) && !configuration.Emplac_Sac.contains(new Point(intru.y+1,intru.x))  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Intrus.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2020-09-10 03:45:28.906
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2020-09-10 03:45:28.911
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:45:29.036
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			Point pg = new Point(intru.y,intru.x-1);
			Point pb = new Point(intru.y+1,intru.x);
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(pd) && !configuration.Emplac_Sac.contains(pd)  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(pg) && !configuration.Emplac_Intrus.contains(pg) && !configuration.Emplac_Sac.contains(pg)  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(pb)&& !configuration.Emplac_Intrus.contains(pb) && !configuration.Emplac_Sac.contains(new Point(intru.y+1,intru.x))  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Intrus.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-09-10 03:45:29.043
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-09-10 03:45:29.048
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:45:30.445
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			Point pg = new Point(intru.y,intru.x-1);
			Point pb = new Point(intru.y+1,intru.x);
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(pd) && !configuration.Emplac_Sac.contains(pd)  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(pg) && !configuration.Emplac_Intrus.contains(pg) && !configuration.Emplac_Sac.contains(pg)  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(pb)&& !configuration.Emplac_Intrus.contains(pb) && !configuration.Emplac_Sac.contains(new Point(intru.y+1,intru.x))  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Intrus.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-09-10 03:45:31.558
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-09-10 03:45:31.564
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:45:34.129
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			Point pg = new Point(intru.y,intru.x-1);
			Point pb = new Point(intru.y+1,intru.x);
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(pd) && !configuration.Emplac_Sac.contains(pd)  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(pg) && !configuration.Emplac_Intrus.contains(pg) && !configuration.Emplac_Sac.contains(pg)  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(pb)&& !configuration.Emplac_Intrus.contains(pb) && !configuration.Emplac_Sac.contains(new Point(intru.y+1,intru.x))  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Intrus.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-09-10 03:45:34.135
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-09-10 03:45:34.140
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:45:34.944
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			Point pg = new Point(intru.y,intru.x-1);
			Point pb = new Point(intru.y+1,intru.x);
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(pd) && !configuration.Emplac_Sac.contains(pd)  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(pg) && !configuration.Emplac_Intrus.contains(pg) && !configuration.Emplac_Sac.contains(pg)  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(pb)&& !configuration.Emplac_Intrus.contains(pb) && !configuration.Emplac_Sac.contains(pb)  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Intrus.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2020-09-10 03:45:34.950
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2020-09-10 03:45:34.956
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:45:34.981
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			Point pg = new Point(intru.y,intru.x-1);
			Point pb = new Point(intru.y+1,intru.x);
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(pd) && !configuration.Emplac_Sac.contains(pd)  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(pg) && !configuration.Emplac_Intrus.contains(pg) && !configuration.Emplac_Sac.contains(pg)  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(pb)&& !configuration.Emplac_Intrus.contains(pb) && !configuration.Emplac_Sac.contains(pb)  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Intrus.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:186)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-09-10 03:45:34.987
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:186)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-09-10 03:45:34.993
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:186)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:45:44.083
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			Point pg = new Point(intru.y,intru.x-1);
			Point pb = new Point(intru.y+1,intru.x);
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(pd) && !configuration.Emplac_Sac.contains(pd)  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(pg) && !configuration.Emplac_Intrus.contains(pg) && !configuration.Emplac_Sac.contains(pg)  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(pb)&& !configuration.Emplac_Intrus.contains(pb) && !configuration.Emplac_Sac.contains(pb)  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Intrus.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-09-10 03:45:44.090
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-09-10 03:45:44.096
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:45:46.248
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			Point pg = new Point(intru.y,intru.x-1);
			Point pb = new Point(intru.y+1,intru.x);
			Point p
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(pd) && !configuration.Emplac_Sac.contains(pd)  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(pg) && !configuration.Emplac_Intrus.contains(pg) && !configuration.Emplac_Sac.contains(pg)  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(pb)&& !configuration.Emplac_Intrus.contains(pb) && !configuration.Emplac_Sac.contains(pb)  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Intrus.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.internal.ui.text.java.PostfixCompletionProposalComputer.updateTemplateEngine(PostfixCompletionProposalComputer.java:153)
	at org.eclipse.jdt.internal.ui.text.java.PostfixCompletionProposalComputer.analyzeCoreContext(PostfixCompletionProposalComputer.java:121)
	at org.eclipse.jdt.internal.ui.text.java.PostfixCompletionProposalComputer.computeCompletionEngine(PostfixCompletionProposalComputer.java:110)
	at org.eclipse.jdt.internal.ui.text.java.AbstractTemplateCompletionProposalComputer.computeCompletionProposals(AbstractTemplateCompletionProposalComputer.java:71)
	at org.eclipse.jdt.internal.ui.text.java.CompletionProposalComputerDescriptor.computeCompletionProposals(CompletionProposalComputerDescriptor.java:345)
	at org.eclipse.jdt.internal.ui.text.java.CompletionProposalCategory.computeCompletionProposals(CompletionProposalCategory.java:340)
	at org.eclipse.jdt.internal.ui.text.java.ContentAssistProcessor.collectProposals(ContentAssistProcessor.java:333)
	at org.eclipse.jdt.internal.ui.text.java.ContentAssistProcessor.computeCompletionProposals(ContentAssistProcessor.java:289)
	at org.eclipse.jface.text.contentassist.AsyncCompletionProposalPopup.lambda$10(AsyncCompletionProposalPopup.java:351)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jface.text.contentassist.AsyncCompletionProposalPopup.lambda$9(AsyncCompletionProposalPopup.java:350)
	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java:1764)
	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.exec(CompletableFuture.java:1756)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:290)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1016)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1665)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1598)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:183)

!ENTRY org.eclipse.jdt.ui 2 0 2020-09-10 03:45:46.255
!MESSAGE The 'org.eclipse.jdt.ui.postfixCompletion' proposal computer from the 'org.eclipse.jdt.ui' plug-in did not complete normally. The extension has thrown a runtime exception.
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.internal.ui.text.java.PostfixCompletionProposalComputer.updateTemplateEngine(PostfixCompletionProposalComputer.java:153)
	at org.eclipse.jdt.internal.ui.text.java.PostfixCompletionProposalComputer.analyzeCoreContext(PostfixCompletionProposalComputer.java:121)
	at org.eclipse.jdt.internal.ui.text.java.PostfixCompletionProposalComputer.computeCompletionEngine(PostfixCompletionProposalComputer.java:110)
	at org.eclipse.jdt.internal.ui.text.java.AbstractTemplateCompletionProposalComputer.computeCompletionProposals(AbstractTemplateCompletionProposalComputer.java:71)
	at org.eclipse.jdt.internal.ui.text.java.CompletionProposalComputerDescriptor.computeCompletionProposals(CompletionProposalComputerDescriptor.java:345)
	at org.eclipse.jdt.internal.ui.text.java.CompletionProposalCategory.computeCompletionProposals(CompletionProposalCategory.java:340)
	at org.eclipse.jdt.internal.ui.text.java.ContentAssistProcessor.collectProposals(ContentAssistProcessor.java:333)
	at org.eclipse.jdt.internal.ui.text.java.ContentAssistProcessor.computeCompletionProposals(ContentAssistProcessor.java:289)
	at org.eclipse.jface.text.contentassist.AsyncCompletionProposalPopup.lambda$10(AsyncCompletionProposalPopup.java:351)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jface.text.contentassist.AsyncCompletionProposalPopup.lambda$9(AsyncCompletionProposalPopup.java:350)
	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java:1764)
	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.exec(CompletableFuture.java:1756)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:290)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1016)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1665)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1598)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:183)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:45:46.993
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			Point pg = new Point(intru.y,intru.x-1);
			Point pb = new Point(intru.y+1,intru.x);
			Point p
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(pd) && !configuration.Emplac_Sac.contains(pd)  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(pg) && !configuration.Emplac_Intrus.contains(pg) && !configuration.Emplac_Sac.contains(pg)  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(pb)&& !configuration.Emplac_Intrus.contains(pb) && !configuration.Emplac_Sac.contains(pb)  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Intrus.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2020-09-10 03:45:47.000
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2020-09-10 03:45:47.006
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:45:47.043
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			Point pg = new Point(intru.y,intru.x-1);
			Point pb = new Point(intru.y+1,intru.x);
			Point p
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(pd) && !configuration.Emplac_Sac.contains(pd)  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(pg) && !configuration.Emplac_Intrus.contains(pg) && !configuration.Emplac_Sac.contains(pg)  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(pb)&& !configuration.Emplac_Intrus.contains(pb) && !configuration.Emplac_Sac.contains(pb)  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Intrus.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-09-10 03:45:47.050
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-09-10 03:45:47.056
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:45:49.573
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			Point pg = new Point(intru.y,intru.x-1);
			Point pb = new Point(intru.y+1,intru.x);
			Point ph
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(pd) && !configuration.Emplac_Sac.contains(pd)  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(pg) && !configuration.Emplac_Intrus.contains(pg) && !configuration.Emplac_Sac.contains(pg)  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(pb)&& !configuration.Emplac_Intrus.contains(pb) && !configuration.Emplac_Sac.contains(pb)  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Intrus.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.internal.ui.text.java.PostfixCompletionProposalComputer.updateTemplateEngine(PostfixCompletionProposalComputer.java:153)
	at org.eclipse.jdt.internal.ui.text.java.PostfixCompletionProposalComputer.analyzeCoreContext(PostfixCompletionProposalComputer.java:121)
	at org.eclipse.jdt.internal.ui.text.java.PostfixCompletionProposalComputer.computeCompletionEngine(PostfixCompletionProposalComputer.java:110)
	at org.eclipse.jdt.internal.ui.text.java.AbstractTemplateCompletionProposalComputer.computeCompletionProposals(AbstractTemplateCompletionProposalComputer.java:71)
	at org.eclipse.jdt.internal.ui.text.java.CompletionProposalComputerDescriptor.computeCompletionProposals(CompletionProposalComputerDescriptor.java:345)
	at org.eclipse.jdt.internal.ui.text.java.CompletionProposalCategory.computeCompletionProposals(CompletionProposalCategory.java:340)
	at org.eclipse.jdt.internal.ui.text.java.ContentAssistProcessor.collectProposals(ContentAssistProcessor.java:333)
	at org.eclipse.jdt.internal.ui.text.java.ContentAssistProcessor.computeCompletionProposals(ContentAssistProcessor.java:289)
	at org.eclipse.jface.text.contentassist.AsyncCompletionProposalPopup.lambda$10(AsyncCompletionProposalPopup.java:351)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jface.text.contentassist.AsyncCompletionProposalPopup.lambda$9(AsyncCompletionProposalPopup.java:350)
	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java:1764)
	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.exec(CompletableFuture.java:1756)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:290)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1016)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1665)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1598)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:183)

!ENTRY org.eclipse.jdt.ui 2 0 2020-09-10 03:45:49.580
!MESSAGE The 'org.eclipse.jdt.ui.postfixCompletion' proposal computer from the 'org.eclipse.jdt.ui' plug-in did not complete normally. The extension has thrown a runtime exception.
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.internal.ui.text.java.PostfixCompletionProposalComputer.updateTemplateEngine(PostfixCompletionProposalComputer.java:153)
	at org.eclipse.jdt.internal.ui.text.java.PostfixCompletionProposalComputer.analyzeCoreContext(PostfixCompletionProposalComputer.java:121)
	at org.eclipse.jdt.internal.ui.text.java.PostfixCompletionProposalComputer.computeCompletionEngine(PostfixCompletionProposalComputer.java:110)
	at org.eclipse.jdt.internal.ui.text.java.AbstractTemplateCompletionProposalComputer.computeCompletionProposals(AbstractTemplateCompletionProposalComputer.java:71)
	at org.eclipse.jdt.internal.ui.text.java.CompletionProposalComputerDescriptor.computeCompletionProposals(CompletionProposalComputerDescriptor.java:345)
	at org.eclipse.jdt.internal.ui.text.java.CompletionProposalCategory.computeCompletionProposals(CompletionProposalCategory.java:340)
	at org.eclipse.jdt.internal.ui.text.java.ContentAssistProcessor.collectProposals(ContentAssistProcessor.java:333)
	at org.eclipse.jdt.internal.ui.text.java.ContentAssistProcessor.computeCompletionProposals(ContentAssistProcessor.java:289)
	at org.eclipse.jface.text.contentassist.AsyncCompletionProposalPopup.lambda$10(AsyncCompletionProposalPopup.java:351)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jface.text.contentassist.AsyncCompletionProposalPopup.lambda$9(AsyncCompletionProposalPopup.java:350)
	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java:1764)
	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.exec(CompletableFuture.java:1756)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:290)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1016)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1665)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1598)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:183)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:45:50.536
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			Point pg = new Point(intru.y,intru.x-1);
			Point pb = new Point(intru.y+1,intru.x);
			Point ph
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(pd) && !configuration.Emplac_Sac.contains(pd)  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(pg) && !configuration.Emplac_Intrus.contains(pg) && !configuration.Emplac_Sac.contains(pg)  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(pb)&& !configuration.Emplac_Intrus.contains(pb) && !configuration.Emplac_Sac.contains(pb)  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Intrus.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2020-09-10 03:45:50.543
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2020-09-10 03:45:50.550
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:46:00.677
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			Point pg = new Point(intru.y,intru.x-1);
			Point pb = new Point(intru.y+1,intru.x);
			Point ph = new Point(intru.y-1,intru.x)
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(pd) && !configuration.Emplac_Sac.contains(pd)  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(pg) && !configuration.Emplac_Intrus.contains(pg) && !configuration.Emplac_Sac.contains(pg)  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(pb)&& !configuration.Emplac_Intrus.contains(pb) && !configuration.Emplac_Sac.contains(pb)  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains() && !configuration.Emplac_Intrus.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2020-09-10 03:46:00.684
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2020-09-10 03:46:00.689
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:46:00.714
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			Point pg = new Point(intru.y,intru.x-1);
			Point pb = new Point(intru.y+1,intru.x);
			Point ph = new Point(intru.y-1,intru.x)
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(pd) && !configuration.Emplac_Sac.contains(pd)  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(pg) && !configuration.Emplac_Intrus.contains(pg) && !configuration.Emplac_Sac.contains(pg)  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(pb)&& !configuration.Emplac_Intrus.contains(pb) && !configuration.Emplac_Sac.contains(pb)  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains() && !configuration.Emplac_Intrus.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:186)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-09-10 03:46:00.720
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:186)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-09-10 03:46:00.726
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:186)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:46:00.750
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			Point pg = new Point(intru.y,intru.x-1);
			Point pb = new Point(intru.y+1,intru.x);
			Point ph = new Point(intru.y-1,intru.x)
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(pd) && !configuration.Emplac_Sac.contains(pd)  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(pg) && !configuration.Emplac_Intrus.contains(pg) && !configuration.Emplac_Sac.contains(pg)  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(pb)&& !configuration.Emplac_Intrus.contains(pb) && !configuration.Emplac_Sac.contains(pb)  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains() && !configuration.Emplac_Intrus.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:186)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:186)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-09-10 03:46:00.756
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:186)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:186)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-09-10 03:46:00.762
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:186)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:186)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:46:02.216
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			Point pg = new Point(intru.y,intru.x-1);
			Point pb = new Point(intru.y+1,intru.x);
			Point ph = new Point(intru.y-1,intru.x);
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(pd) && !configuration.Emplac_Sac.contains(pd)  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(pg) && !configuration.Emplac_Intrus.contains(pg) && !configuration.Emplac_Sac.contains(pg)  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(pb)&& !configuration.Emplac_Intrus.contains(pb) && !configuration.Emplac_Sac.contains(pb)  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains() && !configuration.Emplac_Intrus.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2020-09-10 03:46:02.223
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2020-09-10 03:46:02.228
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:46:02.253
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			Point pg = new Point(intru.y,intru.x-1);
			Point pb = new Point(intru.y+1,intru.x);
			Point ph = new Point(intru.y-1,intru.x);
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(pd) && !configuration.Emplac_Sac.contains(pd)  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(pg) && !configuration.Emplac_Intrus.contains(pg) && !configuration.Emplac_Sac.contains(pg)  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(pb)&& !configuration.Emplac_Intrus.contains(pb) && !configuration.Emplac_Sac.contains(pb)  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains() && !configuration.Emplac_Intrus.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:186)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-09-10 03:46:02.260
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:186)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-09-10 03:46:02.266
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:186)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:46:06.489
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			Point pg = new Point(intru.y,intru.x-1);
			Point pb = new Point(intru.y+1,intru.x);
			Point ph = new Point(intru.y-1,intru.x);
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(pd) && !configuration.Emplac_Sac.contains(pd)  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(pg) && !configuration.Emplac_Intrus.contains(pg) && !configuration.Emplac_Sac.contains(pg)  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(pb)&& !configuration.Emplac_Intrus.contains(pb) && !configuration.Emplac_Sac.contains(pb)  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains() && !configuration.Emplac_Intrus.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-09-10 03:46:06.496
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-09-10 03:46:06.502
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
