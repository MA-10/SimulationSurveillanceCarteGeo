!SESSION 2020-09-10 01:56:40.352 -----------------------------------------------
eclipse.buildId=4.16.0.I20200604-0540
java.version=14.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=fr_FR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

This is a continuation of log file D:\Projet\.metadata\.bak_2.log
Created Time: 2020-09-10 03:46:09.761

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:46:09.767
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			Point pg = new Point(intru.y,intru.x-1);
			Point pb = new Point(intru.y+1,intru.x);
			Point ph = new Point(intru.y-1,intru.x);
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(pd) && !configuration.Emplac_Sac.contains(pd)  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(pg) && !configuration.Emplac_Intrus.contains(pg) && !configuration.Emplac_Sac.contains(pg)  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(pb)&& !configuration.Emplac_Intrus.contains(pb) && !configuration.Emplac_Sac.contains(pb)  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(ph) && !configuration.Emplac_Intrus.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2020-09-10 03:46:09.774
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2020-09-10 03:46:09.781
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:46:09.936
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			Point pg = new Point(intru.y,intru.x-1);
			Point pb = new Point(intru.y+1,intru.x);
			Point ph = new Point(intru.y-1,intru.x);
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(pd) && !configuration.Emplac_Sac.contains(pd)  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(pg) && !configuration.Emplac_Intrus.contains(pg) && !configuration.Emplac_Sac.contains(pg)  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(pb)&& !configuration.Emplac_Intrus.contains(pb) && !configuration.Emplac_Sac.contains(pb)  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(ph) && !configuration.Emplac_Intrus.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-09-10 03:46:09.943
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-09-10 03:46:09.949
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:46:10.749
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			Point pg = new Point(intru.y,intru.x-1);
			Point pb = new Point(intru.y+1,intru.x);
			Point ph = new Point(intru.y-1,intru.x);
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(pd) && !configuration.Emplac_Sac.contains(pd)  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(pg) && !configuration.Emplac_Intrus.contains(pg) && !configuration.Emplac_Sac.contains(pg)  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(pb)&& !configuration.Emplac_Intrus.contains(pb) && !configuration.Emplac_Sac.contains(pb)  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(ph) && !configuration.Emplac_Intrus.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-09-10 03:46:10.755
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-09-10 03:46:10.762
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:46:14.998
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			Point pg = new Point(intru.y,intru.x-1);
			Point pb = new Point(intru.y+1,intru.x);
			Point ph = new Point(intru.y-1,intru.x);
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(pd) && !configuration.Emplac_Sac.contains(pd)  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(pg) && !configuration.Emplac_Intrus.contains(pg) && !configuration.Emplac_Sac.contains(pg)  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(pb)&& !configuration.Emplac_Intrus.contains(pb) && !configuration.Emplac_Sac.contains(pb)  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(ph) && !configuration.Emplac_Intrus.contains(new Point(intru.y-1,intru.x)) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-09-10 03:46:15.005
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-09-10 03:46:15.011
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:46:15.814
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			Point pg = new Point(intru.y,intru.x-1);
			Point pb = new Point(intru.y+1,intru.x);
			Point ph = new Point(intru.y-1,intru.x);
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(pd) && !configuration.Emplac_Sac.contains(pd)  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(pg) && !configuration.Emplac_Intrus.contains(pg) && !configuration.Emplac_Sac.contains(pg)  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(pb)&& !configuration.Emplac_Intrus.contains(pb) && !configuration.Emplac_Sac.contains(pb)  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(ph) && !configuration.Emplac_Intrus.contains(ph) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2020-09-10 03:46:15.821
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2020-09-10 03:46:15.827
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:46:15.989
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			Point pg = new Point(intru.y,intru.x-1);
			Point pb = new Point(intru.y+1,intru.x);
			Point ph = new Point(intru.y-1,intru.x);
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(pd) && !configuration.Emplac_Sac.contains(pd)  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(pg) && !configuration.Emplac_Intrus.contains(pg) && !configuration.Emplac_Sac.contains(pg)  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(pb)&& !configuration.Emplac_Intrus.contains(pb) && !configuration.Emplac_Sac.contains(pb)  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(ph) && !configuration.Emplac_Intrus.contains(ph) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-09-10 03:46:15.996
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-09-10 03:46:16.001
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:46:22.065
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			Point pg = new Point(intru.y,intru.x-1);
			Point pb = new Point(intru.y+1,intru.x);
			Point ph = new Point(intru.y-1,intru.x);
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(pd) && !configuration.Emplac_Sac.contains(pd)  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(pg) && !configuration.Emplac_Intrus.contains(pg) && !configuration.Emplac_Sac.contains(pg)  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(pb)&& !configuration.Emplac_Intrus.contains(pb) && !configuration.Emplac_Sac.contains(pb)  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(ph) && !configuration.Emplac_Intrus.contains(ph) && !configuration.Emplac_Sac.contains(new Point(intru.y-1,intru.x)) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-09-10 03:46:22.072
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-09-10 03:46:22.078
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:46:22.860
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			Point pg = new Point(intru.y,intru.x-1);
			Point pb = new Point(intru.y+1,intru.x);
			Point ph = new Point(intru.y-1,intru.x);
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(pd) && !configuration.Emplac_Sac.contains(pd)  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(pg) && !configuration.Emplac_Intrus.contains(pg) && !configuration.Emplac_Sac.contains(pg)  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(pb)&& !configuration.Emplac_Intrus.contains(pb) && !configuration.Emplac_Sac.contains(pb)  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(ph) && !configuration.Emplac_Intrus.contains(ph) && !configuration.Emplac_Sac.contains(ph) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2020-09-10 03:46:22.866
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2020-09-10 03:46:22.873
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:46:22.926
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			Point pg = new Point(intru.y,intru.x-1);
			Point pb = new Point(intru.y+1,intru.x);
			Point ph = new Point(intru.y-1,intru.x);
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(pd) && !configuration.Emplac_Sac.contains(pd)  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(pg) && !configuration.Emplac_Intrus.contains(pg) && !configuration.Emplac_Sac.contains(pg)  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(pb)&& !configuration.Emplac_Intrus.contains(pb) && !configuration.Emplac_Sac.contains(pb)  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(ph) && !configuration.Emplac_Intrus.contains(ph) && !configuration.Emplac_Sac.contains(ph) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-09-10 03:46:22.934
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-09-10 03:46:22.940
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:46:27.362
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			Point pg = new Point(intru.y,intru.x-1);
			Point pb = new Point(intru.y+1,intru.x);
			Point ph = new Point(intru.y-1,intru.x);
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(pd) && !configuration.Emplac_Sac.contains(pd)  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(pg) && !configuration.Emplac_Intrus.contains(pg) && !configuration.Emplac_Sac.contains(pg)  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(pb)&& !configuration.Emplac_Intrus.contains(pb) && !configuration.Emplac_Sac.contains(pb)  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(ph) && !configuration.Emplac_Intrus.contains(ph) && !configuration.Emplac_Sac.contains(ph) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-09-10 03:46:27.369
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-09-10 03:46:27.375
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:46:27.588
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			Point pg = new Point(intru.y,intru.x-1);
			Point pb = new Point(intru.y+1,intru.x);
			Point ph = new Point(intru.y-1,intru.x);
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(pd) && !configuration.Emplac_Sac.contains(pd)  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(pg) && !configuration.Emplac_Intrus.contains(pg) && !configuration.Emplac_Sac.contains(pg)  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(pb)&& !configuration.Emplac_Intrus.contains(pb) && !configuration.Emplac_Sac.contains(pb)  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(ph) && !configuration.Emplac_Intrus.contains(ph) && !configuration.Emplac_Sac.contains(ph) )
			
			return false;
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-09-10 03:46:27.595
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-09-10 03:46:27.602
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:46:28.419
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			Point pg = new Point(intru.y,intru.x-1);
			Point pb = new Point(intru.y+1,intru.x);
			Point ph = new Point(intru.y-1,intru.x);
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(pd) && !configuration.Emplac_Sac.contains(pd)  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(pg) && !configuration.Emplac_Intrus.contains(pg) && !configuration.Emplac_Sac.contains(pg)  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(pb)&& !configuration.Emplac_Intrus.contains(pb) && !configuration.Emplac_Sac.contains(pb)  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(ph) && !configuration.Emplac_Intrus.contains(ph) && !configuration.Emplac_Sac.contains(ph) )
			
			
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2020-09-10 03:46:28.427
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2020-09-10 03:46:28.434
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:46:28.472
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			Point pg = new Point(intru.y,intru.x-1);
			Point pb = new Point(intru.y+1,intru.x);
			Point ph = new Point(intru.y-1,intru.x);
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(pd) && !configuration.Emplac_Sac.contains(pd)  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(pg) && !configuration.Emplac_Intrus.contains(pg) && !configuration.Emplac_Sac.contains(pg)  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(pb)&& !configuration.Emplac_Intrus.contains(pb) && !configuration.Emplac_Sac.contains(pb)  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(ph) && !configuration.Emplac_Intrus.contains(ph) && !configuration.Emplac_Sac.contains(ph) )
			
			
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-09-10 03:46:28.479
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-09-10 03:46:28.486
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:46:29.858
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			Point pg = new Point(intru.y,intru.x-1);
			Point pb = new Point(intru.y+1,intru.x);
			Point ph = new Point(intru.y-1,intru.x);
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(pd) && !configuration.Emplac_Sac.contains(pd)  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(pg) && !configuration.Emplac_Intrus.contains(pg) && !configuration.Emplac_Sac.contains(pg)  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(pb)&& !configuration.Emplac_Intrus.contains(pb) && !configuration.Emplac_Sac.contains(pb)  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(ph) && !configuration.Emplac_Intrus.contains(ph) && !configuration.Emplac_Sac.contains(ph) )
			
			
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-09-10 03:46:29.865
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-09-10 03:46:29.871
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-10 03:46:29.953
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.plaf.basic.BasicOptionPaneUI.ButtonActionListener;




public class Map extends JPanel implements KeyListener,MouseListener {
	int width,height,cellWidth,cellHeight;
	private ConfigurationModel configuration ;
	private Vector<Robot> robots = new Vector<Robot>();
	private Vector<Intru> intrus = new Vector<Intru>();
	private Vector<Sac> sacs = new Vector<Sac>();
	private Vector<Obstacle> obstacles = new Vector<Obstacle>();
	private Vector<Sortie> sorties = new Vector<Sortie>();
	private int joueurActif ;
	private boolean jeuArrete;
	
	public Map(ConfigurationModel configuration) {
		this.configuration = configuration ; 
		joueurActif = 1;
		jeuArrete = true;
		width=getWidth();
		height=getHeight();
		cellWidth =50;
		cellHeight =50;
		prepare();
		changerTour();
		this.addKeyListener(this);
		this.addMouseListener(this);
        this.setFocusable(true);
        this.requestFocusInWindow();
        
        
         
	}
	// Changer automatiquement le tour chaque 3 secondes
	private void changerTour()
	{
		Timer timer = new Timer();
		TimerTask  timerTask = new TimerTask() {
			int secondPassed = 0 ;
			@Override
			public void run() {
				secondPassed ++ ; 
				System.out.println("Il reste "+secondPassed+" secondes pourque le joueur " + joueurActif + " joue son tour !");
				if (!jeuArrete) {
					if (secondPassed == 3 && joueurActif == 1) {
						secondPassed =0;
						joueurActif =2;
					}
					if (secondPassed == 3 && joueurActif == 2) {
						secondPassed =0;
						joueurActif =1;
					}
				}
				if (jeuArrete) {
					secondPassed = 0 ;
				}
				
			}
		};
		timer.scheduleAtFixedRate(timerTask, 1000, 1000);
	}
	// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
	private void prepare()
	
	{
		for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
			int x= configuration.Emplac_Intrus.get(i).x;
			int y= configuration.Emplac_Intrus.get(i).y;
			Intru intru = new Intru(y, x, 1000);
			intrus.add(intru);
			MoveIntrus moveIntrus =new MoveIntrus(intru);
			moveIntrus.start();
		}
		for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
			int x= configuration.Emplac_Robots.get(i).x;
			int y= configuration.Emplac_Robots.get(i).y;
			Robot robot = new Robot(y,x, 500);
			robots.add(robot);
			MoveRobots moveRobots = new MoveRobots(robot);
			moveRobots.start();
		}
		for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
			int x= configuration.Emplac_Obstacle.get(i).x;
			int y= configuration.Emplac_Obstacle.get(i).y;
			Obstacle obstacle = new Obstacle(y, x);
			obstacles.add(obstacle);
		}
		for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
			int x= configuration.Emplac_Sac.get(i).x;
			int y= configuration.Emplac_Sac.get(i).y;
			Sac sac = new Sac(y, x);
			sacs.add(sac);
		}
		for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
			int x= configuration.Emplac_Sortie.get(i).x;
			int y= configuration.Emplac_Sortie.get(i).y;
			Sortie sortie = new Sortie(y, x);
			sorties.add(sortie);
		}
	}
	// verifier si p1 est adjacent à p2
	private boolean EstAdjacent(Point p1,Point p2)
	{
		if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
		((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
		return true;
		else return false;
	}
	
	public class MoveIntrus extends Thread 
	{
		Intru intru ;
		MoveIntrus(Intru intru)
		{
			this.intru=intru;
		}
		@Override
		public void run() {
		//	int pas =0;
			while(true)
			{	//  un intru prend un sac 
				if (jeuArrete) {
				//	pas = 0 ;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else 
				{
					
					// le mouvement d'un intru d'une case à une autre
					if (intru.active==false) interrupt();
					
						
						if (intruMovementValide())
						{
							intru.move();
							// un intru prend un sac
							for (int i = 0; i < sacs.size(); i++) {
								if (EstAdjacent(intru, sacs.get(i))) {
									if (intru.PrendSac(sacs.get(i))) {
										sacs.remove(sacs.get(i));
									}
																	}
							} 
							//un robot attrape un intru 
							for (int i = 0; i < robots.size(); i++) {
								
								if (EstAdjacent(intru, robots.get(i)) )
									{
										for (int j = 0; j < intru.sacs.size(); j++) {
											sacs.add(intru.sacs.get(j));
										}
										intrus.remove(intru);
									}
							}
							// un intru sort à partir d'une sortie 
							for (int i = 0; i < sorties.size(); i++) {
								
								if (EstAdjacent(intru, sorties.get(i)) )
									{
										intrus.remove(intru);
									}
							}
							repaint();
							//pas++;
							try {
								sleep(1000);
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						//if (pas==1) {
							//jeuArrete = true;
						//}
				}
			
					
			}
						
			}
		private boolean intruMovementValide() {
			Point pd = new Point(intru.y,intru.x+1);
			Point pg = new Point(intru.y,intru.x-1);
			Point pb = new Point(intru.y+1,intru.x);
			Point ph = new Point(intru.y-1,intru.x);
			( !configuration.Emplac_Obstacle.contains(pd) && !configuration.Emplac_Intrus.contains(pd) && !configuration.Emplac_Sac.contains(pd)  && intru.direction=='D')
			|| ( intru.direction=='G' &&  !configuration.Emplac_Obstacle.contains(pg) && !configuration.Emplac_Intrus.contains(pg) && !configuration.Emplac_Sac.contains(pg)  ) 
			||	(intru.direction=='B' &&  !configuration.Emplac_Obstacle.contains(pb)&& !configuration.Emplac_Intrus.contains(pb) && !configuration.Emplac_Sac.contains(pb)  )
			|| (intru.direction=='H' &&   !configuration.Emplac_Obstacle.contains(ph) && !configuration.Emplac_Intrus.contains(ph) && !configuration.Emplac_Sac.contains(ph) )
			
			
		}
				
		}
	class MoveRobots extends Thread 
	{
		Robot robot;
		public MoveRobots(Robot robot) {
			this.robot = robot ;
		}

		@Override
		public void run() {
			// pas = 0;
			while(true)
			{
				if (jeuArrete) {
					//pas =0;
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else {
					
					// le mouvement d'un robot d'une case à une autre
					if ((robot.x+1 < configuration.nbre_colonne &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x+1))  && robot.direction=='D')
							|| (robot.x-1 > -1 && robot.direction=='G' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y,robot.x-1)) ) 
							||	(robot.y+1 < configuration.nbre_ligne && robot.direction=='B' &&  !configuration.Emplac_Obstacle.contains(new Point(robot.y+1,robot.x)) )
							|| (robot.y-1 > -1 && robot.direction=='H' &&   !configuration.Emplac_Obstacle.contains(new Point(robot.y-1,robot.x))))
					{
						robot.move();
						repaint();
						
						try {
							//pas++;
							sleep(500);
							//if (pas==3) {
								//jeuArrete = true;
							//}
							
							
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						
					}
					
				}
				
			}
						
			}
				
		}
	
	// dimensionner la JPanel
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
		}
	// dessiner tous les objects 
	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (int i = 0; i < configuration.nbre_colonne; i++) {
			for (int j = 0; j < configuration.nbre_ligne; j++) {
				g.setColor(Color.white);
				g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
			}
			
		}
		for (int i = 0; i < intrus.size(); i++) {
			if(intrus.get(i).active=true)
			{
				intrus.get(i).draw(g);
			}
		}
		for (int i = 0; i < robots.size(); i++) {
			if (i == n ) {
				
				g.setColor(Color.red);
				g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
			}
			robots.get(i).draw(g);
		}
		for (int i = 0; i < obstacles.size(); i++) {
			
			obstacles.get(i).draw(g);
		}
		for (int i = 0; i < sacs.size(); i++) {
			
			sacs.get(i).draw(g);
		}
		for (int i = 0; i < sorties.size(); i++) {
			
			sorties.get(i).draw(g);
		}
		if (intrus.size() == 0 )
		{
			ImageIcon imageIcon=new ImageIcon("D:\\Projet\\Jeu\\src\\GameOver.jpg");
			Image image = imageIcon.getImage();
			g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
			for (Thread t : Thread.getAllStackTraces().keySet()) 
			{  if (t.getState()==Thread.State.RUNNABLE) 
			     t.interrupt(); 
			} 

			
			repaint();
		}
	}
	
	
	
	int n = -1 ;
	@Override
	public void keyTyped(KeyEvent e) {
		
		
		if (joueurActif == 1 && jeuArrete ) {
			if (robots.size() == 1) {
				n = 0;
			}
			if (n != -1) {
				
				Robot robot =  robots.get(n);
				switch (e.getKeyChar()) {
				case 'd': robot.TournerD();break;
				case 'q':robot.TournerG();break;
				case 'z':robot.TournerH();break;
				case 's':robot.TournerB();break;
				default:
					throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
				}
				joueurActif = 2 ;
				jeuArrete = false;
			}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
			
			
		}
		
			
			else if (joueurActif == 2 && jeuArrete ) {
				if (intrus.size() == 1 ) {
					n=0;
				}
				if (n != -1) {
					Intru intru =  intrus.get(n);
					switch (e.getKeyChar()) {
					case 'd': intru.TournerD();break;
					case 'q':intru.TournerG();break;
					case 'z':intru.TournerH();break;
					case 's':intru.TournerB();break;
					}
					joueurActif = 1 ;
					jeuArrete=false;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
				
		}	
		System.out.println("Donner la main à joueur " + joueurActif);
		
	}
	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void keyReleased(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		jeuArrete = true;
		n=-1;
		System.out.println(jeuArrete);
		if (jeuArrete) {
			int colonne = e.getX()/cellWidth ;
			int ligne = e.getY() / cellWidth ;
			Point point = new Point(ligne,colonne);
			System.out.println(point);
			if (joueurActif == 1  ) {
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
						n=i;
						
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
				}
				
			}
			if (joueurActif == 2  ) {
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
						n=i;
					}
				}
				if (n == -1 ) {
					JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
				}
			}
			
		}
		
		
	}
	@Override
	public void mousePressed(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
	
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-09-10 03:46:29.959
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-09-10 03:46:29.966
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.ui 4 0 2020-09-10 04:53:07.204
!MESSAGE Unhandled event loop exception
!STACK 0
org.eclipse.e4.core.di.InjectionException: org.eclipse.swt.SWTException: i/o error (java.io.FileNotFoundException: C:\Program Files\Git\mingw64\share\git\git-for-windows.ico (Le chemin d’accès spécifié est introuvable))
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:68)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:236)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4735)
	at org.eclipse.e4.ui.internal.workbench.swt.E4Application$1.syncExec(E4Application.java:219)
	at org.eclipse.e4.ui.internal.di.UIEventObjectSupplier$UIEventHandler.handleEvent(UIEventObjectSupplier.java:64)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:132)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.e4.ui.model.application.ui.impl.UIElementImpl.setVisible(UIElementImpl.java:361)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributionRecord.updateVisibility(ContributionRecord.java:113)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRendererFilter.updateElementVisibility(MenuManagerRendererFilter.java:197)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRendererFilter.updateElementVisibility(MenuManagerRendererFilter.java:208)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerShowProcessor.showMenu(MenuManagerShowProcessor.java:258)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerShowProcessor.menuAboutToHide(MenuManagerShowProcessor.java:115)
	at org.eclipse.jface.internal.MenuManagerEventHelper.showEventPostHelper(MenuManagerEventHelper.java:95)
	at org.eclipse.jface.action.MenuManager.handleAboutToShow(MenuManager.java:469)
	at org.eclipse.jface.action.MenuManager.access$1(MenuManager.java:463)
	at org.eclipse.jface.action.MenuManager$2.menuShown(MenuManager.java:495)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:259)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4213)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1037)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1042)
	at org.eclipse.swt.widgets.Control.WM_INITMENUPOPUP(Control.java:5137)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4769)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1480)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2142)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4923)
	at org.eclipse.swt.internal.win32.OS.TrackPopupMenu(Native Method)
	at org.eclipse.swt.widgets.Menu._setVisible(Menu.java:237)
	at org.eclipse.swt.widgets.Display.runPopups(Display.java:4071)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3624)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1158)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1047)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:658)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:557)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:154)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:137)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:107)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1447)
Caused by: org.eclipse.swt.SWTException: i/o error (java.io.FileNotFoundException: C:\Program Files\Git\mingw64\share\git\git-for-windows.ico (Le chemin d’accès spécifié est introuvable))
	at org.eclipse.swt.SWT.error(SWT.java:4723)
	at org.eclipse.swt.SWT.error(SWT.java:4638)
	at org.eclipse.swt.graphics.ImageLoader.load(ImageLoader.java:184)
	at org.eclipse.tm.terminal.view.ui.local.showin.ExternalExecutablesManager.loadImage(ExternalExecutablesManager.java:282)
	at org.eclipse.tm.terminal.view.ui.local.showin.DynamicContributionItems.getContributionItems(DynamicContributionItems.java:74)
	at org.eclipse.ui.actions.CompoundContributionItem.getContributionItemsToFill(CompoundContributionItem.java:83)
	at org.eclipse.ui.actions.CompoundContributionItem.fill(CompoundContributionItem.java:57)
	at org.eclipse.ui.internal.menus.DynamicMenuContributionItem.fill(DynamicMenuContributionItem.java:146)
	at org.eclipse.jface.action.MenuManager.doItemFill(MenuManager.java:729)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:806)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:673)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.scheduleManagerUpdate(MenuManagerRenderer.java:1224)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.subscribeUIElementTopicVisible(MenuManagerRenderer.java:213)
	at jdk.internal.reflect.GeneratedMethodAccessor37.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	... 63 more
Caused by: java.io.FileNotFoundException: C:\Program Files\Git\mingw64\share\git\git-for-windows.ico (Le chemin d’accès spécifié est introuvable)
	at java.base/java.io.FileInputStream.open0(Native Method)
	at java.base/java.io.FileInputStream.open(FileInputStream.java:212)
	at java.base/java.io.FileInputStream.<init>(FileInputStream.java:154)
	at java.base/java.io.FileInputStream.<init>(FileInputStream.java:109)
	at org.eclipse.swt.graphics.ImageLoader.load(ImageLoader.java:181)
	... 77 more

!ENTRY org.eclipse.ui 4 0 2020-09-10 07:38:29.079
!MESSAGE Unhandled event loop exception
!STACK 0
org.eclipse.e4.core.di.InjectionException: org.eclipse.swt.SWTException: i/o error (java.io.FileNotFoundException: C:\Program Files\Git\mingw64\share\git\git-for-windows.ico (Le chemin d’accès spécifié est introuvable))
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:68)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:236)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4735)
	at org.eclipse.e4.ui.internal.workbench.swt.E4Application$1.syncExec(E4Application.java:219)
	at org.eclipse.e4.ui.internal.di.UIEventObjectSupplier$UIEventHandler.handleEvent(UIEventObjectSupplier.java:64)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:132)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.e4.ui.model.application.ui.impl.UIElementImpl.setVisible(UIElementImpl.java:361)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributionRecord.updateVisibility(ContributionRecord.java:113)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRendererFilter.updateElementVisibility(MenuManagerRendererFilter.java:197)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRendererFilter.updateElementVisibility(MenuManagerRendererFilter.java:208)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerShowProcessor.showMenu(MenuManagerShowProcessor.java:258)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerShowProcessor.menuAboutToHide(MenuManagerShowProcessor.java:115)
	at org.eclipse.jface.internal.MenuManagerEventHelper.showEventPostHelper(MenuManagerEventHelper.java:95)
	at org.eclipse.jface.action.MenuManager.handleAboutToShow(MenuManager.java:469)
	at org.eclipse.jface.action.MenuManager.access$1(MenuManager.java:463)
	at org.eclipse.jface.action.MenuManager$2.menuShown(MenuManager.java:495)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:259)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4213)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1037)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1042)
	at org.eclipse.swt.widgets.Control.WM_INITMENUPOPUP(Control.java:5137)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4769)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1480)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2142)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4923)
	at org.eclipse.swt.internal.win32.OS.TrackPopupMenu(Native Method)
	at org.eclipse.swt.widgets.Menu._setVisible(Menu.java:237)
	at org.eclipse.swt.widgets.Display.runPopups(Display.java:4071)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3624)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1158)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1047)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:658)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:557)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:154)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:137)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:107)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1447)
Caused by: org.eclipse.swt.SWTException: i/o error (java.io.FileNotFoundException: C:\Program Files\Git\mingw64\share\git\git-for-windows.ico (Le chemin d’accès spécifié est introuvable))
	at org.eclipse.swt.SWT.error(SWT.java:4723)
	at org.eclipse.swt.SWT.error(SWT.java:4638)
	at org.eclipse.swt.graphics.ImageLoader.load(ImageLoader.java:184)
	at org.eclipse.tm.terminal.view.ui.local.showin.ExternalExecutablesManager.loadImage(ExternalExecutablesManager.java:282)
	at org.eclipse.tm.terminal.view.ui.local.showin.DynamicContributionItems.getContributionItems(DynamicContributionItems.java:74)
	at org.eclipse.ui.actions.CompoundContributionItem.getContributionItemsToFill(CompoundContributionItem.java:83)
	at org.eclipse.ui.actions.CompoundContributionItem.fill(CompoundContributionItem.java:57)
	at org.eclipse.ui.internal.menus.DynamicMenuContributionItem.fill(DynamicMenuContributionItem.java:146)
	at org.eclipse.jface.action.MenuManager.doItemFill(MenuManager.java:729)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:806)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:673)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.scheduleManagerUpdate(MenuManagerRenderer.java:1224)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.subscribeUIElementTopicVisible(MenuManagerRenderer.java:213)
	at jdk.internal.reflect.GeneratedMethodAccessor37.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	... 63 more
Caused by: java.io.FileNotFoundException: C:\Program Files\Git\mingw64\share\git\git-for-windows.ico (Le chemin d’accès spécifié est introuvable)
	at java.base/java.io.FileInputStream.open0(Native Method)
	at java.base/java.io.FileInputStream.open(FileInputStream.java:212)
	at java.base/java.io.FileInputStream.<init>(FileInputStream.java:154)
	at java.base/java.io.FileInputStream.<init>(FileInputStream.java:109)
	at org.eclipse.swt.graphics.ImageLoader.load(ImageLoader.java:181)
	... 77 more

!ENTRY org.eclipse.ui 4 0 2020-09-10 07:45:54.382
!MESSAGE Unhandled event loop exception
!STACK 0
org.eclipse.e4.core.di.InjectionException: org.eclipse.swt.SWTException: i/o error (java.io.FileNotFoundException: C:\Program Files\Git\mingw64\share\git\git-for-windows.ico (Le chemin d’accès spécifié est introuvable))
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:68)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:236)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4735)
	at org.eclipse.e4.ui.internal.workbench.swt.E4Application$1.syncExec(E4Application.java:219)
	at org.eclipse.e4.ui.internal.di.UIEventObjectSupplier$UIEventHandler.handleEvent(UIEventObjectSupplier.java:64)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:132)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.e4.ui.model.application.ui.impl.UIElementImpl.setVisible(UIElementImpl.java:361)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributionRecord.updateVisibility(ContributionRecord.java:113)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRendererFilter.updateElementVisibility(MenuManagerRendererFilter.java:197)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRendererFilter.updateElementVisibility(MenuManagerRendererFilter.java:208)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerShowProcessor.showMenu(MenuManagerShowProcessor.java:258)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerShowProcessor.menuAboutToHide(MenuManagerShowProcessor.java:115)
	at org.eclipse.jface.internal.MenuManagerEventHelper.showEventPostHelper(MenuManagerEventHelper.java:95)
	at org.eclipse.jface.action.MenuManager.handleAboutToShow(MenuManager.java:469)
	at org.eclipse.jface.action.MenuManager.access$1(MenuManager.java:463)
	at org.eclipse.jface.action.MenuManager$2.menuShown(MenuManager.java:495)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:259)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4213)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1037)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1042)
	at org.eclipse.swt.widgets.Control.WM_INITMENUPOPUP(Control.java:5137)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4769)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1480)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2142)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4923)
	at org.eclipse.swt.internal.win32.OS.TrackPopupMenu(Native Method)
	at org.eclipse.swt.widgets.Menu._setVisible(Menu.java:237)
	at org.eclipse.swt.widgets.Display.runPopups(Display.java:4071)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3624)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1158)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1047)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:658)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:557)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:154)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:137)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:107)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1447)
Caused by: org.eclipse.swt.SWTException: i/o error (java.io.FileNotFoundException: C:\Program Files\Git\mingw64\share\git\git-for-windows.ico (Le chemin d’accès spécifié est introuvable))
	at org.eclipse.swt.SWT.error(SWT.java:4723)
	at org.eclipse.swt.SWT.error(SWT.java:4638)
	at org.eclipse.swt.graphics.ImageLoader.load(ImageLoader.java:184)
	at org.eclipse.tm.terminal.view.ui.local.showin.ExternalExecutablesManager.loadImage(ExternalExecutablesManager.java:282)
	at org.eclipse.tm.terminal.view.ui.local.showin.DynamicContributionItems.getContributionItems(DynamicContributionItems.java:74)
	at org.eclipse.ui.actions.CompoundContributionItem.getContributionItemsToFill(CompoundContributionItem.java:83)
	at org.eclipse.ui.actions.CompoundContributionItem.fill(CompoundContributionItem.java:57)
	at org.eclipse.ui.internal.menus.DynamicMenuContributionItem.fill(DynamicMenuContributionItem.java:146)
	at org.eclipse.jface.action.MenuManager.doItemFill(MenuManager.java:729)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:806)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:673)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.scheduleManagerUpdate(MenuManagerRenderer.java:1224)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.subscribeUIElementTopicVisible(MenuManagerRenderer.java:213)
	at jdk.internal.reflect.GeneratedMethodAccessor37.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	... 63 more
Caused by: java.io.FileNotFoundException: C:\Program Files\Git\mingw64\share\git\git-for-windows.ico (Le chemin d’accès spécifié est introuvable)
	at java.base/java.io.FileInputStream.open0(Native Method)
	at java.base/java.io.FileInputStream.open(FileInputStream.java:212)
	at java.base/java.io.FileInputStream.<init>(FileInputStream.java:154)
	at java.base/java.io.FileInputStream.<init>(FileInputStream.java:109)
	at org.eclipse.swt.graphics.ImageLoader.load(ImageLoader.java:181)
	... 77 more

!ENTRY org.eclipse.ui 4 0 2020-09-10 07:47:36.454
!MESSAGE Unhandled event loop exception
!STACK 0
org.eclipse.e4.core.di.InjectionException: org.eclipse.swt.SWTException: i/o error (java.io.FileNotFoundException: C:\Program Files\Git\mingw64\share\git\git-for-windows.ico (Le chemin d’accès spécifié est introuvable))
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:68)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:236)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4735)
	at org.eclipse.e4.ui.internal.workbench.swt.E4Application$1.syncExec(E4Application.java:219)
	at org.eclipse.e4.ui.internal.di.UIEventObjectSupplier$UIEventHandler.handleEvent(UIEventObjectSupplier.java:64)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:132)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.e4.ui.model.application.ui.impl.UIElementImpl.setVisible(UIElementImpl.java:361)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributionRecord.updateVisibility(ContributionRecord.java:113)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRendererFilter.updateElementVisibility(MenuManagerRendererFilter.java:197)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRendererFilter.updateElementVisibility(MenuManagerRendererFilter.java:208)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerShowProcessor.showMenu(MenuManagerShowProcessor.java:258)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerShowProcessor.menuAboutToHide(MenuManagerShowProcessor.java:115)
	at org.eclipse.jface.internal.MenuManagerEventHelper.showEventPostHelper(MenuManagerEventHelper.java:95)
	at org.eclipse.jface.action.MenuManager.handleAboutToShow(MenuManager.java:469)
	at org.eclipse.jface.action.MenuManager.access$1(MenuManager.java:463)
	at org.eclipse.jface.action.MenuManager$2.menuShown(MenuManager.java:495)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:259)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4213)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1037)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1042)
	at org.eclipse.swt.widgets.Control.WM_INITMENUPOPUP(Control.java:5137)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4769)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1480)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2142)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4923)
	at org.eclipse.swt.internal.win32.OS.TrackPopupMenu(Native Method)
	at org.eclipse.swt.widgets.Menu._setVisible(Menu.java:237)
	at org.eclipse.swt.widgets.Display.runPopups(Display.java:4071)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3624)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1158)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1047)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:658)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:557)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:154)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:137)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:107)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1447)
Caused by: org.eclipse.swt.SWTException: i/o error (java.io.FileNotFoundException: C:\Program Files\Git\mingw64\share\git\git-for-windows.ico (Le chemin d’accès spécifié est introuvable))
	at org.eclipse.swt.SWT.error(SWT.java:4723)
	at org.eclipse.swt.SWT.error(SWT.java:4638)
	at org.eclipse.swt.graphics.ImageLoader.load(ImageLoader.java:184)
	at org.eclipse.tm.terminal.view.ui.local.showin.ExternalExecutablesManager.loadImage(ExternalExecutablesManager.java:282)
	at org.eclipse.tm.terminal.view.ui.local.showin.DynamicContributionItems.getContributionItems(DynamicContributionItems.java:74)
	at org.eclipse.ui.actions.CompoundContributionItem.getContributionItemsToFill(CompoundContributionItem.java:83)
	at org.eclipse.ui.actions.CompoundContributionItem.fill(CompoundContributionItem.java:57)
	at org.eclipse.ui.internal.menus.DynamicMenuContributionItem.fill(DynamicMenuContributionItem.java:146)
	at org.eclipse.jface.action.MenuManager.doItemFill(MenuManager.java:729)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:806)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:673)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.scheduleManagerUpdate(MenuManagerRenderer.java:1224)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.subscribeUIElementTopicVisible(MenuManagerRenderer.java:213)
	at jdk.internal.reflect.GeneratedMethodAccessor37.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	... 63 more
Caused by: java.io.FileNotFoundException: C:\Program Files\Git\mingw64\share\git\git-for-windows.ico (Le chemin d’accès spécifié est introuvable)
	at java.base/java.io.FileInputStream.open0(Native Method)
	at java.base/java.io.FileInputStream.open(FileInputStream.java:212)
	at java.base/java.io.FileInputStream.<init>(FileInputStream.java:154)
	at java.base/java.io.FileInputStream.<init>(FileInputStream.java:109)
	at org.eclipse.swt.graphics.ImageLoader.load(ImageLoader.java:181)
	... 77 more
!SESSION 2020-09-10 07:50:26.101 -----------------------------------------------
eclipse.buildId=4.16.0.I20200604-0540
java.version=14.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=fr_FR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2020-09-10 07:50:33.289
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2020-09-10 07:50:33.289
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7944c323,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@637d111d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2020-09-10 07:50:48.216
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\ayadi'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.ui 4 0 2020-09-10 07:52:54.504
!MESSAGE Unhandled event loop exception
!STACK 0
org.eclipse.e4.core.di.InjectionException: org.eclipse.swt.SWTException: i/o error (java.io.FileNotFoundException: C:\Program Files\Git\mingw64\share\git\git-for-windows.ico (Le chemin d’accès spécifié est introuvable))
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:68)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:236)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4735)
	at org.eclipse.e4.ui.internal.workbench.swt.E4Application$1.syncExec(E4Application.java:219)
	at org.eclipse.e4.ui.internal.di.UIEventObjectSupplier$UIEventHandler.handleEvent(UIEventObjectSupplier.java:64)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:132)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.e4.ui.model.application.ui.impl.UIElementImpl.setVisible(UIElementImpl.java:361)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributionRecord.updateVisibility(ContributionRecord.java:113)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRendererFilter.updateElementVisibility(MenuManagerRendererFilter.java:197)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRendererFilter.updateElementVisibility(MenuManagerRendererFilter.java:208)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerShowProcessor.showMenu(MenuManagerShowProcessor.java:258)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerShowProcessor.menuAboutToHide(MenuManagerShowProcessor.java:115)
	at org.eclipse.jface.internal.MenuManagerEventHelper.showEventPostHelper(MenuManagerEventHelper.java:95)
	at org.eclipse.jface.action.MenuManager.handleAboutToShow(MenuManager.java:469)
	at org.eclipse.jface.action.MenuManager.access$1(MenuManager.java:463)
	at org.eclipse.jface.action.MenuManager$2.menuShown(MenuManager.java:495)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:259)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4213)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1037)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1042)
	at org.eclipse.swt.widgets.Control.WM_INITMENUPOPUP(Control.java:5137)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4769)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1480)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2142)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4923)
	at org.eclipse.swt.internal.win32.OS.TrackPopupMenu(Native Method)
	at org.eclipse.swt.widgets.Menu._setVisible(Menu.java:237)
	at org.eclipse.swt.widgets.Display.runPopups(Display.java:4071)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3624)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1158)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1047)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:658)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:557)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:154)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:137)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:107)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1447)
Caused by: org.eclipse.swt.SWTException: i/o error (java.io.FileNotFoundException: C:\Program Files\Git\mingw64\share\git\git-for-windows.ico (Le chemin d’accès spécifié est introuvable))
	at org.eclipse.swt.SWT.error(SWT.java:4723)
	at org.eclipse.swt.SWT.error(SWT.java:4638)
	at org.eclipse.swt.graphics.ImageLoader.load(ImageLoader.java:184)
	at org.eclipse.tm.terminal.view.ui.local.showin.ExternalExecutablesManager.loadImage(ExternalExecutablesManager.java:282)
	at org.eclipse.tm.terminal.view.ui.local.showin.DynamicContributionItems.getContributionItems(DynamicContributionItems.java:74)
	at org.eclipse.ui.actions.CompoundContributionItem.getContributionItemsToFill(CompoundContributionItem.java:83)
	at org.eclipse.ui.actions.CompoundContributionItem.fill(CompoundContributionItem.java:57)
	at org.eclipse.ui.internal.menus.DynamicMenuContributionItem.fill(DynamicMenuContributionItem.java:146)
	at org.eclipse.jface.action.MenuManager.doItemFill(MenuManager.java:729)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:806)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:673)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.scheduleManagerUpdate(MenuManagerRenderer.java:1224)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.subscribeUIElementTopicVisible(MenuManagerRenderer.java:213)
	at jdk.internal.reflect.GeneratedMethodAccessor36.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	... 63 more
Caused by: java.io.FileNotFoundException: C:\Program Files\Git\mingw64\share\git\git-for-windows.ico (Le chemin d’accès spécifié est introuvable)
	at java.base/java.io.FileInputStream.open0(Native Method)
	at java.base/java.io.FileInputStream.open(FileInputStream.java:212)
	at java.base/java.io.FileInputStream.<init>(FileInputStream.java:154)
	at java.base/java.io.FileInputStream.<init>(FileInputStream.java:109)
	at org.eclipse.swt.graphics.ImageLoader.load(ImageLoader.java:181)
	... 77 more

!ENTRY org.eclipse.ui 4 0 2020-09-10 07:55:51.956
!MESSAGE Unhandled event loop exception
!STACK 0
org.eclipse.e4.core.di.InjectionException: org.eclipse.swt.SWTException: i/o error (java.io.FileNotFoundException: C:\Program Files\Git\mingw64\share\git\git-for-windows.ico (Le chemin d’accès spécifié est introuvable))
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:68)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:236)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4735)
	at org.eclipse.e4.ui.internal.workbench.swt.E4Application$1.syncExec(E4Application.java:219)
	at org.eclipse.e4.ui.internal.di.UIEventObjectSupplier$UIEventHandler.handleEvent(UIEventObjectSupplier.java:64)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:132)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.e4.ui.model.application.ui.impl.UIElementImpl.setVisible(UIElementImpl.java:361)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributionRecord.updateVisibility(ContributionRecord.java:113)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRendererFilter.updateElementVisibility(MenuManagerRendererFilter.java:197)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRendererFilter.updateElementVisibility(MenuManagerRendererFilter.java:208)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerShowProcessor.showMenu(MenuManagerShowProcessor.java:258)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerShowProcessor.menuAboutToHide(MenuManagerShowProcessor.java:115)
	at org.eclipse.jface.internal.MenuManagerEventHelper.showEventPostHelper(MenuManagerEventHelper.java:95)
	at org.eclipse.jface.action.MenuManager.handleAboutToShow(MenuManager.java:469)
	at org.eclipse.jface.action.MenuManager.access$1(MenuManager.java:463)
	at org.eclipse.jface.action.MenuManager$2.menuShown(MenuManager.java:495)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:259)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4213)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1037)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1042)
	at org.eclipse.swt.widgets.Control.WM_INITMENUPOPUP(Control.java:5137)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4769)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1480)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2142)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4923)
	at org.eclipse.swt.internal.win32.OS.TrackPopupMenu(Native Method)
	at org.eclipse.swt.widgets.Menu._setVisible(Menu.java:237)
	at org.eclipse.swt.widgets.Display.runPopups(Display.java:4071)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3624)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1158)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1047)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:658)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:557)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:154)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:137)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:107)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1447)
Caused by: org.eclipse.swt.SWTException: i/o error (java.io.FileNotFoundException: C:\Program Files\Git\mingw64\share\git\git-for-windows.ico (Le chemin d’accès spécifié est introuvable))
	at org.eclipse.swt.SWT.error(SWT.java:4723)
	at org.eclipse.swt.SWT.error(SWT.java:4638)
	at org.eclipse.swt.graphics.ImageLoader.load(ImageLoader.java:184)
	at org.eclipse.tm.terminal.view.ui.local.showin.ExternalExecutablesManager.loadImage(ExternalExecutablesManager.java:282)
	at org.eclipse.tm.terminal.view.ui.local.showin.DynamicContributionItems.getContributionItems(DynamicContributionItems.java:74)
	at org.eclipse.ui.actions.CompoundContributionItem.getContributionItemsToFill(CompoundContributionItem.java:83)
	at org.eclipse.ui.actions.CompoundContributionItem.fill(CompoundContributionItem.java:57)
	at org.eclipse.ui.internal.menus.DynamicMenuContributionItem.fill(DynamicMenuContributionItem.java:146)
	at org.eclipse.jface.action.MenuManager.doItemFill(MenuManager.java:729)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:806)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:673)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.scheduleManagerUpdate(MenuManagerRenderer.java:1224)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.subscribeUIElementTopicVisible(MenuManagerRenderer.java:213)
	at jdk.internal.reflect.GeneratedMethodAccessor36.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	... 63 more
Caused by: java.io.FileNotFoundException: C:\Program Files\Git\mingw64\share\git\git-for-windows.ico (Le chemin d’accès spécifié est introuvable)
	at java.base/java.io.FileInputStream.open0(Native Method)
	at java.base/java.io.FileInputStream.open(FileInputStream.java:212)
	at java.base/java.io.FileInputStream.<init>(FileInputStream.java:154)
	at java.base/java.io.FileInputStream.<init>(FileInputStream.java:109)
	at org.eclipse.swt.graphics.ImageLoader.load(ImageLoader.java:181)
	... 77 more

!ENTRY org.eclipse.ui 4 0 2020-09-10 08:01:44.324
!MESSAGE Unhandled event loop exception
!STACK 0
org.eclipse.e4.core.di.InjectionException: org.eclipse.swt.SWTException: i/o error (java.io.FileNotFoundException: C:\Program Files\Git\mingw64\share\git\git-for-windows.ico (Le chemin d’accès spécifié est introuvable))
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:68)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:236)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4735)
	at org.eclipse.e4.ui.internal.workbench.swt.E4Application$1.syncExec(E4Application.java:219)
	at org.eclipse.e4.ui.internal.di.UIEventObjectSupplier$UIEventHandler.handleEvent(UIEventObjectSupplier.java:64)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:132)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.e4.ui.model.application.ui.impl.UIElementImpl.setVisible(UIElementImpl.java:361)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributionRecord.updateVisibility(ContributionRecord.java:113)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRendererFilter.updateElementVisibility(MenuManagerRendererFilter.java:197)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRendererFilter.updateElementVisibility(MenuManagerRendererFilter.java:208)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerShowProcessor.showMenu(MenuManagerShowProcessor.java:258)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerShowProcessor.menuAboutToHide(MenuManagerShowProcessor.java:115)
	at org.eclipse.jface.internal.MenuManagerEventHelper.showEventPostHelper(MenuManagerEventHelper.java:95)
	at org.eclipse.jface.action.MenuManager.handleAboutToShow(MenuManager.java:469)
	at org.eclipse.jface.action.MenuManager.access$1(MenuManager.java:463)
	at org.eclipse.jface.action.MenuManager$2.menuShown(MenuManager.java:495)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:259)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4213)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1037)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1042)
	at org.eclipse.swt.widgets.Control.WM_INITMENUPOPUP(Control.java:5137)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4769)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1480)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2142)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4923)
	at org.eclipse.swt.internal.win32.OS.TrackPopupMenu(Native Method)
	at org.eclipse.swt.widgets.Menu._setVisible(Menu.java:237)
	at org.eclipse.swt.widgets.Display.runPopups(Display.java:4071)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3624)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1158)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1047)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:658)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:557)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:154)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:137)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:107)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1447)
Caused by: org.eclipse.swt.SWTException: i/o error (java.io.FileNotFoundException: C:\Program Files\Git\mingw64\share\git\git-for-windows.ico (Le chemin d’accès spécifié est introuvable))
	at org.eclipse.swt.SWT.error(SWT.java:4723)
	at org.eclipse.swt.SWT.error(SWT.java:4638)
	at org.eclipse.swt.graphics.ImageLoader.load(ImageLoader.java:184)
	at org.eclipse.tm.terminal.view.ui.local.showin.ExternalExecutablesManager.loadImage(ExternalExecutablesManager.java:282)
	at org.eclipse.tm.terminal.view.ui.local.showin.DynamicContributionItems.getContributionItems(DynamicContributionItems.java:74)
	at org.eclipse.ui.actions.CompoundContributionItem.getContributionItemsToFill(CompoundContributionItem.java:83)
	at org.eclipse.ui.actions.CompoundContributionItem.fill(CompoundContributionItem.java:57)
	at org.eclipse.ui.internal.menus.DynamicMenuContributionItem.fill(DynamicMenuContributionItem.java:146)
	at org.eclipse.jface.action.MenuManager.doItemFill(MenuManager.java:729)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:806)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:673)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.scheduleManagerUpdate(MenuManagerRenderer.java:1224)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.subscribeUIElementTopicVisible(MenuManagerRenderer.java:213)
	at jdk.internal.reflect.GeneratedMethodAccessor36.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	... 63 more
Caused by: java.io.FileNotFoundException: C:\Program Files\Git\mingw64\share\git\git-for-windows.ico (Le chemin d’accès spécifié est introuvable)
	at java.base/java.io.FileInputStream.open0(Native Method)
	at java.base/java.io.FileInputStream.open(FileInputStream.java:212)
	at java.base/java.io.FileInputStream.<init>(FileInputStream.java:154)
	at java.base/java.io.FileInputStream.<init>(FileInputStream.java:109)
	at org.eclipse.swt.graphics.ImageLoader.load(ImageLoader.java:181)
	... 77 more

!ENTRY org.eclipse.ui 4 0 2020-09-10 08:03:18.223
!MESSAGE Unhandled event loop exception
!STACK 0
org.eclipse.e4.core.di.InjectionException: org.eclipse.swt.SWTException: i/o error (java.io.FileNotFoundException: C:\Program Files\Git\mingw64\share\git\git-for-windows.ico (Le chemin d’accès spécifié est introuvable))
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:68)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:236)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4735)
	at org.eclipse.e4.ui.internal.workbench.swt.E4Application$1.syncExec(E4Application.java:219)
	at org.eclipse.e4.ui.internal.di.UIEventObjectSupplier$UIEventHandler.handleEvent(UIEventObjectSupplier.java:64)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:132)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.e4.ui.model.application.ui.impl.UIElementImpl.setVisible(UIElementImpl.java:361)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributionRecord.updateVisibility(ContributionRecord.java:113)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRendererFilter.updateElementVisibility(MenuManagerRendererFilter.java:197)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRendererFilter.updateElementVisibility(MenuManagerRendererFilter.java:208)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerShowProcessor.showMenu(MenuManagerShowProcessor.java:258)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerShowProcessor.menuAboutToHide(MenuManagerShowProcessor.java:115)
	at org.eclipse.jface.internal.MenuManagerEventHelper.showEventPostHelper(MenuManagerEventHelper.java:95)
	at org.eclipse.jface.action.MenuManager.handleAboutToShow(MenuManager.java:469)
	at org.eclipse.jface.action.MenuManager.access$1(MenuManager.java:463)
	at org.eclipse.jface.action.MenuManager$2.menuShown(MenuManager.java:495)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:259)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4213)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1037)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1042)
	at org.eclipse.swt.widgets.Control.WM_INITMENUPOPUP(Control.java:5137)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4769)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1480)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2142)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4923)
	at org.eclipse.swt.internal.win32.OS.TrackPopupMenu(Native Method)
	at org.eclipse.swt.widgets.Menu._setVisible(Menu.java:237)
	at org.eclipse.swt.widgets.Display.runPopups(Display.java:4071)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3624)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1158)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1047)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:658)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:557)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:154)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:137)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:107)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1447)
Caused by: org.eclipse.swt.SWTException: i/o error (java.io.FileNotFoundException: C:\Program Files\Git\mingw64\share\git\git-for-windows.ico (Le chemin d’accès spécifié est introuvable))
	at org.eclipse.swt.SWT.error(SWT.java:4723)
	at org.eclipse.swt.SWT.error(SWT.java:4638)
	at org.eclipse.swt.graphics.ImageLoader.load(ImageLoader.java:184)
	at org.eclipse.tm.terminal.view.ui.local.showin.ExternalExecutablesManager.loadImage(ExternalExecutablesManager.java:282)
	at org.eclipse.tm.terminal.view.ui.local.showin.DynamicContributionItems.getContributionItems(DynamicContributionItems.java:74)
	at org.eclipse.ui.actions.CompoundContributionItem.getContributionItemsToFill(CompoundContributionItem.java:83)
	at org.eclipse.ui.actions.CompoundContributionItem.fill(CompoundContributionItem.java:57)
	at org.eclipse.ui.internal.menus.DynamicMenuContributionItem.fill(DynamicMenuContributionItem.java:146)
	at org.eclipse.jface.action.MenuManager.doItemFill(MenuManager.java:729)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:806)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:673)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.scheduleManagerUpdate(MenuManagerRenderer.java:1224)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.subscribeUIElementTopicVisible(MenuManagerRenderer.java:213)
	at jdk.internal.reflect.GeneratedMethodAccessor36.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	... 63 more
Caused by: java.io.FileNotFoundException: C:\Program Files\Git\mingw64\share\git\git-for-windows.ico (Le chemin d’accès spécifié est introuvable)
	at java.base/java.io.FileInputStream.open0(Native Method)
	at java.base/java.io.FileInputStream.open(FileInputStream.java:212)
	at java.base/java.io.FileInputStream.<init>(FileInputStream.java:154)
	at java.base/java.io.FileInputStream.<init>(FileInputStream.java:109)
	at org.eclipse.swt.graphics.ImageLoader.load(ImageLoader.java:181)
	... 77 more
!SESSION 2020-09-10 08:42:53.778 -----------------------------------------------
eclipse.buildId=4.16.0.I20200604-0540
java.version=14.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=fr_FR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2020-09-10 08:42:59.681
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2020-09-10 08:42:59.681
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@35c00c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6cd7dc74,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2020-09-10 08:43:06.245
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\ayadi'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2020-09-10 09:18:40.923 -----------------------------------------------
eclipse.buildId=4.16.0.I20200604-0540
java.version=14.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=fr_FR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2020-09-10 09:18:53.326
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2020-09-10 09:18:53.326
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@35c00c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6cd7dc74,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2020-09-10 09:18:59.864
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\ayadi'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2020-09-10 09:39:02.180 -----------------------------------------------
eclipse.buildId=4.16.0.I20200604-0540
java.version=14.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=fr_FR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2020-09-10 09:39:07.539
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2020-09-10 09:39:07.539
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@60fbc34d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7736c41e,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2020-09-10 09:39:12.867
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\ayadi'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2020-09-10 09:47:49.411 -----------------------------------------------
eclipse.buildId=4.16.0.I20200604-0540
java.version=14.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=fr_FR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2020-09-10 09:47:55.021
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2020-09-10 09:47:55.021
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@42ebece0,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@15c4b1a4,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2020-09-10 09:48:00.885
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\ayadi'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2020-09-11 15:16:27.410 -----------------------------------------------
eclipse.buildId=4.16.0.I20200604-0540
java.version=14.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=fr_FR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2020-09-11 15:16:43.891
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2020-09-11 15:16:43.891
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6cd7dc74,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6d695ec4,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2020-09-11 15:16:50.557
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\ayadi'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.ui 4 0 2020-09-11 15:52:58.068
!MESSAGE Unhandled event loop exception
!STACK 0
org.eclipse.e4.core.di.InjectionException: org.eclipse.swt.SWTException: i/o error (java.io.FileNotFoundException: C:\Program Files\Git\mingw64\share\git\git-for-windows.ico (Le chemin d’accès spécifié est introuvable))
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:68)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:236)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4735)
	at org.eclipse.e4.ui.internal.workbench.swt.E4Application$1.syncExec(E4Application.java:219)
	at org.eclipse.e4.ui.internal.di.UIEventObjectSupplier$UIEventHandler.handleEvent(UIEventObjectSupplier.java:64)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:132)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.e4.ui.model.application.ui.impl.UIElementImpl.setVisible(UIElementImpl.java:361)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributionRecord.updateVisibility(ContributionRecord.java:113)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRendererFilter.updateElementVisibility(MenuManagerRendererFilter.java:197)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRendererFilter.updateElementVisibility(MenuManagerRendererFilter.java:208)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerShowProcessor.showMenu(MenuManagerShowProcessor.java:258)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerShowProcessor.menuAboutToHide(MenuManagerShowProcessor.java:115)
	at org.eclipse.jface.internal.MenuManagerEventHelper.showEventPostHelper(MenuManagerEventHelper.java:95)
	at org.eclipse.jface.action.MenuManager.handleAboutToShow(MenuManager.java:469)
	at org.eclipse.jface.action.MenuManager.access$1(MenuManager.java:463)
	at org.eclipse.jface.action.MenuManager$2.menuShown(MenuManager.java:495)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:259)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4213)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1037)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1042)
	at org.eclipse.swt.widgets.Control.WM_INITMENUPOPUP(Control.java:5137)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4769)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1480)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2142)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4923)
	at org.eclipse.swt.internal.win32.OS.TrackPopupMenu(Native Method)
	at org.eclipse.swt.widgets.Menu._setVisible(Menu.java:237)
	at org.eclipse.swt.widgets.Display.runPopups(Display.java:4071)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3624)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1158)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1047)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:658)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:557)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:154)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:137)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:107)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1447)
Caused by: org.eclipse.swt.SWTException: i/o error (java.io.FileNotFoundException: C:\Program Files\Git\mingw64\share\git\git-for-windows.ico (Le chemin d’accès spécifié est introuvable))
	at org.eclipse.swt.SWT.error(SWT.java:4723)
	at org.eclipse.swt.SWT.error(SWT.java:4638)
	at org.eclipse.swt.graphics.ImageLoader.load(ImageLoader.java:184)
	at org.eclipse.tm.terminal.view.ui.local.showin.ExternalExecutablesManager.loadImage(ExternalExecutablesManager.java:282)
	at org.eclipse.tm.terminal.view.ui.local.showin.DynamicContributionItems.getContributionItems(DynamicContributionItems.java:74)
	at org.eclipse.ui.actions.CompoundContributionItem.getContributionItemsToFill(CompoundContributionItem.java:83)
	at org.eclipse.ui.actions.CompoundContributionItem.fill(CompoundContributionItem.java:57)
	at org.eclipse.ui.internal.menus.DynamicMenuContributionItem.fill(DynamicMenuContributionItem.java:146)
	at org.eclipse.jface.action.MenuManager.doItemFill(MenuManager.java:729)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:806)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:673)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.scheduleManagerUpdate(MenuManagerRenderer.java:1224)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.subscribeUIElementTopicVisible(MenuManagerRenderer.java:213)
	at jdk.internal.reflect.GeneratedMethodAccessor37.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	... 63 more
Caused by: java.io.FileNotFoundException: C:\Program Files\Git\mingw64\share\git\git-for-windows.ico (Le chemin d’accès spécifié est introuvable)
	at java.base/java.io.FileInputStream.open0(Native Method)
	at java.base/java.io.FileInputStream.open(FileInputStream.java:212)
	at java.base/java.io.FileInputStream.<init>(FileInputStream.java:154)
	at java.base/java.io.FileInputStream.<init>(FileInputStream.java:109)
	at org.eclipse.swt.graphics.ImageLoader.load(ImageLoader.java:181)
	... 77 more

!ENTRY org.eclipse.ui 4 0 2020-09-11 15:53:53.334
!MESSAGE Unhandled event loop exception
!STACK 0
org.eclipse.e4.core.di.InjectionException: org.eclipse.swt.SWTException: i/o error (java.io.FileNotFoundException: C:\Program Files\Git\mingw64\share\git\git-for-windows.ico (Le chemin d’accès spécifié est introuvable))
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:68)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:236)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4735)
	at org.eclipse.e4.ui.internal.workbench.swt.E4Application$1.syncExec(E4Application.java:219)
	at org.eclipse.e4.ui.internal.di.UIEventObjectSupplier$UIEventHandler.handleEvent(UIEventObjectSupplier.java:64)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:132)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.e4.ui.model.application.ui.impl.UIElementImpl.setVisible(UIElementImpl.java:361)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributionRecord.updateVisibility(ContributionRecord.java:113)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRendererFilter.updateElementVisibility(MenuManagerRendererFilter.java:197)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRendererFilter.updateElementVisibility(MenuManagerRendererFilter.java:208)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerShowProcessor.showMenu(MenuManagerShowProcessor.java:258)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerShowProcessor.menuAboutToHide(MenuManagerShowProcessor.java:115)
	at org.eclipse.jface.internal.MenuManagerEventHelper.showEventPostHelper(MenuManagerEventHelper.java:95)
	at org.eclipse.jface.action.MenuManager.handleAboutToShow(MenuManager.java:469)
	at org.eclipse.jface.action.MenuManager.access$1(MenuManager.java:463)
	at org.eclipse.jface.action.MenuManager$2.menuShown(MenuManager.java:495)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:259)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4213)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1037)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1042)
	at org.eclipse.swt.widgets.Control.WM_INITMENUPOPUP(Control.java:5137)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4769)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1480)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2142)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4923)
	at org.eclipse.swt.internal.win32.OS.TrackPopupMenu(Native Method)
	at org.eclipse.swt.widgets.Menu._setVisible(Menu.java:237)
	at org.eclipse.swt.widgets.Display.runPopups(Display.java:4071)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3624)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1158)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1047)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:658)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:557)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:154)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:137)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:107)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1447)
Caused by: org.eclipse.swt.SWTException: i/o error (java.io.FileNotFoundException: C:\Program Files\Git\mingw64\share\git\git-for-windows.ico (Le chemin d’accès spécifié est introuvable))
	at org.eclipse.swt.SWT.error(SWT.java:4723)
	at org.eclipse.swt.SWT.error(SWT.java:4638)
	at org.eclipse.swt.graphics.ImageLoader.load(ImageLoader.java:184)
	at org.eclipse.tm.terminal.view.ui.local.showin.ExternalExecutablesManager.loadImage(ExternalExecutablesManager.java:282)
	at org.eclipse.tm.terminal.view.ui.local.showin.DynamicContributionItems.getContributionItems(DynamicContributionItems.java:74)
	at org.eclipse.ui.actions.CompoundContributionItem.getContributionItemsToFill(CompoundContributionItem.java:83)
	at org.eclipse.ui.actions.CompoundContributionItem.fill(CompoundContributionItem.java:57)
	at org.eclipse.ui.internal.menus.DynamicMenuContributionItem.fill(DynamicMenuContributionItem.java:146)
	at org.eclipse.jface.action.MenuManager.doItemFill(MenuManager.java:729)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:806)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:673)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.scheduleManagerUpdate(MenuManagerRenderer.java:1224)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.subscribeUIElementTopicVisible(MenuManagerRenderer.java:213)
	at jdk.internal.reflect.GeneratedMethodAccessor37.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	... 63 more
Caused by: java.io.FileNotFoundException: C:\Program Files\Git\mingw64\share\git\git-for-windows.ico (Le chemin d’accès spécifié est introuvable)
	at java.base/java.io.FileInputStream.open0(Native Method)
	at java.base/java.io.FileInputStream.open(FileInputStream.java:212)
	at java.base/java.io.FileInputStream.<init>(FileInputStream.java:154)
	at java.base/java.io.FileInputStream.<init>(FileInputStream.java:109)
	at org.eclipse.swt.graphics.ImageLoader.load(ImageLoader.java:181)
	... 77 more
!SESSION 2020-09-16 11:43:07.674 -----------------------------------------------
eclipse.buildId=4.16.0.I20200604-0540
java.version=14.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=fr_FR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2020-09-16 11:43:21.047
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2020-09-16 11:43:21.047
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@20556566,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@e4ef4c0,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2020-09-16 11:43:33.306
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\ayadi'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.ui 4 0 2020-09-16 23:40:16.734
!MESSAGE Unhandled event loop exception
!STACK 0
java.lang.IllegalArgumentException: Argument not valid
	at org.eclipse.swt.SWT.error(SWT.java:4704)
	at org.eclipse.swt.SWT.error(SWT.java:4638)
	at org.eclipse.swt.SWT.error(SWT.java:4609)
	at org.eclipse.swt.graphics.GC.setForeground(GC.java:4370)
	at org.eclipse.e4.ui.workbench.renderers.swt.CTabRendering.drawBackground(CTabRendering.java:1158)
	at org.eclipse.e4.ui.workbench.renderers.swt.CTabRendering.drawUnselectedTabBackground(CTabRendering.java:1091)
	at org.eclipse.e4.ui.workbench.renderers.swt.CTabRendering.drawCustomBackground(CTabRendering.java:1073)
	at org.eclipse.e4.ui.workbench.renderers.swt.CTabRendering.draw(CTabRendering.java:236)
	at org.eclipse.swt.custom.CTabFolder.updateBkImages(CTabFolder.java:3938)
	at org.eclipse.swt.custom.CTabFolder.setButtonBounds(CTabFolder.java:2612)
	at org.eclipse.swt.custom.CTabFolder.updateItems(CTabFolder.java:3847)
	at org.eclipse.swt.custom.CTabFolder.updateItems(CTabFolder.java:3770)
	at org.eclipse.swt.custom.CTabFolder.onResize(CTabFolder.java:2117)
	at org.eclipse.swt.custom.CTabFolder.lambda$0(CTabFolder.java:337)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4213)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1037)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1042)
	at org.eclipse.swt.widgets.Control.sendResize(Control.java:3049)
	at org.eclipse.swt.widgets.Composite.sendResize(Composite.java:1011)
	at org.eclipse.swt.widgets.Composite.setBoundsInPixels(Composite.java:1060)
	at org.eclipse.swt.widgets.Control.setBoundsInPixels(Control.java:3218)
	at org.eclipse.swt.widgets.Control.setBoundsInPixels(Control.java:3214)
	at org.eclipse.swt.widgets.Control.setBoundsInPixels(Control.java:3290)
	at org.eclipse.swt.widgets.Control.setBounds(Control.java:3286)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashLayout.setRectangle(SashLayout.java:315)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashLayout.tileSubNodes(SashLayout.java:260)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashLayout.tileSubNodes(SashLayout.java:303)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashLayout.layout(SashLayout.java:178)
	at org.eclipse.swt.widgets.Composite.updateLayout(Composite.java:1324)
	at org.eclipse.swt.widgets.Composite.sendResize(Composite.java:1015)
	at org.eclipse.swt.widgets.Composite.setBoundsInPixels(Composite.java:1060)
	at org.eclipse.swt.widgets.Control.setBoundsInPixels(Control.java:3218)
	at org.eclipse.swt.widgets.Control.setBoundsInPixels(Control.java:3214)
	at org.eclipse.swt.widgets.Control.setBounds(Control.java:3209)
	at org.eclipse.swt.layout.FillLayout.layout(FillLayout.java:207)
	at org.eclipse.swt.widgets.Composite.updateLayout(Composite.java:1324)
	at org.eclipse.swt.widgets.Composite.WM_SIZE(Composite.java:1725)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4817)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4923)
	at org.eclipse.swt.internal.win32.OS.DefWindowProc(Native Method)
	at org.eclipse.swt.widgets.Scrollable.callWindowProc(Scrollable.java:91)
	at org.eclipse.swt.widgets.Control.WM_WINDOWPOSCHANGED(Control.java:5672)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4830)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4923)
	at org.eclipse.swt.internal.win32.OS.SetWindowPos(Native Method)
	at org.eclipse.swt.widgets.Control.setBoundsInPixels(Control.java:3257)
	at org.eclipse.swt.widgets.Composite.setBoundsInPixels(Composite.java:1054)
	at org.eclipse.swt.widgets.Control.setBoundsInPixels(Control.java:3218)
	at org.eclipse.swt.widgets.Control.setBoundsInPixels(Control.java:3214)
	at org.eclipse.swt.widgets.Control.setBoundsInPixels(Control.java:3290)
	at org.eclipse.swt.widgets.Control.setBounds(Control.java:3286)
	at org.eclipse.swt.custom.StackLayout.layout(StackLayout.java:124)
	at org.eclipse.swt.widgets.Composite.updateLayout(Composite.java:1324)
	at org.eclipse.swt.widgets.Composite.WM_SIZE(Composite.java:1725)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4817)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4923)
	at org.eclipse.swt.internal.win32.OS.DefWindowProc(Native Method)
	at org.eclipse.swt.widgets.Scrollable.callWindowProc(Scrollable.java:91)
	at org.eclipse.swt.widgets.Control.WM_WINDOWPOSCHANGED(Control.java:5672)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4830)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4923)
	at org.eclipse.swt.internal.win32.OS.SetWindowPos(Native Method)
	at org.eclipse.swt.widgets.Control.setBoundsInPixels(Control.java:3257)
	at org.eclipse.swt.widgets.Composite.setBoundsInPixels(Composite.java:1054)
	at org.eclipse.swt.widgets.Control.setBoundsInPixels(Control.java:3218)
	at org.eclipse.swt.widgets.Control.setBoundsInPixels(Control.java:3214)
	at org.eclipse.swt.widgets.Control.setBoundsInPixels(Control.java:3290)
	at org.eclipse.swt.widgets.Control.setBounds(Control.java:3286)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashLayout.setRectangle(SashLayout.java:315)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashLayout.tileSubNodes(SashLayout.java:260)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashLayout.tileSubNodes(SashLayout.java:303)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashLayout.layout(SashLayout.java:178)
	at org.eclipse.swt.widgets.Composite.updateLayout(Composite.java:1324)
	at org.eclipse.swt.widgets.Composite.WM_SIZE(Composite.java:1725)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4817)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4923)
	at org.eclipse.swt.internal.win32.OS.DefWindowProc(Native Method)
	at org.eclipse.swt.widgets.Scrollable.callWindowProc(Scrollable.java:91)
	at org.eclipse.swt.widgets.Control.WM_WINDOWPOSCHANGED(Control.java:5672)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4830)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4923)
	at org.eclipse.swt.internal.win32.OS.SetWindowPos(Native Method)
	at org.eclipse.swt.widgets.Control.setBoundsInPixels(Control.java:3257)
	at org.eclipse.swt.widgets.Composite.setBoundsInPixels(Composite.java:1054)
	at org.eclipse.swt.widgets.Control.setBoundsInPixels(Control.java:3218)
	at org.eclipse.swt.widgets.Control.setBoundsInPixels(Control.java:3214)
	at org.eclipse.swt.widgets.Control.setBounds(Control.java:3209)
	at org.eclipse.swt.layout.FillLayout.layout(FillLayout.java:207)
	at org.eclipse.swt.widgets.Composite.updateLayout(Composite.java:1324)
	at org.eclipse.swt.widgets.Composite.WM_SIZE(Composite.java:1725)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4817)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4923)
	at org.eclipse.swt.internal.win32.OS.DefWindowProc(Native Method)
	at org.eclipse.swt.widgets.Scrollable.callWindowProc(Scrollable.java:91)
	at org.eclipse.swt.widgets.Control.WM_WINDOWPOSCHANGED(Control.java:5672)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4830)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4931)
	at org.eclipse.swt.internal.win32.OS.EndDeferWindowPos(Native Method)
	at org.eclipse.swt.widgets.Composite.resizeChildren(Composite.java:986)
	at org.eclipse.swt.widgets.Composite.resizeChildren(Composite.java:963)
	at org.eclipse.swt.widgets.Composite.setResizeChildren(Composite.java:1159)
	at org.eclipse.swt.widgets.Composite.WM_SIZE(Composite.java:1729)
	at org.eclipse.swt.widgets.Canvas.WM_SIZE(Canvas.java:444)
	at org.eclipse.swt.widgets.Decorations.WM_SIZE(Decorations.java:1646)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4817)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1480)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2142)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4931)
	at org.eclipse.swt.internal.win32.OS.DefWindowProc(Native Method)
	at org.eclipse.swt.widgets.Shell.callWindowProc(Shell.java:508)
	at org.eclipse.swt.widgets.Control.WM_WINDOWPOSCHANGED(Control.java:5672)
	at org.eclipse.swt.widgets.Canvas.WM_WINDOWPOSCHANGED(Canvas.java:451)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4830)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1480)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2142)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4923)
	at org.eclipse.swt.internal.win32.OS.SetMenu(Native Method)
	at org.eclipse.swt.widgets.Decorations.setMenuBar(Decorations.java:1039)
	at org.eclipse.swt.widgets.Menu.releaseParent(Menu.java:959)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:802)
	at org.eclipse.swt.widgets.Widget.dispose(Widget.java:410)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.disposeWidget(SWTPartRenderer.java:174)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:943)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:871)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:866)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:850)
	at org.eclipse.ui.internal.WorkbenchWindow$1.handleEvent(WorkbenchWindow.java:331)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.lambda$0(UIEventHandler.java:38)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:236)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4735)
	at org.eclipse.e4.ui.internal.workbench.swt.E4Application$1.syncExec(E4Application.java:219)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.handleEvent(UIEventHandler.java:38)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:132)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.e4.ui.model.application.ui.impl.UIElementImpl.setWidget(UIElementImpl.java:267)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.unbindWidget(SWTPartRenderer.java:149)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.lambda$0(SWTPartRenderer.java:138)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:127)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4213)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1037)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1042)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:794)
	at org.eclipse.swt.widgets.Widget.dispose(Widget.java:410)
	at org.eclipse.swt.widgets.Decorations.dispose(Decorations.java:392)
	at org.eclipse.swt.widgets.Display.release(Display.java:3679)
	at org.eclipse.swt.graphics.Device.dispose(Device.java:276)
	at org.eclipse.swt.widgets.Display.messageProc(Display.java:3222)
	at org.eclipse.swt.internal.win32.OS.DefWindowProc(Native Method)
	at org.eclipse.swt.widgets.Shell.callWindowProc(Shell.java:508)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4841)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1480)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2142)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4931)
	at org.eclipse.swt.internal.win32.OS.PeekMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3625)
	at org.eclipse.jface.window.Window.runEventLoop(Window.java:823)
	at org.eclipse.jface.window.Window.open(Window.java:799)
	at org.eclipse.ui.internal.ide.application.IDEWorkbenchWindowAdvisor.promptOnExit(IDEWorkbenchWindowAdvisor.java:224)
	at org.eclipse.ui.internal.ide.application.IDEWorkbenchAdvisor.lambda$0(IDEWorkbenchAdvisor.java:158)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4213)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4205)
	at org.eclipse.swt.widgets.Display.messageProc(Display.java:3228)
	at org.eclipse.swt.internal.win32.OS.DefWindowProc(Native Method)
	at org.eclipse.swt.widgets.Shell.callWindowProc(Shell.java:508)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4841)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1480)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2142)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4931)
	at org.eclipse.swt.internal.win32.OS.PeekMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3625)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1158)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1047)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:658)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:557)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:154)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:137)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:107)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1447)

!ENTRY org.eclipse.ui 4 0 2020-09-16 23:40:18.524
!MESSAGE Unhandled event loop exception
!STACK 0
java.lang.NullPointerException
	at org.eclipse.ui.internal.views.helpers.EmptyWorkspaceHelper.dispose(EmptyWorkspaceHelper.java:140)
	at org.eclipse.ui.internal.views.helpers.EmptyWorkspaceHelper.access$3(EmptyWorkspaceHelper.java:139)
	at org.eclipse.ui.internal.views.helpers.EmptyWorkspaceHelper$Listener.widgetDisposed(EmptyWorkspaceHelper.java:382)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:127)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4213)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1037)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1042)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:794)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:921)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:797)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:921)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:797)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:921)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:797)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:921)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:797)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:921)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:797)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:921)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:797)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:921)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:797)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:921)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:797)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:921)
	at org.eclipse.swt.widgets.Canvas.releaseChildren(Canvas.java:168)
	at org.eclipse.swt.widgets.Decorations.releaseChildren(Decorations.java:713)
	at org.eclipse.swt.widgets.Shell.releaseChildren(Shell.java:1315)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:797)
	at org.eclipse.swt.widgets.Widget.dispose(Widget.java:410)
	at org.eclipse.swt.widgets.Decorations.dispose(Decorations.java:392)
	at org.eclipse.swt.widgets.Display.release(Display.java:3679)
	at org.eclipse.swt.graphics.Device.dispose(Device.java:276)
	at org.eclipse.swt.widgets.Display.messageProc(Display.java:3222)
	at org.eclipse.swt.internal.win32.OS.DefWindowProc(Native Method)
	at org.eclipse.swt.widgets.Shell.callWindowProc(Shell.java:508)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4841)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1480)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2142)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4931)
	at org.eclipse.swt.internal.win32.OS.PeekMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3625)
	at org.eclipse.jface.window.Window.runEventLoop(Window.java:823)
	at org.eclipse.jface.window.Window.open(Window.java:799)
	at org.eclipse.ui.internal.ide.application.IDEWorkbenchWindowAdvisor.promptOnExit(IDEWorkbenchWindowAdvisor.java:224)
	at org.eclipse.ui.internal.ide.application.IDEWorkbenchAdvisor.lambda$0(IDEWorkbenchAdvisor.java:158)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4213)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4205)
	at org.eclipse.swt.widgets.Display.messageProc(Display.java:3228)
	at org.eclipse.swt.internal.win32.OS.DefWindowProc(Native Method)
	at org.eclipse.swt.widgets.Shell.callWindowProc(Shell.java:508)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4841)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1480)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2142)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4931)
	at org.eclipse.swt.internal.win32.OS.PeekMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3625)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1158)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1047)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:658)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:557)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:154)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:137)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:107)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1447)

!ENTRY org.eclipse.ui 4 0 2020-09-16 23:40:18.551
!MESSAGE Unhandled event loop exception
!STACK 0
java.lang.NullPointerException
	at org.eclipse.ui.internal.NavigationHistory.getDisplay(NavigationHistory.java:178)
	at org.eclipse.ui.internal.NavigationHistory.markEditor(NavigationHistory.java:197)
	at org.eclipse.ui.internal.WorkbenchPage.updateActiveEditorSources(WorkbenchPage.java:419)
	at org.eclipse.ui.internal.WorkbenchPage.firePartClosed(WorkbenchPage.java:5103)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.lambda$0(CompatibilityPart.java:108)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.lambda$0(UIEventHandler.java:38)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:236)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4735)
	at org.eclipse.e4.ui.internal.workbench.swt.E4Application$1.syncExec(E4Application.java:219)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.handleEvent(UIEventHandler.java:38)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:132)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.e4.ui.model.application.ui.impl.UIElementImpl.setWidget(UIElementImpl.java:267)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.unbindWidget(SWTPartRenderer.java:149)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.lambda$0(SWTPartRenderer.java:138)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:127)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4213)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1037)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1042)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:794)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:921)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:797)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:921)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:797)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:921)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:797)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:921)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:797)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:921)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:797)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:921)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:797)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:921)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:797)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:921)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:797)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:921)
	at org.eclipse.swt.widgets.Canvas.releaseChildren(Canvas.java:168)
	at org.eclipse.swt.widgets.Decorations.releaseChildren(Decorations.java:713)
	at org.eclipse.swt.widgets.Shell.releaseChildren(Shell.java:1315)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:797)
	at org.eclipse.swt.widgets.Widget.dispose(Widget.java:410)
	at org.eclipse.swt.widgets.Decorations.dispose(Decorations.java:392)
	at org.eclipse.swt.widgets.Display.release(Display.java:3679)
	at org.eclipse.swt.graphics.Device.dispose(Device.java:276)
	at org.eclipse.swt.widgets.Display.messageProc(Display.java:3222)
	at org.eclipse.swt.internal.win32.OS.DefWindowProc(Native Method)
	at org.eclipse.swt.widgets.Shell.callWindowProc(Shell.java:508)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4841)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1480)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2142)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4931)
	at org.eclipse.swt.internal.win32.OS.PeekMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3625)
	at org.eclipse.jface.window.Window.runEventLoop(Window.java:823)
	at org.eclipse.jface.window.Window.open(Window.java:799)
	at org.eclipse.ui.internal.ide.application.IDEWorkbenchWindowAdvisor.promptOnExit(IDEWorkbenchWindowAdvisor.java:224)
	at org.eclipse.ui.internal.ide.application.IDEWorkbenchAdvisor.lambda$0(IDEWorkbenchAdvisor.java:158)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4213)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4205)
	at org.eclipse.swt.widgets.Display.messageProc(Display.java:3228)
	at org.eclipse.swt.internal.win32.OS.DefWindowProc(Native Method)
	at org.eclipse.swt.widgets.Shell.callWindowProc(Shell.java:508)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4841)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1480)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2142)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4931)
	at org.eclipse.swt.internal.win32.OS.PeekMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3625)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1158)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1047)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:658)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:557)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:154)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:137)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:107)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1447)
!SESSION 2020-09-17 07:39:31.119 -----------------------------------------------
eclipse.buildId=4.16.0.I20200604-0540
java.version=14.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=fr_FR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.core.resources 2 10035 2020-09-17 07:39:35.365
!MESSAGE The workspace exited with unsaved changes in the previous session; refreshing workspace to recover changes.

!ENTRY org.eclipse.jface 2 0 2020-09-17 07:39:39.477
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2020-09-17 07:39:39.477
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2b19b346,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@37c5b8e8,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2020-09-17 07:39:48.542
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\ayadi'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.ui 4 0 2020-09-17 07:42:25.997
!MESSAGE Unhandled event loop exception
!STACK 0
org.eclipse.e4.core.di.InjectionException: org.eclipse.swt.SWTException: i/o error (java.io.FileNotFoundException: C:\Program Files\Git\mingw64\share\git\git-for-windows.ico (Le chemin d’accès spécifié est introuvable))
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:68)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:236)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4735)
	at org.eclipse.e4.ui.internal.workbench.swt.E4Application$1.syncExec(E4Application.java:219)
	at org.eclipse.e4.ui.internal.di.UIEventObjectSupplier$UIEventHandler.handleEvent(UIEventObjectSupplier.java:64)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:132)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.e4.ui.model.application.ui.impl.UIElementImpl.setVisible(UIElementImpl.java:361)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributionRecord.updateVisibility(ContributionRecord.java:105)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRendererFilter.updateElementVisibility(MenuManagerRendererFilter.java:197)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRendererFilter.updateElementVisibility(MenuManagerRendererFilter.java:208)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerShowProcessor.showMenu(MenuManagerShowProcessor.java:258)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerShowProcessor.menuAboutToHide(MenuManagerShowProcessor.java:115)
	at org.eclipse.jface.internal.MenuManagerEventHelper.showEventPostHelper(MenuManagerEventHelper.java:95)
	at org.eclipse.jface.action.MenuManager.handleAboutToShow(MenuManager.java:469)
	at org.eclipse.jface.action.MenuManager.access$1(MenuManager.java:463)
	at org.eclipse.jface.action.MenuManager$2.menuShown(MenuManager.java:495)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:259)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4213)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1037)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1042)
	at org.eclipse.swt.widgets.Control.WM_INITMENUPOPUP(Control.java:5137)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4769)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1480)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2142)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4923)
	at org.eclipse.swt.internal.win32.OS.TrackPopupMenu(Native Method)
	at org.eclipse.swt.widgets.Menu._setVisible(Menu.java:237)
	at org.eclipse.swt.widgets.Display.runPopups(Display.java:4071)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3624)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1158)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1047)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:658)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:557)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:154)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:137)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:107)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1447)
Caused by: org.eclipse.swt.SWTException: i/o error (java.io.FileNotFoundException: C:\Program Files\Git\mingw64\share\git\git-for-windows.ico (Le chemin d’accès spécifié est introuvable))
	at org.eclipse.swt.SWT.error(SWT.java:4723)
	at org.eclipse.swt.SWT.error(SWT.java:4638)
	at org.eclipse.swt.graphics.ImageLoader.load(ImageLoader.java:184)
	at org.eclipse.tm.terminal.view.ui.local.showin.ExternalExecutablesManager.loadImage(ExternalExecutablesManager.java:282)
	at org.eclipse.tm.terminal.view.ui.local.showin.DynamicContributionItems.getContributionItems(DynamicContributionItems.java:74)
	at org.eclipse.ui.actions.CompoundContributionItem.getContributionItemsToFill(CompoundContributionItem.java:83)
	at org.eclipse.ui.actions.CompoundContributionItem.fill(CompoundContributionItem.java:57)
	at org.eclipse.ui.internal.menus.DynamicMenuContributionItem.fill(DynamicMenuContributionItem.java:146)
	at org.eclipse.jface.action.MenuManager.doItemFill(MenuManager.java:729)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:806)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:673)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.scheduleManagerUpdate(MenuManagerRenderer.java:1224)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.subscribeUIElementTopicVisible(MenuManagerRenderer.java:213)
	at jdk.internal.reflect.GeneratedMethodAccessor36.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	... 63 more
Caused by: java.io.FileNotFoundException: C:\Program Files\Git\mingw64\share\git\git-for-windows.ico (Le chemin d’accès spécifié est introuvable)
	at java.base/java.io.FileInputStream.open0(Native Method)
	at java.base/java.io.FileInputStream.open(FileInputStream.java:212)
	at java.base/java.io.FileInputStream.<init>(FileInputStream.java:154)
	at java.base/java.io.FileInputStream.<init>(FileInputStream.java:109)
	at org.eclipse.swt.graphics.ImageLoader.load(ImageLoader.java:181)
	... 77 more

!ENTRY org.eclipse.ui 4 0 2020-09-17 07:42:32.710
!MESSAGE Unhandled event loop exception
!STACK 0
org.eclipse.e4.core.di.InjectionException: org.eclipse.swt.SWTException: i/o error (java.io.FileNotFoundException: C:\Program Files\Git\mingw64\share\git\git-for-windows.ico (Le chemin d’accès spécifié est introuvable))
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:68)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:236)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4735)
	at org.eclipse.e4.ui.internal.workbench.swt.E4Application$1.syncExec(E4Application.java:219)
	at org.eclipse.e4.ui.internal.di.UIEventObjectSupplier$UIEventHandler.handleEvent(UIEventObjectSupplier.java:64)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:132)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.e4.ui.model.application.ui.impl.UIElementImpl.setVisible(UIElementImpl.java:361)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributionRecord.updateVisibility(ContributionRecord.java:105)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRendererFilter.updateElementVisibility(MenuManagerRendererFilter.java:197)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRendererFilter.updateElementVisibility(MenuManagerRendererFilter.java:208)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerShowProcessor.showMenu(MenuManagerShowProcessor.java:258)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerShowProcessor.menuAboutToHide(MenuManagerShowProcessor.java:115)
	at org.eclipse.jface.internal.MenuManagerEventHelper.showEventPostHelper(MenuManagerEventHelper.java:95)
	at org.eclipse.jface.action.MenuManager.handleAboutToShow(MenuManager.java:469)
	at org.eclipse.jface.action.MenuManager.access$1(MenuManager.java:463)
	at org.eclipse.jface.action.MenuManager$2.menuShown(MenuManager.java:495)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:259)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4213)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1037)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1042)
	at org.eclipse.swt.widgets.Control.WM_INITMENUPOPUP(Control.java:5137)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4769)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1480)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2142)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4923)
	at org.eclipse.swt.internal.win32.OS.TrackPopupMenu(Native Method)
	at org.eclipse.swt.widgets.Menu._setVisible(Menu.java:237)
	at org.eclipse.swt.widgets.Display.runPopups(Display.java:4071)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3624)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1158)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1047)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:658)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:557)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:154)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:137)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:107)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1447)
Caused by: org.eclipse.swt.SWTException: i/o error (java.io.FileNotFoundException: C:\Program Files\Git\mingw64\share\git\git-for-windows.ico (Le chemin d’accès spécifié est introuvable))
	at org.eclipse.swt.SWT.error(SWT.java:4723)
	at org.eclipse.swt.SWT.error(SWT.java:4638)
	at org.eclipse.swt.graphics.ImageLoader.load(ImageLoader.java:184)
	at org.eclipse.tm.terminal.view.ui.local.showin.ExternalExecutablesManager.loadImage(ExternalExecutablesManager.java:282)
	at org.eclipse.tm.terminal.view.ui.local.showin.DynamicContributionItems.getContributionItems(DynamicContributionItems.java:74)
	at org.eclipse.ui.actions.CompoundContributionItem.getContributionItemsToFill(CompoundContributionItem.java:83)
	at org.eclipse.ui.actions.CompoundContributionItem.fill(CompoundContributionItem.java:57)
	at org.eclipse.ui.internal.menus.DynamicMenuContributionItem.fill(DynamicMenuContributionItem.java:146)
	at org.eclipse.jface.action.MenuManager.doItemFill(MenuManager.java:729)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:806)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:673)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.scheduleManagerUpdate(MenuManagerRenderer.java:1224)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.subscribeUIElementTopicVisible(MenuManagerRenderer.java:213)
	at jdk.internal.reflect.GeneratedMethodAccessor36.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	... 63 more
Caused by: java.io.FileNotFoundException: C:\Program Files\Git\mingw64\share\git\git-for-windows.ico (Le chemin d’accès spécifié est introuvable)
	at java.base/java.io.FileInputStream.open0(Native Method)
	at java.base/java.io.FileInputStream.open(FileInputStream.java:212)
	at java.base/java.io.FileInputStream.<init>(FileInputStream.java:154)
	at java.base/java.io.FileInputStream.<init>(FileInputStream.java:109)
	at org.eclipse.swt.graphics.ImageLoader.load(ImageLoader.java:181)
	... 77 more

!ENTRY org.eclipse.ui 4 0 2020-09-17 07:42:40.248
!MESSAGE Unhandled event loop exception
!STACK 0
org.eclipse.e4.core.di.InjectionException: org.eclipse.swt.SWTException: i/o error (java.io.FileNotFoundException: C:\Program Files\Git\mingw64\share\git\git-for-windows.ico (Le chemin d’accès spécifié est introuvable))
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:68)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:236)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4735)
	at org.eclipse.e4.ui.internal.workbench.swt.E4Application$1.syncExec(E4Application.java:219)
	at org.eclipse.e4.ui.internal.di.UIEventObjectSupplier$UIEventHandler.handleEvent(UIEventObjectSupplier.java:64)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:132)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.e4.ui.model.application.ui.impl.UIElementImpl.setVisible(UIElementImpl.java:361)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributionRecord.updateVisibility(ContributionRecord.java:105)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRendererFilter.updateElementVisibility(MenuManagerRendererFilter.java:197)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRendererFilter.updateElementVisibility(MenuManagerRendererFilter.java:208)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerShowProcessor.showMenu(MenuManagerShowProcessor.java:258)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerShowProcessor.menuAboutToHide(MenuManagerShowProcessor.java:115)
	at org.eclipse.jface.internal.MenuManagerEventHelper.showEventPostHelper(MenuManagerEventHelper.java:95)
	at org.eclipse.jface.action.MenuManager.handleAboutToShow(MenuManager.java:469)
	at org.eclipse.jface.action.MenuManager.access$1(MenuManager.java:463)
	at org.eclipse.jface.action.MenuManager$2.menuShown(MenuManager.java:495)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:259)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4213)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1037)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1042)
	at org.eclipse.swt.widgets.Control.WM_INITMENUPOPUP(Control.java:5137)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4769)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1480)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2142)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4923)
	at org.eclipse.swt.internal.win32.OS.TrackPopupMenu(Native Method)
	at org.eclipse.swt.widgets.Menu._setVisible(Menu.java:237)
	at org.eclipse.swt.widgets.Display.runPopups(Display.java:4071)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3624)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1158)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1047)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:658)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:557)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:154)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:137)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:107)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1447)
Caused by: org.eclipse.swt.SWTException: i/o error (java.io.FileNotFoundException: C:\Program Files\Git\mingw64\share\git\git-for-windows.ico (Le chemin d’accès spécifié est introuvable))
	at org.eclipse.swt.SWT.error(SWT.java:4723)
	at org.eclipse.swt.SWT.error(SWT.java:4638)
	at org.eclipse.swt.graphics.ImageLoader.load(ImageLoader.java:184)
	at org.eclipse.tm.terminal.view.ui.local.showin.ExternalExecutablesManager.loadImage(ExternalExecutablesManager.java:282)
	at org.eclipse.tm.terminal.view.ui.local.showin.DynamicContributionItems.getContributionItems(DynamicContributionItems.java:74)
	at org.eclipse.ui.actions.CompoundContributionItem.getContributionItemsToFill(CompoundContributionItem.java:83)
	at org.eclipse.ui.actions.CompoundContributionItem.fill(CompoundContributionItem.java:57)
	at org.eclipse.ui.internal.menus.DynamicMenuContributionItem.fill(DynamicMenuContributionItem.java:146)
	at org.eclipse.jface.action.MenuManager.doItemFill(MenuManager.java:729)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:806)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:673)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.scheduleManagerUpdate(MenuManagerRenderer.java:1224)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.subscribeUIElementTopicVisible(MenuManagerRenderer.java:213)
	at jdk.internal.reflect.GeneratedMethodAccessor36.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	... 63 more
Caused by: java.io.FileNotFoundException: C:\Program Files\Git\mingw64\share\git\git-for-windows.ico (Le chemin d’accès spécifié est introuvable)
	at java.base/java.io.FileInputStream.open0(Native Method)
	at java.base/java.io.FileInputStream.open(FileInputStream.java:212)
	at java.base/java.io.FileInputStream.<init>(FileInputStream.java:154)
	at java.base/java.io.FileInputStream.<init>(FileInputStream.java:109)
	at org.eclipse.swt.graphics.ImageLoader.load(ImageLoader.java:181)
	... 77 more
!SESSION 2020-09-17 07:43:08.870 -----------------------------------------------
eclipse.buildId=4.16.0.I20200604-0540
java.version=14.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=fr_FR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2020-09-17 07:43:24.471
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2020-09-17 07:43:24.471
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5bb39285,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2b0d85bd,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2020-09-17 07:43:28.455
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\ayadi'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2020-09-17 07:45:52.271 -----------------------------------------------
eclipse.buildId=4.16.0.I20200604-0540
java.version=14.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=fr_FR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2020-09-17 07:45:58.573
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2020-09-17 07:45:58.573
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@31de27c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7ebfe01a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2020-09-17 07:46:02.762
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\ayadi'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2020-09-17 07:59:06.335 -----------------------------------------------
eclipse.buildId=4.16.0.I20200604-0540
java.version=14.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=fr_FR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2020-09-17 07:59:13.153
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2020-09-17 07:59:13.153
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7c5d36c3,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@31de27c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2020-09-17 07:59:16.493
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\ayadi'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.core 4 4 2020-09-17 08:08:16.909
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.GridBagLayout;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.event.WindowEvent;
import java.awt.event.WindowListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import java.awt.GridBagConstraints;
import java.awt.Insets;
import java.awt.Component;
import javax.swing.Box;

public class Jeu extends JFrame{
	JLabel label;
	JPanel panel = new JPanel();
	JLabel lblNewLabel = new JLabel("Time :");
	JLabel lblNewLabel_1 = new JLabel("Sacs restants :");
	JLabel lblNewLabel_2 = new JLabel("Intrus restants :");
	JLabel lblNewLabel_3 = new JLabel("Robots :");
	private Component verticalStrut;
	private final Component horizontalStrut = Box.createHorizontalStrut(20);
	private final Component horizontalStrut_1 = Box.createHorizontalStrut(20);
	public Jeu(ConfigurationModel configuration) {
		super("Jeu");
		setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);
		getContentPane().setLayout(new BorderLayout());
		 label = new JLabel("Hello");
		 label.setForeground(Color.red);
		label.setVisible(true);
		getContentPane().add(label,BorderLayout.SOUTH);
		getContentPane().add(new Map(configuration),BorderLayout.CENTER);
		getContentPane().add(panel, BorderLayout.NORTH);
		GridBagLayout gbl_panel = new GridBagLayout();
		gbl_panel.columnWidths = new int[]{52, 0, 0, 0, 0, 56, 0};
		gbl_panel.rowHeights = new int[]{0, 0, 0, 16, 0};
		gbl_panel.columnWeights = new double[]{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, Double.MIN_VALUE};
		gbl_panel.rowWeights = new double[]{0.0, 0.0, 0.0, 0.0, Double.MIN_VALUE};
		panel.setLayout(gbl_panel);
		
		verticalStrut = Box.createVerticalStrut(20);
		GridBagConstraints gbc_verticalStrut = new GridBagConstraints();
		gbc_verticalStrut.insets = new Insets(0, 0, 5, 5);
		gbc_verticalStrut.gridx = 0;
		gbc_verticalStrut.gridy = 0;
		panel.add(verticalStrut, gbc_verticalStrut);
		
		//JLabel lblNewLabel = new JLabel("Time :");
		GridBagConstraints gbc_lblNewLabel = new GridBagConstraints();
		gbc_lblNewLabel.insets = new Insets(0, 0, 5, 5);
		gbc_lblNewLabel.anchor = GridBagConstraints.NORTHWEST;
		gbc_lblNewLabel.gridx = 0;
		gbc_lblNewLabel.gridy = 1;
		panel.add(lblNewLabel, gbc_lblNewLabel);
		
		
		
		
		//lblNewLabel_1 = new JLabel("Sacs restants :");
		GridBagConstraints gbc_lblNewLabel_1 = new GridBagConstraints();
		gbc_lblNewLabel_1.insets = new Insets(0, 0, 5, 5);
		gbc_lblNewLabel_1.gridx = 0;
		gbc_lblNewLabel_1.gridy = 2;
		panel.add(lblNewLabel_1, gbc_lblNewLabel_1);
		
		GridBagConstraints gbc_horizontalStrut = new GridBagConstraints();
		gbc_horizontalStrut.insets = new Insets(0, 0, 5, 5);
		gbc_horizontalStrut.gridx = 1;
		gbc_horizontalStrut.gridy = 2;
		panel.add(horizontalStrut, gbc_horizontalStrut);
		
		//lblNewLabel_2 = new JLabel("nbre d'Intrus restants :");
		GridBagConstraints gbc_lblNewLabel_2 = new GridBagConstraints();
		gbc_lblNewLabel_2.insets = new Insets(0, 0, 5, 5);
		gbc_lblNewLabel_2.gridx = 2;
		gbc_lblNewLabel_2.gridy = 2;
		panel.add(lblNewLabel_2, gbc_lblNewLabel_2);
		
		GridBagConstraints gbc_horizontalStrut_1 = new GridBagConstraints();
		gbc_horizontalStrut_1.insets = new Insets(0, 0, 5, 5);
		gbc_horizontalStrut_1.gridx = 3;
		gbc_horizontalStrut_1.gridy = 2;
		panel.add(horizontalStrut_1, gbc_horizontalStrut_1);
		
		//lblNewLabel_3 = new JLabel("nbre de robots :");
		GridBagConstraints gbc_lblNewLabel_3 = new GridBagConstraints();
		gbc_lblNewLabel_3.insets = new Insets(0, 0, 5, 5);
		gbc_lblNewLabel_3.gridx = 4;
		gbc_lblNewLabel_3.gridy = 2;
		panel.add(lblNewLabel_3, gbc_lblNewLabel_3);
		pack();
		setLocationRelativeTo(null);
		setResizable(false);
		setVisible(true);
		
	}
	private class Map extends JPanel implements KeyListener,MouseListener,WindowListener {
		int width,height,cellWidth,cellHeight;
		private ConfigurationModel configuration ;
		private Vector<Robot> robots = new Vector<Robot>();
		private Vector<Intru> intrus = new Vector<Intru>();
		private Vector<Sac> sacs = new Vector<Sac>();
		private Vector<Obstacle> obstacles = new Vector<Obstacle>();
		private Vector<Sortie> sorties = new Vector<Sortie>();
		private int joueurActif ;
		private boolean jeuArrete;
		
		public Map(ConfigurationModel configuration) {
			this.configuration = configuration ; 
			joueurActif = 1;
			jeuArrete = true;
			width=getWidth();
			height=getHeight();
			cellWidth =40;
			cellHeight =40;
			prepare();
			changerTour();
			calculertemps();
			lblNewLabel_1.setText("Sacs restants: "+ sacs.size());
			lblNewLabel_2.setText("Intrus restants: "+intrus.size());
			lblNewLabel_3.setText("Robots: "+ robots.size());
			//afficher();
			this.addKeyListener(this);
			this.addMouseListener(this);
			addWindowListener(this);
	        this.setFocusable(true);
	        this.requestFocusInWindow();
	        
	        
	         
		}
		
		
		
		
	/*	//Afficher le nombre de robots, intrus et sacs
		private void afficher() {

			Timer myTimer2 = new Timer();
			TimerTask task2= new TimerTask() {
				int s=0;
				@Override
				public void run() {
					s++;
					int x1=sacs.size();
					int x2=intrus.size();
					int x3=robots.size();
					lblNewLabel_1.setText("Sacs restants: "+ x1);
					lblNewLabel_2.setText("Intrus restants: "+ x2);
					lblNewLabel_3.setText("Robots: "+ x3);
					//System.out.println(sacs.size());
				}
			};
			myTimer2.scheduleAtFixedRate(task2, 1000, 1000);
		}
		*/
		
		//Calculer le temps passé
		private void calculertemps() {
			//System.out.println("temps");
			
			Timer myTimer1 = new Timer();
			TimerTask task1= new TimerTask() {
				int SecondesPassed1 = 0;
				int min=0,heu=0;
				@Override
				public void run() {
					if (intrus.size()!=0) {
						SecondesPassed1 ++;  
					}
					
					String ch ="";
					
					if (SecondesPassed1 ==60) {
						min+=1;
						SecondesPassed1=0;
					}
					if (min==60) {
						heu+=1;
						min=0;
					}
					//System.out.println("Time: "+ SecondesPassed1);
					
					if (SecondesPassed1 / 10 == 0 && min/ 10==0 ) {
						ch="0"+heu+" : "+"0"+min+" : "+"0"+SecondesPassed1;
					}
					if (SecondesPassed1 / 10 != 0 && min/ 10==0) {
						ch="0"+heu+" : "+"0"+min+" : "+SecondesPassed1;
					}
					if (SecondesPassed1 / 10 == 0 && min/ 10!=0) {
						ch="0"+heu+" : "+min+" : "+"0"+SecondesPassed1;
					}
					
					if (SecondesPassed1 / 10 != 0 && min/ 10!=0) {
						ch="0"+heu+" : "+min+" : "+SecondesPassed1; 
					}
					lblNewLabel.setText("Time: " + ch );
					
					
				}
			};
			
			
				myTimer1.scheduleAtFixedRate(task1, 1000, 1000);
			
		
			
			
			
		}
		
		
		
		// Changer automatiquement le tour chaque 5 secondes
		private void changerTour()
		{
			
			Timer timer = new Timer();
			TimerTask  timerTask = new TimerTask() {
				int secondPassed = 0 ;
				@Override
				public void run() {
					secondPassed ++ ; 
					if (!jeuArrete) {
						//System.out.println("Il reste "+(5-secondPassed)+" secondes pourque le joueur " + joueurActif + " joue son coup !");
						label.setText("Il reste "+(5-secondPassed)+" secondes pourque le joueur " + joueurActif + " joue son coup !  .. Cliquer pour prendre le coup ! ..");
						if (secondPassed == 5 && joueurActif == 1) {
							secondPassed =0;
							joueurActif =2;
						}
						if (secondPassed == 5 && joueurActif == 2) {
							secondPassed =0;
							joueurActif =1;
						}
					}
					if (jeuArrete) {
						secondPassed = 0 ;
						label.setText("Joueur "+joueurActif+" en train de jouer !  .. Choisir une direction .. ");
					}
					
				}
			};
			timer.scheduleAtFixedRate(timerTask, 1000, 1000);
		}
		// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
		private void prepare()
		
		{
			for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
				int x= configuration.Emplac_Intrus.get(i).x;
				int y= configuration.Emplac_Intrus.get(i).y;
				Intru intru = new Intru(y, x, 1000);
				intrus.add(intru);
				MoveIntrus moveIntrus =new MoveIntrus(intru);
				moveIntrus.start();
			}
			for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
				int x= configuration.Emplac_Robots.get(i).x;
				int y= configuration.Emplac_Robots.get(i).y;
				Robot robot = new Robot(y,x, 500);
				robots.add(robot);
				MoveRobots moveRobots = new MoveRobots(robot);
				moveRobots.start();
			}
			for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
				int x= configuration.Emplac_Obstacle.get(i).x;
				int y= configuration.Emplac_Obstacle.get(i).y;
				Obstacle obstacle = new Obstacle(y, x);
				obstacles.add(obstacle);
			}
			for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
				int x= configuration.Emplac_Sac.get(i).x;
				int y= configuration.Emplac_Sac.get(i).y;
				Sac sac = new Sac(y, x);
				sacs.add(sac);
			}
			for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
				int x= configuration.Emplac_Sortie.get(i).x;
				int y= configuration.Emplac_Sortie.get(i).y;
				Sortie sortie = new Sortie(y, x);
				sorties.add(sortie);
			}
		}
		// verifier si p1 est adjacent à p2
		private boolean EstAdjacent(Point p1,Point p2)
		{
			if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
			((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
			return true;
			else return false;
		}
		private boolean MovementValide(Point p , char direction) {
			Point pa = null;
			switch (direction) {
			case 'D': pa = new Point(p.x+1,p.y);break;
			case 'G': pa = new Point(p.x-1,p.y);break;
			case 'B': pa = new Point(p.x,p.y+1);break;
			case 'H': pa = new Point(p.x,p.y-1);break;
			default:
				break;
			}
			if (pa != null) {
				for (int i = 0; i < obstacles.size(); i++) {
					if (obstacles.get(i).x == pa.x && obstacles.get(i).y== pa.y ) {
						return false;
					}
				}
				for (int i = 0; i < sacs.size(); i++) {
					if (sacs.get(i).x == pa.x && sacs.get(i).y== pa.y ) {
						return false;
					}
				}
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == pa.x && intrus.get(i).y== pa.y ) {
						return false;
					}
				}
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == pa.x && robots.get(i).y== pa.y ) {
						return false;
					}
				}
				for (int i = 0; i < sorties.size(); i++) {
					if (sorties.get(i).x == pa.x && sorties.get(i).y== pa.y ) {
						return false;
					}
				}
			}
			
			return true;
		}

		
		public class MoveIntrus extends Thread 
		{
			Intru intru ;
			MoveIntrus(Intru intru)
			{
				this.intru=intru;
			}
			@Override
			public void run() {
			//	int pas =0;
				while(true)
				{	//  un intru prend un sac 
					if (jeuArrete) {
					//	pas = 0 ;
						try {
							sleep(1000);
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
					}
					else 
					{
						// un intru prend un sac
						for (int i = 0; i < sacs.size(); i++) {
							if (EstAdjacent(intru, sacs.get(i))) {
								if (intru.PrendSac(sacs.get(i))) {
									sacs.remove(sacs.get(i));
									System.out.println(sacs.size());
									lblNewLabel_1.setText("Sacs restants: "+ sacs.size());
									
								}
																}
						} 
						//un robot attrape un intru 
						for (int i = 0; i < robots.size(); i++) {
							
							if (EstAdjacent(intru, robots.get(i)) )
								{
									for (int j = 0; j < intru.sacs.size(); j++) {
										
										sacs.add(intru.sacs.get(j));
										lblNewLabel_1.setText("Sacs restants: "+ sacs.size());
										
									}
									intru.retournerSac();
									intrus.remove(intru);
									lblNewLabel_2.setText("Intrus restants: "+intrus.size());
								}
						}
						// un intru sort à partir d'une sortie 
						for (int i = 0; i < sorties.size(); i++) {
							
							if (EstAdjacent(intru, sorties.get(i)) )
								{
									intrus.remove(intru);
									lblNewLabel_2.setText("Intrus restants: "+intrus.size());
								}
						}
						
						// le mouvement d'un intru d'une case à une autre
						if (intru.active==false) interrupt();
						
							
							if (MovementValide(intru, intru.direction))
							{
								intru.move();
								repaint();
								try {
									sleep(1000);
								} catch (InterruptedException e) {
									// TODO Auto-generated catch block
									e.printStackTrace();
								}
								
							}
						
					}
				
						
				}
							
				}
							
			}
		class MoveRobots extends Thread 
		{
			Robot robot;
			public MoveRobots(Robot robot) {
				this.robot = robot ;
			}

			@Override
			public void run() {
				// pas = 0;
				while(true)
				{
					if (jeuArrete) {
						//pas =0;
						try {
							sleep(1000);
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
					}
					else {
						
						// le mouvement d'un robot d'une case à une autre
						if (MovementValide(robot, robot.direction))
						{
							robot.move();
							repaint();
							
							try {
								//pas++;
								sleep(500);
								//if (pas==3) {
									//jeuArrete = true;
								//}
								
								
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						
					}
					
				}
							
				}
					
			}
		
		// dimensionner la JPanel
		@Override
		public Dimension getPreferredSize() {
			return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
			}
		// dessiner tous les objects 
		@Override
		protected void paintComponent(Graphics g) {
			super.paintComponent(g);
			
			if (intrus.size() == 0 )
			{
				jeuArrete = true;
				label.setText("le jeu est terminé !");
				ImageIcon imageIcon=new ImageIcon("resources\\GameOver.jpg");
				Image image = imageIcon.getImage();
				g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
				/*for (Thread t : Thread.getAllStackTraces().keySet()) 
				{  if (t.getState()==Thread.State.RUNNABLE) 
				     t.interrupt(); 
				} */

				
				repaint();
			}
			else {
				for (int i = 0; i < configuration.nbre_colonne; i++) {
					for (int j = 0; j < configuration.nbre_ligne; j++) {
						g.setColor(Color.WHITE);
						g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
					}
					
				}
				for (int i = 0; i < intrus.size(); i++) {
					if(intrus.get(i).active=true)
					{
						if (i == n ) {
							
							g.setColor(Color.red);
							g.draw3DRect(x, y, i, i, raised);(intrus.get(i).x*cellWidth,intrus.get(i).y*cellHeight, cellWidth, cellHeight);
						}
						intrus.get(i).draw(g);
					}
				}
				for (int i = 0; i < robots.size(); i++) {
					if (i == n ) {
						
						g.setColor(Color.red);
						g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
					}
					robots.get(i).draw(g);
				}
				for (int i = 0; i < obstacles.size(); i++) {
					
					obstacles.get(i).draw(g);
				}
				for (int i = 0; i < sacs.size(); i++) {
					
					sacs.get(i).draw(g);
				}
				/**for (int i = 0; i < sorties.size(); i++) {
					
					sorties.get(i).draw(g);
				}**/
			}
		}
		
		
		
		int n = -1 ;
		@Override
		public void keyTyped(KeyEvent e) {
			
			
			if (joueurActif == 1 && jeuArrete ) {
				if (robots.size() == 1) {
					n = 0;
				}
				if (n != -1) {
					
					Robot robot =  robots.get(n);
					switch (e.getKeyChar()) {
					case 'd': robot.TournerD();break;
					case 'q':robot.TournerG();break;
					case 'z':robot.TournerH();break;
					case 's':robot.TournerB();break;
					default:
						throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
					}
					joueurActif = 2 ;
					jeuArrete = false;
					n=-1;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
				
				
			}
			
				
				else if (joueurActif == 2 && jeuArrete ) {
					if (intrus.size() == 1 ) {
						n=0;
					}
					if (n != -1) {
						Intru intru =  intrus.get(n);
						switch (e.getKeyChar()) {
						case 'd': intru.TournerD();break;
						case 'q':intru.TournerG();break;
						case 'z':intru.TournerH();break;
						case 's':intru.TournerB();break;
						}
						joueurActif = 1 ;
						jeuArrete=false;
						n=-1;
					}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
					
			}	
			
		}
		@Override
		public void keyPressed(KeyEvent e) {
			// TODO Auto-generated method stub
			
		}
		@Override
		public void keyReleased(KeyEvent e) {
			// TODO Auto-generated method stub
			
		}
		@Override
		public void mouseClicked(MouseEvent e) {
			jeuArrete = true;
			n=-1;
			if (jeuArrete && (intrus.size() != 1 || robots.size() != 1)) {
				int colonne = e.getX()/cellWidth ;
				int ligne = e.getY() / cellWidth ;
				Point point = new Point(ligne,colonne);
				//System.out.println(point);
				if (joueurActif == 1  ) {
					for (int i = 0; i < robots.size(); i++) {
						if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
							n=i;
						}
					}
					if (n == -1 ) {
						JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
					}
					
				}
				if (joueurActif == 2  ) {
					for (int i = 0; i < intrus.size(); i++) {
						if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
							n=i;
						}
					}
					if (n == -1 ) {
						JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
					}
				}
				
			}
			
			
		}
		@Override
		public void mousePressed(MouseEvent e) {
			// TODO Auto-generated method stub
			
		}
		@Override
		public void mouseReleased(MouseEvent e) {
			// TODO Auto-generated method stub
			
		}
		@Override
		public void mouseEntered(MouseEvent e) {
			// TODO Auto-generated method stub
			
		}
		@Override
		public void mouseExited(MouseEvent e) {
			// TODO Auto-generated method stub
			
		}
		
		
		
		//verifier avant de quitter

		@Override
		public void windowActivated(WindowEvent e) {
			// TODO Auto-generated method stub
			
		}

		@Override
		public void windowClosed(WindowEvent e) {
			// TODO Auto-generated method stub
			
		}

		@Override
		public void windowClosing(WindowEvent e) {
			// TODO Auto-generated method stub
			exit();
			
			}
	
		void exit() {
			
			int a= JOptionPane.showConfirmDialog(null, "Clicker sur \"oui \" pour quitter vers le menu principal", "Quit options", JOptionPane.YES_NO_OPTION);
			if (a==JOptionPane.YES_OPTION) {
				dispose();
				Menu window = new Menu();
				window.main(null);
				
			}
			
			
			
		}
		

		@Override
		public void windowDeactivated(WindowEvent e) {
			// TODO Auto-generated method stub
			
		}

		@Override
		public void windowDeiconified(WindowEvent e) {
			// TODO Auto-generated method stub
			
		}

		@Override
		public void windowIconified(WindowEvent e) {
			// TODO Auto-generated method stub
			
		}

		@Override
		public void windowOpened(WindowEvent e) {
			// TODO Auto-generated method stub
			
		}
		
	}
}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2020-09-17 08:08:16.916
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2020-09-17 08:08:16.921
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-17 08:08:24.065
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.GridBagLayout;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.event.WindowEvent;
import java.awt.event.WindowListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import java.awt.GridBagConstraints;
import java.awt.Insets;
import java.awt.Component;
import javax.swing.Box;

public class Jeu extends JFrame{
	JLabel label;
	JPanel panel = new JPanel();
	JLabel lblNewLabel = new JLabel("Time :");
	JLabel lblNewLabel_1 = new JLabel("Sacs restants :");
	JLabel lblNewLabel_2 = new JLabel("Intrus restants :");
	JLabel lblNewLabel_3 = new JLabel("Robots :");
	private Component verticalStrut;
	private final Component horizontalStrut = Box.createHorizontalStrut(20);
	private final Component horizontalStrut_1 = Box.createHorizontalStrut(20);
	public Jeu(ConfigurationModel configuration) {
		super("Jeu");
		setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);
		getContentPane().setLayout(new BorderLayout());
		 label = new JLabel("Hello");
		 label.setForeground(Color.red);
		label.setVisible(true);
		getContentPane().add(label,BorderLayout.SOUTH);
		getContentPane().add(new Map(configuration),BorderLayout.CENTER);
		getContentPane().add(panel, BorderLayout.NORTH);
		GridBagLayout gbl_panel = new GridBagLayout();
		gbl_panel.columnWidths = new int[]{52, 0, 0, 0, 0, 56, 0};
		gbl_panel.rowHeights = new int[]{0, 0, 0, 16, 0};
		gbl_panel.columnWeights = new double[]{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, Double.MIN_VALUE};
		gbl_panel.rowWeights = new double[]{0.0, 0.0, 0.0, 0.0, Double.MIN_VALUE};
		panel.setLayout(gbl_panel);
		
		verticalStrut = Box.createVerticalStrut(20);
		GridBagConstraints gbc_verticalStrut = new GridBagConstraints();
		gbc_verticalStrut.insets = new Insets(0, 0, 5, 5);
		gbc_verticalStrut.gridx = 0;
		gbc_verticalStrut.gridy = 0;
		panel.add(verticalStrut, gbc_verticalStrut);
		
		//JLabel lblNewLabel = new JLabel("Time :");
		GridBagConstraints gbc_lblNewLabel = new GridBagConstraints();
		gbc_lblNewLabel.insets = new Insets(0, 0, 5, 5);
		gbc_lblNewLabel.anchor = GridBagConstraints.NORTHWEST;
		gbc_lblNewLabel.gridx = 0;
		gbc_lblNewLabel.gridy = 1;
		panel.add(lblNewLabel, gbc_lblNewLabel);
		
		
		
		
		//lblNewLabel_1 = new JLabel("Sacs restants :");
		GridBagConstraints gbc_lblNewLabel_1 = new GridBagConstraints();
		gbc_lblNewLabel_1.insets = new Insets(0, 0, 5, 5);
		gbc_lblNewLabel_1.gridx = 0;
		gbc_lblNewLabel_1.gridy = 2;
		panel.add(lblNewLabel_1, gbc_lblNewLabel_1);
		
		GridBagConstraints gbc_horizontalStrut = new GridBagConstraints();
		gbc_horizontalStrut.insets = new Insets(0, 0, 5, 5);
		gbc_horizontalStrut.gridx = 1;
		gbc_horizontalStrut.gridy = 2;
		panel.add(horizontalStrut, gbc_horizontalStrut);
		
		//lblNewLabel_2 = new JLabel("nbre d'Intrus restants :");
		GridBagConstraints gbc_lblNewLabel_2 = new GridBagConstraints();
		gbc_lblNewLabel_2.insets = new Insets(0, 0, 5, 5);
		gbc_lblNewLabel_2.gridx = 2;
		gbc_lblNewLabel_2.gridy = 2;
		panel.add(lblNewLabel_2, gbc_lblNewLabel_2);
		
		GridBagConstraints gbc_horizontalStrut_1 = new GridBagConstraints();
		gbc_horizontalStrut_1.insets = new Insets(0, 0, 5, 5);
		gbc_horizontalStrut_1.gridx = 3;
		gbc_horizontalStrut_1.gridy = 2;
		panel.add(horizontalStrut_1, gbc_horizontalStrut_1);
		
		//lblNewLabel_3 = new JLabel("nbre de robots :");
		GridBagConstraints gbc_lblNewLabel_3 = new GridBagConstraints();
		gbc_lblNewLabel_3.insets = new Insets(0, 0, 5, 5);
		gbc_lblNewLabel_3.gridx = 4;
		gbc_lblNewLabel_3.gridy = 2;
		panel.add(lblNewLabel_3, gbc_lblNewLabel_3);
		pack();
		setLocationRelativeTo(null);
		setResizable(false);
		setVisible(true);
		
	}
	private class Map extends JPanel implements KeyListener,MouseListener,WindowListener {
		int width,height,cellWidth,cellHeight;
		private ConfigurationModel configuration ;
		private Vector<Robot> robots = new Vector<Robot>();
		private Vector<Intru> intrus = new Vector<Intru>();
		private Vector<Sac> sacs = new Vector<Sac>();
		private Vector<Obstacle> obstacles = new Vector<Obstacle>();
		private Vector<Sortie> sorties = new Vector<Sortie>();
		private int joueurActif ;
		private boolean jeuArrete;
		
		public Map(ConfigurationModel configuration) {
			this.configuration = configuration ; 
			joueurActif = 1;
			jeuArrete = true;
			width=getWidth();
			height=getHeight();
			cellWidth =40;
			cellHeight =40;
			prepare();
			changerTour();
			calculertemps();
			lblNewLabel_1.setText("Sacs restants: "+ sacs.size());
			lblNewLabel_2.setText("Intrus restants: "+intrus.size());
			lblNewLabel_3.setText("Robots: "+ robots.size());
			//afficher();
			this.addKeyListener(this);
			this.addMouseListener(this);
			addWindowListener(this);
	        this.setFocusable(true);
	        this.requestFocusInWindow();
	        
	        
	         
		}
		
		
		
		
	/*	//Afficher le nombre de robots, intrus et sacs
		private void afficher() {

			Timer myTimer2 = new Timer();
			TimerTask task2= new TimerTask() {
				int s=0;
				@Override
				public void run() {
					s++;
					int x1=sacs.size();
					int x2=intrus.size();
					int x3=robots.size();
					lblNewLabel_1.setText("Sacs restants: "+ x1);
					lblNewLabel_2.setText("Intrus restants: "+ x2);
					lblNewLabel_3.setText("Robots: "+ x3);
					//System.out.println(sacs.size());
				}
			};
			myTimer2.scheduleAtFixedRate(task2, 1000, 1000);
		}
		*/
		
		//Calculer le temps passé
		private void calculertemps() {
			//System.out.println("temps");
			
			Timer myTimer1 = new Timer();
			TimerTask task1= new TimerTask() {
				int SecondesPassed1 = 0;
				int min=0,heu=0;
				@Override
				public void run() {
					if (intrus.size()!=0) {
						SecondesPassed1 ++;  
					}
					
					String ch ="";
					
					if (SecondesPassed1 ==60) {
						min+=1;
						SecondesPassed1=0;
					}
					if (min==60) {
						heu+=1;
						min=0;
					}
					//System.out.println("Time: "+ SecondesPassed1);
					
					if (SecondesPassed1 / 10 == 0 && min/ 10==0 ) {
						ch="0"+heu+" : "+"0"+min+" : "+"0"+SecondesPassed1;
					}
					if (SecondesPassed1 / 10 != 0 && min/ 10==0) {
						ch="0"+heu+" : "+"0"+min+" : "+SecondesPassed1;
					}
					if (SecondesPassed1 / 10 == 0 && min/ 10!=0) {
						ch="0"+heu+" : "+min+" : "+"0"+SecondesPassed1;
					}
					
					if (SecondesPassed1 / 10 != 0 && min/ 10!=0) {
						ch="0"+heu+" : "+min+" : "+SecondesPassed1; 
					}
					lblNewLabel.setText("Time: " + ch );
					
					
				}
			};
			
			
				myTimer1.scheduleAtFixedRate(task1, 1000, 1000);
			
		
			
			
			
		}
		
		
		
		// Changer automatiquement le tour chaque 5 secondes
		private void changerTour()
		{
			
			Timer timer = new Timer();
			TimerTask  timerTask = new TimerTask() {
				int secondPassed = 0 ;
				@Override
				public void run() {
					secondPassed ++ ; 
					if (!jeuArrete) {
						//System.out.println("Il reste "+(5-secondPassed)+" secondes pourque le joueur " + joueurActif + " joue son coup !");
						label.setText("Il reste "+(5-secondPassed)+" secondes pourque le joueur " + joueurActif + " joue son coup !  .. Cliquer pour prendre le coup ! ..");
						if (secondPassed == 5 && joueurActif == 1) {
							secondPassed =0;
							joueurActif =2;
						}
						if (secondPassed == 5 && joueurActif == 2) {
							secondPassed =0;
							joueurActif =1;
						}
					}
					if (jeuArrete) {
						secondPassed = 0 ;
						label.setText("Joueur "+joueurActif+" en train de jouer !  .. Choisir une direction .. ");
					}
					
				}
			};
			timer.scheduleAtFixedRate(timerTask, 1000, 1000);
		}
		// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
		private void prepare()
		
		{
			for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
				int x= configuration.Emplac_Intrus.get(i).x;
				int y= configuration.Emplac_Intrus.get(i).y;
				Intru intru = new Intru(y, x, 1000);
				intrus.add(intru);
				MoveIntrus moveIntrus =new MoveIntrus(intru);
				moveIntrus.start();
			}
			for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
				int x= configuration.Emplac_Robots.get(i).x;
				int y= configuration.Emplac_Robots.get(i).y;
				Robot robot = new Robot(y,x, 500);
				robots.add(robot);
				MoveRobots moveRobots = new MoveRobots(robot);
				moveRobots.start();
			}
			for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
				int x= configuration.Emplac_Obstacle.get(i).x;
				int y= configuration.Emplac_Obstacle.get(i).y;
				Obstacle obstacle = new Obstacle(y, x);
				obstacles.add(obstacle);
			}
			for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
				int x= configuration.Emplac_Sac.get(i).x;
				int y= configuration.Emplac_Sac.get(i).y;
				Sac sac = new Sac(y, x);
				sacs.add(sac);
			}
			for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
				int x= configuration.Emplac_Sortie.get(i).x;
				int y= configuration.Emplac_Sortie.get(i).y;
				Sortie sortie = new Sortie(y, x);
				sorties.add(sortie);
			}
		}
		// verifier si p1 est adjacent à p2
		private boolean EstAdjacent(Point p1,Point p2)
		{
			if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
			((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
			return true;
			else return false;
		}
		private boolean MovementValide(Point p , char direction) {
			Point pa = null;
			switch (direction) {
			case 'D': pa = new Point(p.x+1,p.y);break;
			case 'G': pa = new Point(p.x-1,p.y);break;
			case 'B': pa = new Point(p.x,p.y+1);break;
			case 'H': pa = new Point(p.x,p.y-1);break;
			default:
				break;
			}
			if (pa != null) {
				for (int i = 0; i < obstacles.size(); i++) {
					if (obstacles.get(i).x == pa.x && obstacles.get(i).y== pa.y ) {
						return false;
					}
				}
				for (int i = 0; i < sacs.size(); i++) {
					if (sacs.get(i).x == pa.x && sacs.get(i).y== pa.y ) {
						return false;
					}
				}
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == pa.x && intrus.get(i).y== pa.y ) {
						return false;
					}
				}
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == pa.x && robots.get(i).y== pa.y ) {
						return false;
					}
				}
				for (int i = 0; i < sorties.size(); i++) {
					if (sorties.get(i).x == pa.x && sorties.get(i).y== pa.y ) {
						return false;
					}
				}
			}
			
			return true;
		}

		
		public class MoveIntrus extends Thread 
		{
			Intru intru ;
			MoveIntrus(Intru intru)
			{
				this.intru=intru;
			}
			@Override
			public void run() {
			//	int pas =0;
				while(true)
				{	//  un intru prend un sac 
					if (jeuArrete) {
					//	pas = 0 ;
						try {
							sleep(1000);
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
					}
					else 
					{
						// un intru prend un sac
						for (int i = 0; i < sacs.size(); i++) {
							if (EstAdjacent(intru, sacs.get(i))) {
								if (intru.PrendSac(sacs.get(i))) {
									sacs.remove(sacs.get(i));
									System.out.println(sacs.size());
									lblNewLabel_1.setText("Sacs restants: "+ sacs.size());
									
								}
																}
						} 
						//un robot attrape un intru 
						for (int i = 0; i < robots.size(); i++) {
							
							if (EstAdjacent(intru, robots.get(i)) )
								{
									for (int j = 0; j < intru.sacs.size(); j++) {
										
										sacs.add(intru.sacs.get(j));
										lblNewLabel_1.setText("Sacs restants: "+ sacs.size());
										
									}
									intru.retournerSac();
									intrus.remove(intru);
									lblNewLabel_2.setText("Intrus restants: "+intrus.size());
								}
						}
						// un intru sort à partir d'une sortie 
						for (int i = 0; i < sorties.size(); i++) {
							
							if (EstAdjacent(intru, sorties.get(i)) )
								{
									intrus.remove(intru);
									lblNewLabel_2.setText("Intrus restants: "+intrus.size());
								}
						}
						
						// le mouvement d'un intru d'une case à une autre
						if (intru.active==false) interrupt();
						
							
							if (MovementValide(intru, intru.direction))
							{
								intru.move();
								repaint();
								try {
									sleep(1000);
								} catch (InterruptedException e) {
									// TODO Auto-generated catch block
									e.printStackTrace();
								}
								
							}
						
					}
				
						
				}
							
				}
							
			}
		class MoveRobots extends Thread 
		{
			Robot robot;
			public MoveRobots(Robot robot) {
				this.robot = robot ;
			}

			@Override
			public void run() {
				// pas = 0;
				while(true)
				{
					if (jeuArrete) {
						//pas =0;
						try {
							sleep(1000);
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
					}
					else {
						
						// le mouvement d'un robot d'une case à une autre
						if (MovementValide(robot, robot.direction))
						{
							robot.move();
							repaint();
							
							try {
								//pas++;
								sleep(500);
								//if (pas==3) {
									//jeuArrete = true;
								//}
								
								
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						
					}
					
				}
							
				}
					
			}
		
		// dimensionner la JPanel
		@Override
		public Dimension getPreferredSize() {
			return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
			}
		// dessiner tous les objects 
		@Override
		protected void paintComponent(Graphics g) {
			super.paintComponent(g);
			
			if (intrus.size() == 0 )
			{
				jeuArrete = true;
				label.setText("le jeu est terminé !");
				ImageIcon imageIcon=new ImageIcon("resources\\GameOver.jpg");
				Image image = imageIcon.getImage();
				g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
				/*for (Thread t : Thread.getAllStackTraces().keySet()) 
				{  if (t.getState()==Thread.State.RUNNABLE) 
				     t.interrupt(); 
				} */

				
				repaint();
			}
			else {
				for (int i = 0; i < configuration.nbre_colonne; i++) {
					for (int j = 0; j < configuration.nbre_ligne; j++) {
						g.setColor(Color.WHITE);
						g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
					}
					
				}
				for (int i = 0; i < intrus.size(); i++) {
					if(intrus.get(i).active=true)
					{
						if (i == n ) {
							
							g.setColor(Color.red);
							g.draw3DRect(x, y, i, i, raised);(intrus.get(i).x*cellWidth,intrus.get(i).y*cellHeight, cellWidth, cellHeight);
						}
						intrus.get(i).draw(g);
					}
				}
				for (int i = 0; i < robots.size(); i++) {
					if (i == n ) {
						
						g.setColor(Color.red);
						g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
					}
					robots.get(i).draw(g);
				}
				for (int i = 0; i < obstacles.size(); i++) {
					
					obstacles.get(i).draw(g);
				}
				for (int i = 0; i < sacs.size(); i++) {
					
					sacs.get(i).draw(g);
				}
				/**for (int i = 0; i < sorties.size(); i++) {
					
					sorties.get(i).draw(g);
				}**/
			}
		}
		
		
		
		int n = -1 ;
		@Override
		public void keyTyped(KeyEvent e) {
			
			
			if (joueurActif == 1 && jeuArrete ) {
				if (robots.size() == 1) {
					n = 0;
				}
				if (n != -1) {
					
					Robot robot =  robots.get(n);
					switch (e.getKeyChar()) {
					case 'd': robot.TournerD();break;
					case 'q':robot.TournerG();break;
					case 'z':robot.TournerH();break;
					case 's':robot.TournerB();break;
					default:
						throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
					}
					joueurActif = 2 ;
					jeuArrete = false;
					n=-1;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
				
				
			}
			
				
				else if (joueurActif == 2 && jeuArrete ) {
					if (intrus.size() == 1 ) {
						n=0;
					}
					if (n != -1) {
						Intru intru =  intrus.get(n);
						switch (e.getKeyChar()) {
						case 'd': intru.TournerD();break;
						case 'q':intru.TournerG();break;
						case 'z':intru.TournerH();break;
						case 's':intru.TournerB();break;
						}
						joueurActif = 1 ;
						jeuArrete=false;
						n=-1;
					}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
					
			}	
			
		}
		@Override
		public void keyPressed(KeyEvent e) {
			// TODO Auto-generated method stub
			
		}
		@Override
		public void keyReleased(KeyEvent e) {
			// TODO Auto-generated method stub
			
		}
		@Override
		public void mouseClicked(MouseEvent e) {
			jeuArrete = true;
			n=-1;
			if (jeuArrete && (intrus.size() != 1 || robots.size() != 1)) {
				int colonne = e.getX()/cellWidth ;
				int ligne = e.getY() / cellWidth ;
				Point point = new Point(ligne,colonne);
				//System.out.println(point);
				if (joueurActif == 1  ) {
					for (int i = 0; i < robots.size(); i++) {
						if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
							n=i;
						}
					}
					if (n == -1 ) {
						JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
					}
					
				}
				if (joueurActif == 2  ) {
					for (int i = 0; i < intrus.size(); i++) {
						if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
							n=i;
						}
					}
					if (n == -1 ) {
						JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
					}
				}
				
			}
			
			
		}
		@Override
		public void mousePressed(MouseEvent e) {
			// TODO Auto-generated method stub
			
		}
		@Override
		public void mouseReleased(MouseEvent e) {
			// TODO Auto-generated method stub
			
		}
		@Override
		public void mouseEntered(MouseEvent e) {
			// TODO Auto-generated method stub
			
		}
		@Override
		public void mouseExited(MouseEvent e) {
			// TODO Auto-generated method stub
			
		}
		
		
		
		//verifier avant de quitter

		@Override
		public void windowActivated(WindowEvent e) {
			// TODO Auto-generated method stub
			
		}

		@Override
		public void windowClosed(WindowEvent e) {
			// TODO Auto-generated method stub
			
		}

		@Override
		public void windowClosing(WindowEvent e) {
			// TODO Auto-generated method stub
			exit();
			
			}
	
		void exit() {
			
			int a= JOptionPane.showConfirmDialog(null, "Clicker sur \"oui \" pour quitter vers le menu principal", "Quit options", JOptionPane.YES_NO_OPTION);
			if (a==JOptionPane.YES_OPTION) {
				dispose();
				Menu window = new Menu();
				window.main(null);
				
			}
			
			
			
		}
		

		@Override
		public void windowDeactivated(WindowEvent e) {
			// TODO Auto-generated method stub
			
		}

		@Override
		public void windowDeiconified(WindowEvent e) {
			// TODO Auto-generated method stub
			
		}

		@Override
		public void windowIconified(WindowEvent e) {
			// TODO Auto-generated method stub
			
		}

		@Override
		public void windowOpened(WindowEvent e) {
			// TODO Auto-generated method stub
			
		}
		
	}
}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-09-17 08:08:24.071
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-09-17 08:08:24.075
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-17 08:08:24.138
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.GridBagLayout;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.event.WindowEvent;
import java.awt.event.WindowListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import java.awt.GridBagConstraints;
import java.awt.Insets;
import java.awt.Component;
import javax.swing.Box;

public class Jeu extends JFrame{
	JLabel label;
	JPanel panel = new JPanel();
	JLabel lblNewLabel = new JLabel("Time :");
	JLabel lblNewLabel_1 = new JLabel("Sacs restants :");
	JLabel lblNewLabel_2 = new JLabel("Intrus restants :");
	JLabel lblNewLabel_3 = new JLabel("Robots :");
	private Component verticalStrut;
	private final Component horizontalStrut = Box.createHorizontalStrut(20);
	private final Component horizontalStrut_1 = Box.createHorizontalStrut(20);
	public Jeu(ConfigurationModel configuration) {
		super("Jeu");
		setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);
		getContentPane().setLayout(new BorderLayout());
		 label = new JLabel("Hello");
		 label.setForeground(Color.red);
		label.setVisible(true);
		getContentPane().add(label,BorderLayout.SOUTH);
		getContentPane().add(new Map(configuration),BorderLayout.CENTER);
		getContentPane().add(panel, BorderLayout.NORTH);
		GridBagLayout gbl_panel = new GridBagLayout();
		gbl_panel.columnWidths = new int[]{52, 0, 0, 0, 0, 56, 0};
		gbl_panel.rowHeights = new int[]{0, 0, 0, 16, 0};
		gbl_panel.columnWeights = new double[]{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, Double.MIN_VALUE};
		gbl_panel.rowWeights = new double[]{0.0, 0.0, 0.0, 0.0, Double.MIN_VALUE};
		panel.setLayout(gbl_panel);
		
		verticalStrut = Box.createVerticalStrut(20);
		GridBagConstraints gbc_verticalStrut = new GridBagConstraints();
		gbc_verticalStrut.insets = new Insets(0, 0, 5, 5);
		gbc_verticalStrut.gridx = 0;
		gbc_verticalStrut.gridy = 0;
		panel.add(verticalStrut, gbc_verticalStrut);
		
		//JLabel lblNewLabel = new JLabel("Time :");
		GridBagConstraints gbc_lblNewLabel = new GridBagConstraints();
		gbc_lblNewLabel.insets = new Insets(0, 0, 5, 5);
		gbc_lblNewLabel.anchor = GridBagConstraints.NORTHWEST;
		gbc_lblNewLabel.gridx = 0;
		gbc_lblNewLabel.gridy = 1;
		panel.add(lblNewLabel, gbc_lblNewLabel);
		
		
		
		
		//lblNewLabel_1 = new JLabel("Sacs restants :");
		GridBagConstraints gbc_lblNewLabel_1 = new GridBagConstraints();
		gbc_lblNewLabel_1.insets = new Insets(0, 0, 5, 5);
		gbc_lblNewLabel_1.gridx = 0;
		gbc_lblNewLabel_1.gridy = 2;
		panel.add(lblNewLabel_1, gbc_lblNewLabel_1);
		
		GridBagConstraints gbc_horizontalStrut = new GridBagConstraints();
		gbc_horizontalStrut.insets = new Insets(0, 0, 5, 5);
		gbc_horizontalStrut.gridx = 1;
		gbc_horizontalStrut.gridy = 2;
		panel.add(horizontalStrut, gbc_horizontalStrut);
		
		//lblNewLabel_2 = new JLabel("nbre d'Intrus restants :");
		GridBagConstraints gbc_lblNewLabel_2 = new GridBagConstraints();
		gbc_lblNewLabel_2.insets = new Insets(0, 0, 5, 5);
		gbc_lblNewLabel_2.gridx = 2;
		gbc_lblNewLabel_2.gridy = 2;
		panel.add(lblNewLabel_2, gbc_lblNewLabel_2);
		
		GridBagConstraints gbc_horizontalStrut_1 = new GridBagConstraints();
		gbc_horizontalStrut_1.insets = new Insets(0, 0, 5, 5);
		gbc_horizontalStrut_1.gridx = 3;
		gbc_horizontalStrut_1.gridy = 2;
		panel.add(horizontalStrut_1, gbc_horizontalStrut_1);
		
		//lblNewLabel_3 = new JLabel("nbre de robots :");
		GridBagConstraints gbc_lblNewLabel_3 = new GridBagConstraints();
		gbc_lblNewLabel_3.insets = new Insets(0, 0, 5, 5);
		gbc_lblNewLabel_3.gridx = 4;
		gbc_lblNewLabel_3.gridy = 2;
		panel.add(lblNewLabel_3, gbc_lblNewLabel_3);
		pack();
		setLocationRelativeTo(null);
		setResizable(false);
		setVisible(true);
		
	}
	private class Map extends JPanel implements KeyListener,MouseListener,WindowListener {
		int width,height,cellWidth,cellHeight;
		private ConfigurationModel configuration ;
		private Vector<Robot> robots = new Vector<Robot>();
		private Vector<Intru> intrus = new Vector<Intru>();
		private Vector<Sac> sacs = new Vector<Sac>();
		private Vector<Obstacle> obstacles = new Vector<Obstacle>();
		private Vector<Sortie> sorties = new Vector<Sortie>();
		private int joueurActif ;
		private boolean jeuArrete;
		
		public Map(ConfigurationModel configuration) {
			this.configuration = configuration ; 
			joueurActif = 1;
			jeuArrete = true;
			width=getWidth();
			height=getHeight();
			cellWidth =40;
			cellHeight =40;
			prepare();
			changerTour();
			calculertemps();
			lblNewLabel_1.setText("Sacs restants: "+ sacs.size());
			lblNewLabel_2.setText("Intrus restants: "+intrus.size());
			lblNewLabel_3.setText("Robots: "+ robots.size());
			//afficher();
			this.addKeyListener(this);
			this.addMouseListener(this);
			addWindowListener(this);
	        this.setFocusable(true);
	        this.requestFocusInWindow();
	        
	        
	         
		}
		
		
		
		
	/*	//Afficher le nombre de robots, intrus et sacs
		private void afficher() {

			Timer myTimer2 = new Timer();
			TimerTask task2= new TimerTask() {
				int s=0;
				@Override
				public void run() {
					s++;
					int x1=sacs.size();
					int x2=intrus.size();
					int x3=robots.size();
					lblNewLabel_1.setText("Sacs restants: "+ x1);
					lblNewLabel_2.setText("Intrus restants: "+ x2);
					lblNewLabel_3.setText("Robots: "+ x3);
					//System.out.println(sacs.size());
				}
			};
			myTimer2.scheduleAtFixedRate(task2, 1000, 1000);
		}
		*/
		
		//Calculer le temps passé
		private void calculertemps() {
			//System.out.println("temps");
			
			Timer myTimer1 = new Timer();
			TimerTask task1= new TimerTask() {
				int SecondesPassed1 = 0;
				int min=0,heu=0;
				@Override
				public void run() {
					if (intrus.size()!=0) {
						SecondesPassed1 ++;  
					}
					
					String ch ="";
					
					if (SecondesPassed1 ==60) {
						min+=1;
						SecondesPassed1=0;
					}
					if (min==60) {
						heu+=1;
						min=0;
					}
					//System.out.println("Time: "+ SecondesPassed1);
					
					if (SecondesPassed1 / 10 == 0 && min/ 10==0 ) {
						ch="0"+heu+" : "+"0"+min+" : "+"0"+SecondesPassed1;
					}
					if (SecondesPassed1 / 10 != 0 && min/ 10==0) {
						ch="0"+heu+" : "+"0"+min+" : "+SecondesPassed1;
					}
					if (SecondesPassed1 / 10 == 0 && min/ 10!=0) {
						ch="0"+heu+" : "+min+" : "+"0"+SecondesPassed1;
					}
					
					if (SecondesPassed1 / 10 != 0 && min/ 10!=0) {
						ch="0"+heu+" : "+min+" : "+SecondesPassed1; 
					}
					lblNewLabel.setText("Time: " + ch );
					
					
				}
			};
			
			
				myTimer1.scheduleAtFixedRate(task1, 1000, 1000);
			
		
			
			
			
		}
		
		
		
		// Changer automatiquement le tour chaque 5 secondes
		private void changerTour()
		{
			
			Timer timer = new Timer();
			TimerTask  timerTask = new TimerTask() {
				int secondPassed = 0 ;
				@Override
				public void run() {
					secondPassed ++ ; 
					if (!jeuArrete) {
						//System.out.println("Il reste "+(5-secondPassed)+" secondes pourque le joueur " + joueurActif + " joue son coup !");
						label.setText("Il reste "+(5-secondPassed)+" secondes pourque le joueur " + joueurActif + " joue son coup !  .. Cliquer pour prendre le coup ! ..");
						if (secondPassed == 5 && joueurActif == 1) {
							secondPassed =0;
							joueurActif =2;
						}
						if (secondPassed == 5 && joueurActif == 2) {
							secondPassed =0;
							joueurActif =1;
						}
					}
					if (jeuArrete) {
						secondPassed = 0 ;
						label.setText("Joueur "+joueurActif+" en train de jouer !  .. Choisir une direction .. ");
					}
					
				}
			};
			timer.scheduleAtFixedRate(timerTask, 1000, 1000);
		}
		// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
		private void prepare()
		
		{
			for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
				int x= configuration.Emplac_Intrus.get(i).x;
				int y= configuration.Emplac_Intrus.get(i).y;
				Intru intru = new Intru(y, x, 1000);
				intrus.add(intru);
				MoveIntrus moveIntrus =new MoveIntrus(intru);
				moveIntrus.start();
			}
			for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
				int x= configuration.Emplac_Robots.get(i).x;
				int y= configuration.Emplac_Robots.get(i).y;
				Robot robot = new Robot(y,x, 500);
				robots.add(robot);
				MoveRobots moveRobots = new MoveRobots(robot);
				moveRobots.start();
			}
			for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
				int x= configuration.Emplac_Obstacle.get(i).x;
				int y= configuration.Emplac_Obstacle.get(i).y;
				Obstacle obstacle = new Obstacle(y, x);
				obstacles.add(obstacle);
			}
			for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
				int x= configuration.Emplac_Sac.get(i).x;
				int y= configuration.Emplac_Sac.get(i).y;
				Sac sac = new Sac(y, x);
				sacs.add(sac);
			}
			for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
				int x= configuration.Emplac_Sortie.get(i).x;
				int y= configuration.Emplac_Sortie.get(i).y;
				Sortie sortie = new Sortie(y, x);
				sorties.add(sortie);
			}
		}
		// verifier si p1 est adjacent à p2
		private boolean EstAdjacent(Point p1,Point p2)
		{
			if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
			((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
			return true;
			else return false;
		}
		private boolean MovementValide(Point p , char direction) {
			Point pa = null;
			switch (direction) {
			case 'D': pa = new Point(p.x+1,p.y);break;
			case 'G': pa = new Point(p.x-1,p.y);break;
			case 'B': pa = new Point(p.x,p.y+1);break;
			case 'H': pa = new Point(p.x,p.y-1);break;
			default:
				break;
			}
			if (pa != null) {
				for (int i = 0; i < obstacles.size(); i++) {
					if (obstacles.get(i).x == pa.x && obstacles.get(i).y== pa.y ) {
						return false;
					}
				}
				for (int i = 0; i < sacs.size(); i++) {
					if (sacs.get(i).x == pa.x && sacs.get(i).y== pa.y ) {
						return false;
					}
				}
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == pa.x && intrus.get(i).y== pa.y ) {
						return false;
					}
				}
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == pa.x && robots.get(i).y== pa.y ) {
						return false;
					}
				}
				for (int i = 0; i < sorties.size(); i++) {
					if (sorties.get(i).x == pa.x && sorties.get(i).y== pa.y ) {
						return false;
					}
				}
			}
			
			return true;
		}

		
		public class MoveIntrus extends Thread 
		{
			Intru intru ;
			MoveIntrus(Intru intru)
			{
				this.intru=intru;
			}
			@Override
			public void run() {
			//	int pas =0;
				while(true)
				{	//  un intru prend un sac 
					if (jeuArrete) {
					//	pas = 0 ;
						try {
							sleep(1000);
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
					}
					else 
					{
						// un intru prend un sac
						for (int i = 0; i < sacs.size(); i++) {
							if (EstAdjacent(intru, sacs.get(i))) {
								if (intru.PrendSac(sacs.get(i))) {
									sacs.remove(sacs.get(i));
									System.out.println(sacs.size());
									lblNewLabel_1.setText("Sacs restants: "+ sacs.size());
									
								}
																}
						} 
						//un robot attrape un intru 
						for (int i = 0; i < robots.size(); i++) {
							
							if (EstAdjacent(intru, robots.get(i)) )
								{
									for (int j = 0; j < intru.sacs.size(); j++) {
										
										sacs.add(intru.sacs.get(j));
										lblNewLabel_1.setText("Sacs restants: "+ sacs.size());
										
									}
									intru.retournerSac();
									intrus.remove(intru);
									lblNewLabel_2.setText("Intrus restants: "+intrus.size());
								}
						}
						// un intru sort à partir d'une sortie 
						for (int i = 0; i < sorties.size(); i++) {
							
							if (EstAdjacent(intru, sorties.get(i)) )
								{
									intrus.remove(intru);
									lblNewLabel_2.setText("Intrus restants: "+intrus.size());
								}
						}
						
						// le mouvement d'un intru d'une case à une autre
						if (intru.active==false) interrupt();
						
							
							if (MovementValide(intru, intru.direction))
							{
								intru.move();
								repaint();
								try {
									sleep(1000);
								} catch (InterruptedException e) {
									// TODO Auto-generated catch block
									e.printStackTrace();
								}
								
							}
						
					}
				
						
				}
							
				}
							
			}
		class MoveRobots extends Thread 
		{
			Robot robot;
			public MoveRobots(Robot robot) {
				this.robot = robot ;
			}

			@Override
			public void run() {
				// pas = 0;
				while(true)
				{
					if (jeuArrete) {
						//pas =0;
						try {
							sleep(1000);
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
					}
					else {
						
						// le mouvement d'un robot d'une case à une autre
						if (MovementValide(robot, robot.direction))
						{
							robot.move();
							repaint();
							
							try {
								//pas++;
								sleep(500);
								//if (pas==3) {
									//jeuArrete = true;
								//}
								
								
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						
					}
					
				}
							
				}
					
			}
		
		// dimensionner la JPanel
		@Override
		public Dimension getPreferredSize() {
			return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
			}
		// dessiner tous les objects 
		@Override
		protected void paintComponent(Graphics g) {
			super.paintComponent(g);
			
			if (intrus.size() == 0 )
			{
				jeuArrete = true;
				label.setText("le jeu est terminé !");
				ImageIcon imageIcon=new ImageIcon("resources\\GameOver.jpg");
				Image image = imageIcon.getImage();
				g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
				/*for (Thread t : Thread.getAllStackTraces().keySet()) 
				{  if (t.getState()==Thread.State.RUNNABLE) 
				     t.interrupt(); 
				} */

				
				repaint();
			}
			else {
				for (int i = 0; i < configuration.nbre_colonne; i++) {
					for (int j = 0; j < configuration.nbre_ligne; j++) {
						g.setColor(Color.WHITE);
						g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
					}
					
				}
				for (int i = 0; i < intrus.size(); i++) {
					if(intrus.get(i).active=true)
					{
						if (i == n ) {
							
							g.setColor(Color.red);
							g.draw3DRect(x, y, i, i, raised);(intrus.get(i).x*cellWidth,intrus.get(i).y*cellHeight, cellWidth, cellHeight);
						}
						intrus.get(i).draw(g);
					}
				}
				for (int i = 0; i < robots.size(); i++) {
					if (i == n ) {
						
						g.setColor(Color.red);
						g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
					}
					robots.get(i).draw(g);
				}
				for (int i = 0; i < obstacles.size(); i++) {
					
					obstacles.get(i).draw(g);
				}
				for (int i = 0; i < sacs.size(); i++) {
					
					sacs.get(i).draw(g);
				}
				/**for (int i = 0; i < sorties.size(); i++) {
					
					sorties.get(i).draw(g);
				}**/
			}
		}
		
		
		
		int n = -1 ;
		@Override
		public void keyTyped(KeyEvent e) {
			
			
			if (joueurActif == 1 && jeuArrete ) {
				if (robots.size() == 1) {
					n = 0;
				}
				if (n != -1) {
					
					Robot robot =  robots.get(n);
					switch (e.getKeyChar()) {
					case 'd': robot.TournerD();break;
					case 'q':robot.TournerG();break;
					case 'z':robot.TournerH();break;
					case 's':robot.TournerB();break;
					default:
						throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
					}
					joueurActif = 2 ;
					jeuArrete = false;
					n=-1;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
				
				
			}
			
				
				else if (joueurActif == 2 && jeuArrete ) {
					if (intrus.size() == 1 ) {
						n=0;
					}
					if (n != -1) {
						Intru intru =  intrus.get(n);
						switch (e.getKeyChar()) {
						case 'd': intru.TournerD();break;
						case 'q':intru.TournerG();break;
						case 'z':intru.TournerH();break;
						case 's':intru.TournerB();break;
						}
						joueurActif = 1 ;
						jeuArrete=false;
						n=-1;
					}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
					
			}	
			
		}
		@Override
		public void keyPressed(KeyEvent e) {
			// TODO Auto-generated method stub
			
		}
		@Override
		public void keyReleased(KeyEvent e) {
			// TODO Auto-generated method stub
			
		}
		@Override
		public void mouseClicked(MouseEvent e) {
			jeuArrete = true;
			n=-1;
			if (jeuArrete && (intrus.size() != 1 || robots.size() != 1)) {
				int colonne = e.getX()/cellWidth ;
				int ligne = e.getY() / cellWidth ;
				Point point = new Point(ligne,colonne);
				//System.out.println(point);
				if (joueurActif == 1  ) {
					for (int i = 0; i < robots.size(); i++) {
						if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
							n=i;
						}
					}
					if (n == -1 ) {
						JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
					}
					
				}
				if (joueurActif == 2  ) {
					for (int i = 0; i < intrus.size(); i++) {
						if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
							n=i;
						}
					}
					if (n == -1 ) {
						JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
					}
				}
				
			}
			
			
		}
		@Override
		public void mousePressed(MouseEvent e) {
			// TODO Auto-generated method stub
			
		}
		@Override
		public void mouseReleased(MouseEvent e) {
			// TODO Auto-generated method stub
			
		}
		@Override
		public void mouseEntered(MouseEvent e) {
			// TODO Auto-generated method stub
			
		}
		@Override
		public void mouseExited(MouseEvent e) {
			// TODO Auto-generated method stub
			
		}
		
		
		
		//verifier avant de quitter

		@Override
		public void windowActivated(WindowEvent e) {
			// TODO Auto-generated method stub
			
		}

		@Override
		public void windowClosed(WindowEvent e) {
			// TODO Auto-generated method stub
			
		}

		@Override
		public void windowClosing(WindowEvent e) {
			// TODO Auto-generated method stub
			exit();
			
			}
	
		void exit() {
			
			int a= JOptionPane.showConfirmDialog(null, "Clicker sur \"oui \" pour quitter vers le menu principal", "Quit options", JOptionPane.YES_NO_OPTION);
			if (a==JOptionPane.YES_OPTION) {
				dispose();
				Menu window = new Menu();
				window.main(null);
				
			}
			
			
			
		}
		

		@Override
		public void windowDeactivated(WindowEvent e) {
			// TODO Auto-generated method stub
			
		}

		@Override
		public void windowDeiconified(WindowEvent e) {
			// TODO Auto-generated method stub
			
		}

		@Override
		public void windowIconified(WindowEvent e) {
			// TODO Auto-generated method stub
			
		}

		@Override
		public void windowOpened(WindowEvent e) {
			// TODO Auto-generated method stub
			
		}
		
	}
}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1015)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:811)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:678)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:670)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-09-17 08:08:24.144
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1015)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:811)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:678)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:670)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-09-17 08:08:24.148
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1015)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:811)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:678)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:670)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-17 08:08:28.035
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.GridBagLayout;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.event.WindowEvent;
import java.awt.event.WindowListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import java.awt.GridBagConstraints;
import java.awt.Insets;
import java.awt.Component;
import javax.swing.Box;

public class Jeu extends JFrame{
	JLabel label;
	JPanel panel = new JPanel();
	JLabel lblNewLabel = new JLabel("Time :");
	JLabel lblNewLabel_1 = new JLabel("Sacs restants :");
	JLabel lblNewLabel_2 = new JLabel("Intrus restants :");
	JLabel lblNewLabel_3 = new JLabel("Robots :");
	private Component verticalStrut;
	private final Component horizontalStrut = Box.createHorizontalStrut(20);
	private final Component horizontalStrut_1 = Box.createHorizontalStrut(20);
	public Jeu(ConfigurationModel configuration) {
		super("Jeu");
		setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);
		getContentPane().setLayout(new BorderLayout());
		 label = new JLabel("Hello");
		 label.setForeground(Color.red);
		label.setVisible(true);
		getContentPane().add(label,BorderLayout.SOUTH);
		getContentPane().add(new Map(configuration),BorderLayout.CENTER);
		getContentPane().add(panel, BorderLayout.NORTH);
		GridBagLayout gbl_panel = new GridBagLayout();
		gbl_panel.columnWidths = new int[]{52, 0, 0, 0, 0, 56, 0};
		gbl_panel.rowHeights = new int[]{0, 0, 0, 16, 0};
		gbl_panel.columnWeights = new double[]{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, Double.MIN_VALUE};
		gbl_panel.rowWeights = new double[]{0.0, 0.0, 0.0, 0.0, Double.MIN_VALUE};
		panel.setLayout(gbl_panel);
		
		verticalStrut = Box.createVerticalStrut(20);
		GridBagConstraints gbc_verticalStrut = new GridBagConstraints();
		gbc_verticalStrut.insets = new Insets(0, 0, 5, 5);
		gbc_verticalStrut.gridx = 0;
		gbc_verticalStrut.gridy = 0;
		panel.add(verticalStrut, gbc_verticalStrut);
		
		//JLabel lblNewLabel = new JLabel("Time :");
		GridBagConstraints gbc_lblNewLabel = new GridBagConstraints();
		gbc_lblNewLabel.insets = new Insets(0, 0, 5, 5);
		gbc_lblNewLabel.anchor = GridBagConstraints.NORTHWEST;
		gbc_lblNewLabel.gridx = 0;
		gbc_lblNewLabel.gridy = 1;
		panel.add(lblNewLabel, gbc_lblNewLabel);
		
		
		
		
		//lblNewLabel_1 = new JLabel("Sacs restants :");
		GridBagConstraints gbc_lblNewLabel_1 = new GridBagConstraints();
		gbc_lblNewLabel_1.insets = new Insets(0, 0, 5, 5);
		gbc_lblNewLabel_1.gridx = 0;
		gbc_lblNewLabel_1.gridy = 2;
		panel.add(lblNewLabel_1, gbc_lblNewLabel_1);
		
		GridBagConstraints gbc_horizontalStrut = new GridBagConstraints();
		gbc_horizontalStrut.insets = new Insets(0, 0, 5, 5);
		gbc_horizontalStrut.gridx = 1;
		gbc_horizontalStrut.gridy = 2;
		panel.add(horizontalStrut, gbc_horizontalStrut);
		
		//lblNewLabel_2 = new JLabel("nbre d'Intrus restants :");
		GridBagConstraints gbc_lblNewLabel_2 = new GridBagConstraints();
		gbc_lblNewLabel_2.insets = new Insets(0, 0, 5, 5);
		gbc_lblNewLabel_2.gridx = 2;
		gbc_lblNewLabel_2.gridy = 2;
		panel.add(lblNewLabel_2, gbc_lblNewLabel_2);
		
		GridBagConstraints gbc_horizontalStrut_1 = new GridBagConstraints();
		gbc_horizontalStrut_1.insets = new Insets(0, 0, 5, 5);
		gbc_horizontalStrut_1.gridx = 3;
		gbc_horizontalStrut_1.gridy = 2;
		panel.add(horizontalStrut_1, gbc_horizontalStrut_1);
		
		//lblNewLabel_3 = new JLabel("nbre de robots :");
		GridBagConstraints gbc_lblNewLabel_3 = new GridBagConstraints();
		gbc_lblNewLabel_3.insets = new Insets(0, 0, 5, 5);
		gbc_lblNewLabel_3.gridx = 4;
		gbc_lblNewLabel_3.gridy = 2;
		panel.add(lblNewLabel_3, gbc_lblNewLabel_3);
		pack();
		setLocationRelativeTo(null);
		setResizable(false);
		setVisible(true);
		
	}
	private class Map extends JPanel implements KeyListener,MouseListener,WindowListener {
		int width,height,cellWidth,cellHeight;
		private ConfigurationModel configuration ;
		private Vector<Robot> robots = new Vector<Robot>();
		private Vector<Intru> intrus = new Vector<Intru>();
		private Vector<Sac> sacs = new Vector<Sac>();
		private Vector<Obstacle> obstacles = new Vector<Obstacle>();
		private Vector<Sortie> sorties = new Vector<Sortie>();
		private int joueurActif ;
		private boolean jeuArrete;
		
		public Map(ConfigurationModel configuration) {
			this.configuration = configuration ; 
			joueurActif = 1;
			jeuArrete = true;
			width=getWidth();
			height=getHeight();
			cellWidth =40;
			cellHeight =40;
			prepare();
			changerTour();
			calculertemps();
			lblNewLabel_1.setText("Sacs restants: "+ sacs.size());
			lblNewLabel_2.setText("Intrus restants: "+intrus.size());
			lblNewLabel_3.setText("Robots: "+ robots.size());
			//afficher();
			this.addKeyListener(this);
			this.addMouseListener(this);
			addWindowListener(this);
	        this.setFocusable(true);
	        this.requestFocusInWindow();
	        
	        
	         
		}
		
		
		
		
	/*	//Afficher le nombre de robots, intrus et sacs
		private void afficher() {

			Timer myTimer2 = new Timer();
			TimerTask task2= new TimerTask() {
				int s=0;
				@Override
				public void run() {
					s++;
					int x1=sacs.size();
					int x2=intrus.size();
					int x3=robots.size();
					lblNewLabel_1.setText("Sacs restants: "+ x1);
					lblNewLabel_2.setText("Intrus restants: "+ x2);
					lblNewLabel_3.setText("Robots: "+ x3);
					//System.out.println(sacs.size());
				}
			};
			myTimer2.scheduleAtFixedRate(task2, 1000, 1000);
		}
		*/
		
		//Calculer le temps passé
		private void calculertemps() {
			//System.out.println("temps");
			
			Timer myTimer1 = new Timer();
			TimerTask task1= new TimerTask() {
				int SecondesPassed1 = 0;
				int min=0,heu=0;
				@Override
				public void run() {
					if (intrus.size()!=0) {
						SecondesPassed1 ++;  
					}
					
					String ch ="";
					
					if (SecondesPassed1 ==60) {
						min+=1;
						SecondesPassed1=0;
					}
					if (min==60) {
						heu+=1;
						min=0;
					}
					//System.out.println("Time: "+ SecondesPassed1);
					
					if (SecondesPassed1 / 10 == 0 && min/ 10==0 ) {
						ch="0"+heu+" : "+"0"+min+" : "+"0"+SecondesPassed1;
					}
					if (SecondesPassed1 / 10 != 0 && min/ 10==0) {
						ch="0"+heu+" : "+"0"+min+" : "+SecondesPassed1;
					}
					if (SecondesPassed1 / 10 == 0 && min/ 10!=0) {
						ch="0"+heu+" : "+min+" : "+"0"+SecondesPassed1;
					}
					
					if (SecondesPassed1 / 10 != 0 && min/ 10!=0) {
						ch="0"+heu+" : "+min+" : "+SecondesPassed1; 
					}
					lblNewLabel.setText("Time: " + ch );
					
					
				}
			};
			
			
				myTimer1.scheduleAtFixedRate(task1, 1000, 1000);
			
		
			
			
			
		}
		
		
		
		// Changer automatiquement le tour chaque 5 secondes
		private void changerTour()
		{
			
			Timer timer = new Timer();
			TimerTask  timerTask = new TimerTask() {
				int secondPassed = 0 ;
				@Override
				public void run() {
					secondPassed ++ ; 
					if (!jeuArrete) {
						//System.out.println("Il reste "+(5-secondPassed)+" secondes pourque le joueur " + joueurActif + " joue son coup !");
						label.setText("Il reste "+(5-secondPassed)+" secondes pourque le joueur " + joueurActif + " joue son coup !  .. Cliquer pour prendre le coup ! ..");
						if (secondPassed == 5 && joueurActif == 1) {
							secondPassed =0;
							joueurActif =2;
						}
						if (secondPassed == 5 && joueurActif == 2) {
							secondPassed =0;
							joueurActif =1;
						}
					}
					if (jeuArrete) {
						secondPassed = 0 ;
						label.setText("Joueur "+joueurActif+" en train de jouer !  .. Choisir une direction .. ");
					}
					
				}
			};
			timer.scheduleAtFixedRate(timerTask, 1000, 1000);
		}
		// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
		private void prepare()
		
		{
			for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
				int x= configuration.Emplac_Intrus.get(i).x;
				int y= configuration.Emplac_Intrus.get(i).y;
				Intru intru = new Intru(y, x, 1000);
				intrus.add(intru);
				MoveIntrus moveIntrus =new MoveIntrus(intru);
				moveIntrus.start();
			}
			for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
				int x= configuration.Emplac_Robots.get(i).x;
				int y= configuration.Emplac_Robots.get(i).y;
				Robot robot = new Robot(y,x, 500);
				robots.add(robot);
				MoveRobots moveRobots = new MoveRobots(robot);
				moveRobots.start();
			}
			for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
				int x= configuration.Emplac_Obstacle.get(i).x;
				int y= configuration.Emplac_Obstacle.get(i).y;
				Obstacle obstacle = new Obstacle(y, x);
				obstacles.add(obstacle);
			}
			for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
				int x= configuration.Emplac_Sac.get(i).x;
				int y= configuration.Emplac_Sac.get(i).y;
				Sac sac = new Sac(y, x);
				sacs.add(sac);
			}
			for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
				int x= configuration.Emplac_Sortie.get(i).x;
				int y= configuration.Emplac_Sortie.get(i).y;
				Sortie sortie = new Sortie(y, x);
				sorties.add(sortie);
			}
		}
		// verifier si p1 est adjacent à p2
		private boolean EstAdjacent(Point p1,Point p2)
		{
			if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
			((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
			return true;
			else return false;
		}
		private boolean MovementValide(Point p , char direction) {
			Point pa = null;
			switch (direction) {
			case 'D': pa = new Point(p.x+1,p.y);break;
			case 'G': pa = new Point(p.x-1,p.y);break;
			case 'B': pa = new Point(p.x,p.y+1);break;
			case 'H': pa = new Point(p.x,p.y-1);break;
			default:
				break;
			}
			if (pa != null) {
				for (int i = 0; i < obstacles.size(); i++) {
					if (obstacles.get(i).x == pa.x && obstacles.get(i).y== pa.y ) {
						return false;
					}
				}
				for (int i = 0; i < sacs.size(); i++) {
					if (sacs.get(i).x == pa.x && sacs.get(i).y== pa.y ) {
						return false;
					}
				}
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == pa.x && intrus.get(i).y== pa.y ) {
						return false;
					}
				}
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == pa.x && robots.get(i).y== pa.y ) {
						return false;
					}
				}
				for (int i = 0; i < sorties.size(); i++) {
					if (sorties.get(i).x == pa.x && sorties.get(i).y== pa.y ) {
						return false;
					}
				}
			}
			
			return true;
		}

		
		public class MoveIntrus extends Thread 
		{
			Intru intru ;
			MoveIntrus(Intru intru)
			{
				this.intru=intru;
			}
			@Override
			public void run() {
			//	int pas =0;
				while(true)
				{	//  un intru prend un sac 
					if (jeuArrete) {
					//	pas = 0 ;
						try {
							sleep(1000);
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
					}
					else 
					{
						// un intru prend un sac
						for (int i = 0; i < sacs.size(); i++) {
							if (EstAdjacent(intru, sacs.get(i))) {
								if (intru.PrendSac(sacs.get(i))) {
									sacs.remove(sacs.get(i));
									System.out.println(sacs.size());
									lblNewLabel_1.setText("Sacs restants: "+ sacs.size());
									
								}
																}
						} 
						//un robot attrape un intru 
						for (int i = 0; i < robots.size(); i++) {
							
							if (EstAdjacent(intru, robots.get(i)) )
								{
									for (int j = 0; j < intru.sacs.size(); j++) {
										
										sacs.add(intru.sacs.get(j));
										lblNewLabel_1.setText("Sacs restants: "+ sacs.size());
										
									}
									intru.retournerSac();
									intrus.remove(intru);
									lblNewLabel_2.setText("Intrus restants: "+intrus.size());
								}
						}
						// un intru sort à partir d'une sortie 
						for (int i = 0; i < sorties.size(); i++) {
							
							if (EstAdjacent(intru, sorties.get(i)) )
								{
									intrus.remove(intru);
									lblNewLabel_2.setText("Intrus restants: "+intrus.size());
								}
						}
						
						// le mouvement d'un intru d'une case à une autre
						if (intru.active==false) interrupt();
						
							
							if (MovementValide(intru, intru.direction))
							{
								intru.move();
								repaint();
								try {
									sleep(1000);
								} catch (InterruptedException e) {
									// TODO Auto-generated catch block
									e.printStackTrace();
								}
								
							}
						
					}
				
						
				}
							
				}
							
			}
		class MoveRobots extends Thread 
		{
			Robot robot;
			public MoveRobots(Robot robot) {
				this.robot = robot ;
			}

			@Override
			public void run() {
				// pas = 0;
				while(true)
				{
					if (jeuArrete) {
						//pas =0;
						try {
							sleep(1000);
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
					}
					else {
						
						// le mouvement d'un robot d'une case à une autre
						if (MovementValide(robot, robot.direction))
						{
							robot.move();
							repaint();
							
							try {
								//pas++;
								sleep(500);
								//if (pas==3) {
									//jeuArrete = true;
								//}
								
								
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						
					}
					
				}
							
				}
					
			}
		
		// dimensionner la JPanel
		@Override
		public Dimension getPreferredSize() {
			return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
			}
		// dessiner tous les objects 
		@Override
		protected void paintComponent(Graphics g) {
			super.paintComponent(g);
			
			if (intrus.size() == 0 )
			{
				jeuArrete = true;
				label.setText("le jeu est terminé !");
				ImageIcon imageIcon=new ImageIcon("resources\\GameOver.jpg");
				Image image = imageIcon.getImage();
				g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
				/*for (Thread t : Thread.getAllStackTraces().keySet()) 
				{  if (t.getState()==Thread.State.RUNNABLE) 
				     t.interrupt(); 
				} */

				
				repaint();
			}
			else {
				for (int i = 0; i < configuration.nbre_colonne; i++) {
					for (int j = 0; j < configuration.nbre_ligne; j++) {
						g.setColor(Color.WHITE);
						g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
					}
					
				}
				for (int i = 0; i < intrus.size(); i++) {
					if(intrus.get(i).active=true)
					{
						if (i == n ) {
							
							g.setColor(Color.red);
							g.draw3DRect(x, y, i, i, raised);(intrus.get(i).x*cellWidth,intrus.get(i).y*cellHeight, cellWidth, cellHeight,true);
						}
						intrus.get(i).draw(g);
					}
				}
				for (int i = 0; i < robots.size(); i++) {
					if (i == n ) {
						
						g.setColor(Color.red);
						g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
					}
					robots.get(i).draw(g);
				}
				for (int i = 0; i < obstacles.size(); i++) {
					
					obstacles.get(i).draw(g);
				}
				for (int i = 0; i < sacs.size(); i++) {
					
					sacs.get(i).draw(g);
				}
				/**for (int i = 0; i < sorties.size(); i++) {
					
					sorties.get(i).draw(g);
				}**/
			}
		}
		
		
		
		int n = -1 ;
		@Override
		public void keyTyped(KeyEvent e) {
			
			
			if (joueurActif == 1 && jeuArrete ) {
				if (robots.size() == 1) {
					n = 0;
				}
				if (n != -1) {
					
					Robot robot =  robots.get(n);
					switch (e.getKeyChar()) {
					case 'd': robot.TournerD();break;
					case 'q':robot.TournerG();break;
					case 'z':robot.TournerH();break;
					case 's':robot.TournerB();break;
					default:
						throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
					}
					joueurActif = 2 ;
					jeuArrete = false;
					n=-1;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
				
				
			}
			
				
				else if (joueurActif == 2 && jeuArrete ) {
					if (intrus.size() == 1 ) {
						n=0;
					}
					if (n != -1) {
						Intru intru =  intrus.get(n);
						switch (e.getKeyChar()) {
						case 'd': intru.TournerD();break;
						case 'q':intru.TournerG();break;
						case 'z':intru.TournerH();break;
						case 's':intru.TournerB();break;
						}
						joueurActif = 1 ;
						jeuArrete=false;
						n=-1;
					}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
					
			}	
			
		}
		@Override
		public void keyPressed(KeyEvent e) {
			// TODO Auto-generated method stub
			
		}
		@Override
		public void keyReleased(KeyEvent e) {
			// TODO Auto-generated method stub
			
		}
		@Override
		public void mouseClicked(MouseEvent e) {
			jeuArrete = true;
			n=-1;
			if (jeuArrete && (intrus.size() != 1 || robots.size() != 1)) {
				int colonne = e.getX()/cellWidth ;
				int ligne = e.getY() / cellWidth ;
				Point point = new Point(ligne,colonne);
				//System.out.println(point);
				if (joueurActif == 1  ) {
					for (int i = 0; i < robots.size(); i++) {
						if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
							n=i;
						}
					}
					if (n == -1 ) {
						JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
					}
					
				}
				if (joueurActif == 2  ) {
					for (int i = 0; i < intrus.size(); i++) {
						if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
							n=i;
						}
					}
					if (n == -1 ) {
						JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
					}
				}
				
			}
			
			
		}
		@Override
		public void mousePressed(MouseEvent e) {
			// TODO Auto-generated method stub
			
		}
		@Override
		public void mouseReleased(MouseEvent e) {
			// TODO Auto-generated method stub
			
		}
		@Override
		public void mouseEntered(MouseEvent e) {
			// TODO Auto-generated method stub
			
		}
		@Override
		public void mouseExited(MouseEvent e) {
			// TODO Auto-generated method stub
			
		}
		
		
		
		//verifier avant de quitter

		@Override
		public void windowActivated(WindowEvent e) {
			// TODO Auto-generated method stub
			
		}

		@Override
		public void windowClosed(WindowEvent e) {
			// TODO Auto-generated method stub
			
		}

		@Override
		public void windowClosing(WindowEvent e) {
			// TODO Auto-generated method stub
			exit();
			
			}
	
		void exit() {
			
			int a= JOptionPane.showConfirmDialog(null, "Clicker sur \"oui \" pour quitter vers le menu principal", "Quit options", JOptionPane.YES_NO_OPTION);
			if (a==JOptionPane.YES_OPTION) {
				dispose();
				Menu window = new Menu();
				window.main(null);
				
			}
			
			
			
		}
		

		@Override
		public void windowDeactivated(WindowEvent e) {
			// TODO Auto-generated method stub
			
		}

		@Override
		public void windowDeiconified(WindowEvent e) {
			// TODO Auto-generated method stub
			
		}

		@Override
		public void windowIconified(WindowEvent e) {
			// TODO Auto-generated method stub
			
		}

		@Override
		public void windowOpened(WindowEvent e) {
			// TODO Auto-generated method stub
			
		}
		
	}
}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2020-09-17 08:08:28.040
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2020-09-17 08:08:28.045
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-17 08:08:28.536
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.GridBagLayout;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.event.WindowEvent;
import java.awt.event.WindowListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import java.awt.GridBagConstraints;
import java.awt.Insets;
import java.awt.Component;
import javax.swing.Box;

public class Jeu extends JFrame{
	JLabel label;
	JPanel panel = new JPanel();
	JLabel lblNewLabel = new JLabel("Time :");
	JLabel lblNewLabel_1 = new JLabel("Sacs restants :");
	JLabel lblNewLabel_2 = new JLabel("Intrus restants :");
	JLabel lblNewLabel_3 = new JLabel("Robots :");
	private Component verticalStrut;
	private final Component horizontalStrut = Box.createHorizontalStrut(20);
	private final Component horizontalStrut_1 = Box.createHorizontalStrut(20);
	public Jeu(ConfigurationModel configuration) {
		super("Jeu");
		setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);
		getContentPane().setLayout(new BorderLayout());
		 label = new JLabel("Hello");
		 label.setForeground(Color.red);
		label.setVisible(true);
		getContentPane().add(label,BorderLayout.SOUTH);
		getContentPane().add(new Map(configuration),BorderLayout.CENTER);
		getContentPane().add(panel, BorderLayout.NORTH);
		GridBagLayout gbl_panel = new GridBagLayout();
		gbl_panel.columnWidths = new int[]{52, 0, 0, 0, 0, 56, 0};
		gbl_panel.rowHeights = new int[]{0, 0, 0, 16, 0};
		gbl_panel.columnWeights = new double[]{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, Double.MIN_VALUE};
		gbl_panel.rowWeights = new double[]{0.0, 0.0, 0.0, 0.0, Double.MIN_VALUE};
		panel.setLayout(gbl_panel);
		
		verticalStrut = Box.createVerticalStrut(20);
		GridBagConstraints gbc_verticalStrut = new GridBagConstraints();
		gbc_verticalStrut.insets = new Insets(0, 0, 5, 5);
		gbc_verticalStrut.gridx = 0;
		gbc_verticalStrut.gridy = 0;
		panel.add(verticalStrut, gbc_verticalStrut);
		
		//JLabel lblNewLabel = new JLabel("Time :");
		GridBagConstraints gbc_lblNewLabel = new GridBagConstraints();
		gbc_lblNewLabel.insets = new Insets(0, 0, 5, 5);
		gbc_lblNewLabel.anchor = GridBagConstraints.NORTHWEST;
		gbc_lblNewLabel.gridx = 0;
		gbc_lblNewLabel.gridy = 1;
		panel.add(lblNewLabel, gbc_lblNewLabel);
		
		
		
		
		//lblNewLabel_1 = new JLabel("Sacs restants :");
		GridBagConstraints gbc_lblNewLabel_1 = new GridBagConstraints();
		gbc_lblNewLabel_1.insets = new Insets(0, 0, 5, 5);
		gbc_lblNewLabel_1.gridx = 0;
		gbc_lblNewLabel_1.gridy = 2;
		panel.add(lblNewLabel_1, gbc_lblNewLabel_1);
		
		GridBagConstraints gbc_horizontalStrut = new GridBagConstraints();
		gbc_horizontalStrut.insets = new Insets(0, 0, 5, 5);
		gbc_horizontalStrut.gridx = 1;
		gbc_horizontalStrut.gridy = 2;
		panel.add(horizontalStrut, gbc_horizontalStrut);
		
		//lblNewLabel_2 = new JLabel("nbre d'Intrus restants :");
		GridBagConstraints gbc_lblNewLabel_2 = new GridBagConstraints();
		gbc_lblNewLabel_2.insets = new Insets(0, 0, 5, 5);
		gbc_lblNewLabel_2.gridx = 2;
		gbc_lblNewLabel_2.gridy = 2;
		panel.add(lblNewLabel_2, gbc_lblNewLabel_2);
		
		GridBagConstraints gbc_horizontalStrut_1 = new GridBagConstraints();
		gbc_horizontalStrut_1.insets = new Insets(0, 0, 5, 5);
		gbc_horizontalStrut_1.gridx = 3;
		gbc_horizontalStrut_1.gridy = 2;
		panel.add(horizontalStrut_1, gbc_horizontalStrut_1);
		
		//lblNewLabel_3 = new JLabel("nbre de robots :");
		GridBagConstraints gbc_lblNewLabel_3 = new GridBagConstraints();
		gbc_lblNewLabel_3.insets = new Insets(0, 0, 5, 5);
		gbc_lblNewLabel_3.gridx = 4;
		gbc_lblNewLabel_3.gridy = 2;
		panel.add(lblNewLabel_3, gbc_lblNewLabel_3);
		pack();
		setLocationRelativeTo(null);
		setResizable(false);
		setVisible(true);
		
	}
	private class Map extends JPanel implements KeyListener,MouseListener,WindowListener {
		int width,height,cellWidth,cellHeight;
		private ConfigurationModel configuration ;
		private Vector<Robot> robots = new Vector<Robot>();
		private Vector<Intru> intrus = new Vector<Intru>();
		private Vector<Sac> sacs = new Vector<Sac>();
		private Vector<Obstacle> obstacles = new Vector<Obstacle>();
		private Vector<Sortie> sorties = new Vector<Sortie>();
		private int joueurActif ;
		private boolean jeuArrete;
		
		public Map(ConfigurationModel configuration) {
			this.configuration = configuration ; 
			joueurActif = 1;
			jeuArrete = true;
			width=getWidth();
			height=getHeight();
			cellWidth =40;
			cellHeight =40;
			prepare();
			changerTour();
			calculertemps();
			lblNewLabel_1.setText("Sacs restants: "+ sacs.size());
			lblNewLabel_2.setText("Intrus restants: "+intrus.size());
			lblNewLabel_3.setText("Robots: "+ robots.size());
			//afficher();
			this.addKeyListener(this);
			this.addMouseListener(this);
			addWindowListener(this);
	        this.setFocusable(true);
	        this.requestFocusInWindow();
	        
	        
	         
		}
		
		
		
		
	/*	//Afficher le nombre de robots, intrus et sacs
		private void afficher() {

			Timer myTimer2 = new Timer();
			TimerTask task2= new TimerTask() {
				int s=0;
				@Override
				public void run() {
					s++;
					int x1=sacs.size();
					int x2=intrus.size();
					int x3=robots.size();
					lblNewLabel_1.setText("Sacs restants: "+ x1);
					lblNewLabel_2.setText("Intrus restants: "+ x2);
					lblNewLabel_3.setText("Robots: "+ x3);
					//System.out.println(sacs.size());
				}
			};
			myTimer2.scheduleAtFixedRate(task2, 1000, 1000);
		}
		*/
		
		//Calculer le temps passé
		private void calculertemps() {
			//System.out.println("temps");
			
			Timer myTimer1 = new Timer();
			TimerTask task1= new TimerTask() {
				int SecondesPassed1 = 0;
				int min=0,heu=0;
				@Override
				public void run() {
					if (intrus.size()!=0) {
						SecondesPassed1 ++;  
					}
					
					String ch ="";
					
					if (SecondesPassed1 ==60) {
						min+=1;
						SecondesPassed1=0;
					}
					if (min==60) {
						heu+=1;
						min=0;
					}
					//System.out.println("Time: "+ SecondesPassed1);
					
					if (SecondesPassed1 / 10 == 0 && min/ 10==0 ) {
						ch="0"+heu+" : "+"0"+min+" : "+"0"+SecondesPassed1;
					}
					if (SecondesPassed1 / 10 != 0 && min/ 10==0) {
						ch="0"+heu+" : "+"0"+min+" : "+SecondesPassed1;
					}
					if (SecondesPassed1 / 10 == 0 && min/ 10!=0) {
						ch="0"+heu+" : "+min+" : "+"0"+SecondesPassed1;
					}
					
					if (SecondesPassed1 / 10 != 0 && min/ 10!=0) {
						ch="0"+heu+" : "+min+" : "+SecondesPassed1; 
					}
					lblNewLabel.setText("Time: " + ch );
					
					
				}
			};
			
			
				myTimer1.scheduleAtFixedRate(task1, 1000, 1000);
			
		
			
			
			
		}
		
		
		
		// Changer automatiquement le tour chaque 5 secondes
		private void changerTour()
		{
			
			Timer timer = new Timer();
			TimerTask  timerTask = new TimerTask() {
				int secondPassed = 0 ;
				@Override
				public void run() {
					secondPassed ++ ; 
					if (!jeuArrete) {
						//System.out.println("Il reste "+(5-secondPassed)+" secondes pourque le joueur " + joueurActif + " joue son coup !");
						label.setText("Il reste "+(5-secondPassed)+" secondes pourque le joueur " + joueurActif + " joue son coup !  .. Cliquer pour prendre le coup ! ..");
						if (secondPassed == 5 && joueurActif == 1) {
							secondPassed =0;
							joueurActif =2;
						}
						if (secondPassed == 5 && joueurActif == 2) {
							secondPassed =0;
							joueurActif =1;
						}
					}
					if (jeuArrete) {
						secondPassed = 0 ;
						label.setText("Joueur "+joueurActif+" en train de jouer !  .. Choisir une direction .. ");
					}
					
				}
			};
			timer.scheduleAtFixedRate(timerTask, 1000, 1000);
		}
		// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
		private void prepare()
		
		{
			for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
				int x= configuration.Emplac_Intrus.get(i).x;
				int y= configuration.Emplac_Intrus.get(i).y;
				Intru intru = new Intru(y, x, 1000);
				intrus.add(intru);
				MoveIntrus moveIntrus =new MoveIntrus(intru);
				moveIntrus.start();
			}
			for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
				int x= configuration.Emplac_Robots.get(i).x;
				int y= configuration.Emplac_Robots.get(i).y;
				Robot robot = new Robot(y,x, 500);
				robots.add(robot);
				MoveRobots moveRobots = new MoveRobots(robot);
				moveRobots.start();
			}
			for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
				int x= configuration.Emplac_Obstacle.get(i).x;
				int y= configuration.Emplac_Obstacle.get(i).y;
				Obstacle obstacle = new Obstacle(y, x);
				obstacles.add(obstacle);
			}
			for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
				int x= configuration.Emplac_Sac.get(i).x;
				int y= configuration.Emplac_Sac.get(i).y;
				Sac sac = new Sac(y, x);
				sacs.add(sac);
			}
			for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
				int x= configuration.Emplac_Sortie.get(i).x;
				int y= configuration.Emplac_Sortie.get(i).y;
				Sortie sortie = new Sortie(y, x);
				sorties.add(sortie);
			}
		}
		// verifier si p1 est adjacent à p2
		private boolean EstAdjacent(Point p1,Point p2)
		{
			if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
			((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
			return true;
			else return false;
		}
		private boolean MovementValide(Point p , char direction) {
			Point pa = null;
			switch (direction) {
			case 'D': pa = new Point(p.x+1,p.y);break;
			case 'G': pa = new Point(p.x-1,p.y);break;
			case 'B': pa = new Point(p.x,p.y+1);break;
			case 'H': pa = new Point(p.x,p.y-1);break;
			default:
				break;
			}
			if (pa != null) {
				for (int i = 0; i < obstacles.size(); i++) {
					if (obstacles.get(i).x == pa.x && obstacles.get(i).y== pa.y ) {
						return false;
					}
				}
				for (int i = 0; i < sacs.size(); i++) {
					if (sacs.get(i).x == pa.x && sacs.get(i).y== pa.y ) {
						return false;
					}
				}
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == pa.x && intrus.get(i).y== pa.y ) {
						return false;
					}
				}
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == pa.x && robots.get(i).y== pa.y ) {
						return false;
					}
				}
				for (int i = 0; i < sorties.size(); i++) {
					if (sorties.get(i).x == pa.x && sorties.get(i).y== pa.y ) {
						return false;
					}
				}
			}
			
			return true;
		}

		
		public class MoveIntrus extends Thread 
		{
			Intru intru ;
			MoveIntrus(Intru intru)
			{
				this.intru=intru;
			}
			@Override
			public void run() {
			//	int pas =0;
				while(true)
				{	//  un intru prend un sac 
					if (jeuArrete) {
					//	pas = 0 ;
						try {
							sleep(1000);
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
					}
					else 
					{
						// un intru prend un sac
						for (int i = 0; i < sacs.size(); i++) {
							if (EstAdjacent(intru, sacs.get(i))) {
								if (intru.PrendSac(sacs.get(i))) {
									sacs.remove(sacs.get(i));
									System.out.println(sacs.size());
									lblNewLabel_1.setText("Sacs restants: "+ sacs.size());
									
								}
																}
						} 
						//un robot attrape un intru 
						for (int i = 0; i < robots.size(); i++) {
							
							if (EstAdjacent(intru, robots.get(i)) )
								{
									for (int j = 0; j < intru.sacs.size(); j++) {
										
										sacs.add(intru.sacs.get(j));
										lblNewLabel_1.setText("Sacs restants: "+ sacs.size());
										
									}
									intru.retournerSac();
									intrus.remove(intru);
									lblNewLabel_2.setText("Intrus restants: "+intrus.size());
								}
						}
						// un intru sort à partir d'une sortie 
						for (int i = 0; i < sorties.size(); i++) {
							
							if (EstAdjacent(intru, sorties.get(i)) )
								{
									intrus.remove(intru);
									lblNewLabel_2.setText("Intrus restants: "+intrus.size());
								}
						}
						
						// le mouvement d'un intru d'une case à une autre
						if (intru.active==false) interrupt();
						
							
							if (MovementValide(intru, intru.direction))
							{
								intru.move();
								repaint();
								try {
									sleep(1000);
								} catch (InterruptedException e) {
									// TODO Auto-generated catch block
									e.printStackTrace();
								}
								
							}
						
					}
				
						
				}
							
				}
							
			}
		class MoveRobots extends Thread 
		{
			Robot robot;
			public MoveRobots(Robot robot) {
				this.robot = robot ;
			}

			@Override
			public void run() {
				// pas = 0;
				while(true)
				{
					if (jeuArrete) {
						//pas =0;
						try {
							sleep(1000);
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
					}
					else {
						
						// le mouvement d'un robot d'une case à une autre
						if (MovementValide(robot, robot.direction))
						{
							robot.move();
							repaint();
							
							try {
								//pas++;
								sleep(500);
								//if (pas==3) {
									//jeuArrete = true;
								//}
								
								
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						
					}
					
				}
							
				}
					
			}
		
		// dimensionner la JPanel
		@Override
		public Dimension getPreferredSize() {
			return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
			}
		// dessiner tous les objects 
		@Override
		protected void paintComponent(Graphics g) {
			super.paintComponent(g);
			
			if (intrus.size() == 0 )
			{
				jeuArrete = true;
				label.setText("le jeu est terminé !");
				ImageIcon imageIcon=new ImageIcon("resources\\GameOver.jpg");
				Image image = imageIcon.getImage();
				g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
				/*for (Thread t : Thread.getAllStackTraces().keySet()) 
				{  if (t.getState()==Thread.State.RUNNABLE) 
				     t.interrupt(); 
				} */

				
				repaint();
			}
			else {
				for (int i = 0; i < configuration.nbre_colonne; i++) {
					for (int j = 0; j < configuration.nbre_ligne; j++) {
						g.setColor(Color.WHITE);
						g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
					}
					
				}
				for (int i = 0; i < intrus.size(); i++) {
					if(intrus.get(i).active=true)
					{
						if (i == n ) {
							
							g.setColor(Color.red);
							g.draw3DRect(x, y, i, i, raised);(intrus.get(i).x*cellWidth,intrus.get(i).y*cellHeight, cellWidth, cellHeight,true);
						}
						intrus.get(i).draw(g);
					}
				}
				for (int i = 0; i < robots.size(); i++) {
					if (i == n ) {
						
						g.setColor(Color.red);
						g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
					}
					robots.get(i).draw(g);
				}
				for (int i = 0; i < obstacles.size(); i++) {
					
					obstacles.get(i).draw(g);
				}
				for (int i = 0; i < sacs.size(); i++) {
					
					sacs.get(i).draw(g);
				}
				/**for (int i = 0; i < sorties.size(); i++) {
					
					sorties.get(i).draw(g);
				}**/
			}
		}
		
		
		
		int n = -1 ;
		@Override
		public void keyTyped(KeyEvent e) {
			
			
			if (joueurActif == 1 && jeuArrete ) {
				if (robots.size() == 1) {
					n = 0;
				}
				if (n != -1) {
					
					Robot robot =  robots.get(n);
					switch (e.getKeyChar()) {
					case 'd': robot.TournerD();break;
					case 'q':robot.TournerG();break;
					case 'z':robot.TournerH();break;
					case 's':robot.TournerB();break;
					default:
						throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
					}
					joueurActif = 2 ;
					jeuArrete = false;
					n=-1;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
				
				
			}
			
				
				else if (joueurActif == 2 && jeuArrete ) {
					if (intrus.size() == 1 ) {
						n=0;
					}
					if (n != -1) {
						Intru intru =  intrus.get(n);
						switch (e.getKeyChar()) {
						case 'd': intru.TournerD();break;
						case 'q':intru.TournerG();break;
						case 'z':intru.TournerH();break;
						case 's':intru.TournerB();break;
						}
						joueurActif = 1 ;
						jeuArrete=false;
						n=-1;
					}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
					
			}	
			
		}
		@Override
		public void keyPressed(KeyEvent e) {
			// TODO Auto-generated method stub
			
		}
		@Override
		public void keyReleased(KeyEvent e) {
			// TODO Auto-generated method stub
			
		}
		@Override
		public void mouseClicked(MouseEvent e) {
			jeuArrete = true;
			n=-1;
			if (jeuArrete && (intrus.size() != 1 || robots.size() != 1)) {
				int colonne = e.getX()/cellWidth ;
				int ligne = e.getY() / cellWidth ;
				Point point = new Point(ligne,colonne);
				//System.out.println(point);
				if (joueurActif == 1  ) {
					for (int i = 0; i < robots.size(); i++) {
						if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
							n=i;
						}
					}
					if (n == -1 ) {
						JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
					}
					
				}
				if (joueurActif == 2  ) {
					for (int i = 0; i < intrus.size(); i++) {
						if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
							n=i;
						}
					}
					if (n == -1 ) {
						JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
					}
				}
				
			}
			
			
		}
		@Override
		public void mousePressed(MouseEvent e) {
			// TODO Auto-generated method stub
			
		}
		@Override
		public void mouseReleased(MouseEvent e) {
			// TODO Auto-generated method stub
			
		}
		@Override
		public void mouseEntered(MouseEvent e) {
			// TODO Auto-generated method stub
			
		}
		@Override
		public void mouseExited(MouseEvent e) {
			// TODO Auto-generated method stub
			
		}
		
		
		
		//verifier avant de quitter

		@Override
		public void windowActivated(WindowEvent e) {
			// TODO Auto-generated method stub
			
		}

		@Override
		public void windowClosed(WindowEvent e) {
			// TODO Auto-generated method stub
			
		}

		@Override
		public void windowClosing(WindowEvent e) {
			// TODO Auto-generated method stub
			exit();
			
			}
	
		void exit() {
			
			int a= JOptionPane.showConfirmDialog(null, "Clicker sur \"oui \" pour quitter vers le menu principal", "Quit options", JOptionPane.YES_NO_OPTION);
			if (a==JOptionPane.YES_OPTION) {
				dispose();
				Menu window = new Menu();
				window.main(null);
				
			}
			
			
			
		}
		

		@Override
		public void windowDeactivated(WindowEvent e) {
			// TODO Auto-generated method stub
			
		}

		@Override
		public void windowDeiconified(WindowEvent e) {
			// TODO Auto-generated method stub
			
		}

		@Override
		public void windowIconified(WindowEvent e) {
			// TODO Auto-generated method stub
			
		}

		@Override
		public void windowOpened(WindowEvent e) {
			// TODO Auto-generated method stub
			
		}
		
	}
}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-09-17 08:08:28.543
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-09-17 08:08:28.547
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-17 08:08:31.968
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.GridBagLayout;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.event.WindowEvent;
import java.awt.event.WindowListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import java.awt.GridBagConstraints;
import java.awt.Insets;
import java.awt.Component;
import javax.swing.Box;

public class Jeu extends JFrame{
	JLabel label;
	JPanel panel = new JPanel();
	JLabel lblNewLabel = new JLabel("Time :");
	JLabel lblNewLabel_1 = new JLabel("Sacs restants :");
	JLabel lblNewLabel_2 = new JLabel("Intrus restants :");
	JLabel lblNewLabel_3 = new JLabel("Robots :");
	private Component verticalStrut;
	private final Component horizontalStrut = Box.createHorizontalStrut(20);
	private final Component horizontalStrut_1 = Box.createHorizontalStrut(20);
	public Jeu(ConfigurationModel configuration) {
		super("Jeu");
		setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);
		getContentPane().setLayout(new BorderLayout());
		 label = new JLabel("Hello");
		 label.setForeground(Color.red);
		label.setVisible(true);
		getContentPane().add(label,BorderLayout.SOUTH);
		getContentPane().add(new Map(configuration),BorderLayout.CENTER);
		getContentPane().add(panel, BorderLayout.NORTH);
		GridBagLayout gbl_panel = new GridBagLayout();
		gbl_panel.columnWidths = new int[]{52, 0, 0, 0, 0, 56, 0};
		gbl_panel.rowHeights = new int[]{0, 0, 0, 16, 0};
		gbl_panel.columnWeights = new double[]{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, Double.MIN_VALUE};
		gbl_panel.rowWeights = new double[]{0.0, 0.0, 0.0, 0.0, Double.MIN_VALUE};
		panel.setLayout(gbl_panel);
		
		verticalStrut = Box.createVerticalStrut(20);
		GridBagConstraints gbc_verticalStrut = new GridBagConstraints();
		gbc_verticalStrut.insets = new Insets(0, 0, 5, 5);
		gbc_verticalStrut.gridx = 0;
		gbc_verticalStrut.gridy = 0;
		panel.add(verticalStrut, gbc_verticalStrut);
		
		//JLabel lblNewLabel = new JLabel("Time :");
		GridBagConstraints gbc_lblNewLabel = new GridBagConstraints();
		gbc_lblNewLabel.insets = new Insets(0, 0, 5, 5);
		gbc_lblNewLabel.anchor = GridBagConstraints.NORTHWEST;
		gbc_lblNewLabel.gridx = 0;
		gbc_lblNewLabel.gridy = 1;
		panel.add(lblNewLabel, gbc_lblNewLabel);
		
		
		
		
		//lblNewLabel_1 = new JLabel("Sacs restants :");
		GridBagConstraints gbc_lblNewLabel_1 = new GridBagConstraints();
		gbc_lblNewLabel_1.insets = new Insets(0, 0, 5, 5);
		gbc_lblNewLabel_1.gridx = 0;
		gbc_lblNewLabel_1.gridy = 2;
		panel.add(lblNewLabel_1, gbc_lblNewLabel_1);
		
		GridBagConstraints gbc_horizontalStrut = new GridBagConstraints();
		gbc_horizontalStrut.insets = new Insets(0, 0, 5, 5);
		gbc_horizontalStrut.gridx = 1;
		gbc_horizontalStrut.gridy = 2;
		panel.add(horizontalStrut, gbc_horizontalStrut);
		
		//lblNewLabel_2 = new JLabel("nbre d'Intrus restants :");
		GridBagConstraints gbc_lblNewLabel_2 = new GridBagConstraints();
		gbc_lblNewLabel_2.insets = new Insets(0, 0, 5, 5);
		gbc_lblNewLabel_2.gridx = 2;
		gbc_lblNewLabel_2.gridy = 2;
		panel.add(lblNewLabel_2, gbc_lblNewLabel_2);
		
		GridBagConstraints gbc_horizontalStrut_1 = new GridBagConstraints();
		gbc_horizontalStrut_1.insets = new Insets(0, 0, 5, 5);
		gbc_horizontalStrut_1.gridx = 3;
		gbc_horizontalStrut_1.gridy = 2;
		panel.add(horizontalStrut_1, gbc_horizontalStrut_1);
		
		//lblNewLabel_3 = new JLabel("nbre de robots :");
		GridBagConstraints gbc_lblNewLabel_3 = new GridBagConstraints();
		gbc_lblNewLabel_3.insets = new Insets(0, 0, 5, 5);
		gbc_lblNewLabel_3.gridx = 4;
		gbc_lblNewLabel_3.gridy = 2;
		panel.add(lblNewLabel_3, gbc_lblNewLabel_3);
		pack();
		setLocationRelativeTo(null);
		setResizable(false);
		setVisible(true);
		
	}
	private class Map extends JPanel implements KeyListener,MouseListener,WindowListener {
		int width,height,cellWidth,cellHeight;
		private ConfigurationModel configuration ;
		private Vector<Robot> robots = new Vector<Robot>();
		private Vector<Intru> intrus = new Vector<Intru>();
		private Vector<Sac> sacs = new Vector<Sac>();
		private Vector<Obstacle> obstacles = new Vector<Obstacle>();
		private Vector<Sortie> sorties = new Vector<Sortie>();
		private int joueurActif ;
		private boolean jeuArrete;
		
		public Map(ConfigurationModel configuration) {
			this.configuration = configuration ; 
			joueurActif = 1;
			jeuArrete = true;
			width=getWidth();
			height=getHeight();
			cellWidth =40;
			cellHeight =40;
			prepare();
			changerTour();
			calculertemps();
			lblNewLabel_1.setText("Sacs restants: "+ sacs.size());
			lblNewLabel_2.setText("Intrus restants: "+intrus.size());
			lblNewLabel_3.setText("Robots: "+ robots.size());
			//afficher();
			this.addKeyListener(this);
			this.addMouseListener(this);
			addWindowListener(this);
	        this.setFocusable(true);
	        this.requestFocusInWindow();
	        
	        
	         
		}
		
		
		
		
	/*	//Afficher le nombre de robots, intrus et sacs
		private void afficher() {

			Timer myTimer2 = new Timer();
			TimerTask task2= new TimerTask() {
				int s=0;
				@Override
				public void run() {
					s++;
					int x1=sacs.size();
					int x2=intrus.size();
					int x3=robots.size();
					lblNewLabel_1.setText("Sacs restants: "+ x1);
					lblNewLabel_2.setText("Intrus restants: "+ x2);
					lblNewLabel_3.setText("Robots: "+ x3);
					//System.out.println(sacs.size());
				}
			};
			myTimer2.scheduleAtFixedRate(task2, 1000, 1000);
		}
		*/
		
		//Calculer le temps passé
		private void calculertemps() {
			//System.out.println("temps");
			
			Timer myTimer1 = new Timer();
			TimerTask task1= new TimerTask() {
				int SecondesPassed1 = 0;
				int min=0,heu=0;
				@Override
				public void run() {
					if (intrus.size()!=0) {
						SecondesPassed1 ++;  
					}
					
					String ch ="";
					
					if (SecondesPassed1 ==60) {
						min+=1;
						SecondesPassed1=0;
					}
					if (min==60) {
						heu+=1;
						min=0;
					}
					//System.out.println("Time: "+ SecondesPassed1);
					
					if (SecondesPassed1 / 10 == 0 && min/ 10==0 ) {
						ch="0"+heu+" : "+"0"+min+" : "+"0"+SecondesPassed1;
					}
					if (SecondesPassed1 / 10 != 0 && min/ 10==0) {
						ch="0"+heu+" : "+"0"+min+" : "+SecondesPassed1;
					}
					if (SecondesPassed1 / 10 == 0 && min/ 10!=0) {
						ch="0"+heu+" : "+min+" : "+"0"+SecondesPassed1;
					}
					
					if (SecondesPassed1 / 10 != 0 && min/ 10!=0) {
						ch="0"+heu+" : "+min+" : "+SecondesPassed1; 
					}
					lblNewLabel.setText("Time: " + ch );
					
					
				}
			};
			
			
				myTimer1.scheduleAtFixedRate(task1, 1000, 1000);
			
		
			
			
			
		}
		
		
		
		// Changer automatiquement le tour chaque 5 secondes
		private void changerTour()
		{
			
			Timer timer = new Timer();
			TimerTask  timerTask = new TimerTask() {
				int secondPassed = 0 ;
				@Override
				public void run() {
					secondPassed ++ ; 
					if (!jeuArrete) {
						//System.out.println("Il reste "+(5-secondPassed)+" secondes pourque le joueur " + joueurActif + " joue son coup !");
						label.setText("Il reste "+(5-secondPassed)+" secondes pourque le joueur " + joueurActif + " joue son coup !  .. Cliquer pour prendre le coup ! ..");
						if (secondPassed == 5 && joueurActif == 1) {
							secondPassed =0;
							joueurActif =2;
						}
						if (secondPassed == 5 && joueurActif == 2) {
							secondPassed =0;
							joueurActif =1;
						}
					}
					if (jeuArrete) {
						secondPassed = 0 ;
						label.setText("Joueur "+joueurActif+" en train de jouer !  .. Choisir une direction .. ");
					}
					
				}
			};
			timer.scheduleAtFixedRate(timerTask, 1000, 1000);
		}
		// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
		private void prepare()
		
		{
			for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
				int x= configuration.Emplac_Intrus.get(i).x;
				int y= configuration.Emplac_Intrus.get(i).y;
				Intru intru = new Intru(y, x, 1000);
				intrus.add(intru);
				MoveIntrus moveIntrus =new MoveIntrus(intru);
				moveIntrus.start();
			}
			for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
				int x= configuration.Emplac_Robots.get(i).x;
				int y= configuration.Emplac_Robots.get(i).y;
				Robot robot = new Robot(y,x, 500);
				robots.add(robot);
				MoveRobots moveRobots = new MoveRobots(robot);
				moveRobots.start();
			}
			for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
				int x= configuration.Emplac_Obstacle.get(i).x;
				int y= configuration.Emplac_Obstacle.get(i).y;
				Obstacle obstacle = new Obstacle(y, x);
				obstacles.add(obstacle);
			}
			for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
				int x= configuration.Emplac_Sac.get(i).x;
				int y= configuration.Emplac_Sac.get(i).y;
				Sac sac = new Sac(y, x);
				sacs.add(sac);
			}
			for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
				int x= configuration.Emplac_Sortie.get(i).x;
				int y= configuration.Emplac_Sortie.get(i).y;
				Sortie sortie = new Sortie(y, x);
				sorties.add(sortie);
			}
		}
		// verifier si p1 est adjacent à p2
		private boolean EstAdjacent(Point p1,Point p2)
		{
			if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
			((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
			return true;
			else return false;
		}
		private boolean MovementValide(Point p , char direction) {
			Point pa = null;
			switch (direction) {
			case 'D': pa = new Point(p.x+1,p.y);break;
			case 'G': pa = new Point(p.x-1,p.y);break;
			case 'B': pa = new Point(p.x,p.y+1);break;
			case 'H': pa = new Point(p.x,p.y-1);break;
			default:
				break;
			}
			if (pa != null) {
				for (int i = 0; i < obstacles.size(); i++) {
					if (obstacles.get(i).x == pa.x && obstacles.get(i).y== pa.y ) {
						return false;
					}
				}
				for (int i = 0; i < sacs.size(); i++) {
					if (sacs.get(i).x == pa.x && sacs.get(i).y== pa.y ) {
						return false;
					}
				}
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == pa.x && intrus.get(i).y== pa.y ) {
						return false;
					}
				}
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == pa.x && robots.get(i).y== pa.y ) {
						return false;
					}
				}
				for (int i = 0; i < sorties.size(); i++) {
					if (sorties.get(i).x == pa.x && sorties.get(i).y== pa.y ) {
						return false;
					}
				}
			}
			
			return true;
		}

		
		public class MoveIntrus extends Thread 
		{
			Intru intru ;
			MoveIntrus(Intru intru)
			{
				this.intru=intru;
			}
			@Override
			public void run() {
			//	int pas =0;
				while(true)
				{	//  un intru prend un sac 
					if (jeuArrete) {
					//	pas = 0 ;
						try {
							sleep(1000);
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
					}
					else 
					{
						// un intru prend un sac
						for (int i = 0; i < sacs.size(); i++) {
							if (EstAdjacent(intru, sacs.get(i))) {
								if (intru.PrendSac(sacs.get(i))) {
									sacs.remove(sacs.get(i));
									System.out.println(sacs.size());
									lblNewLabel_1.setText("Sacs restants: "+ sacs.size());
									
								}
																}
						} 
						//un robot attrape un intru 
						for (int i = 0; i < robots.size(); i++) {
							
							if (EstAdjacent(intru, robots.get(i)) )
								{
									for (int j = 0; j < intru.sacs.size(); j++) {
										
										sacs.add(intru.sacs.get(j));
										lblNewLabel_1.setText("Sacs restants: "+ sacs.size());
										
									}
									intru.retournerSac();
									intrus.remove(intru);
									lblNewLabel_2.setText("Intrus restants: "+intrus.size());
								}
						}
						// un intru sort à partir d'une sortie 
						for (int i = 0; i < sorties.size(); i++) {
							
							if (EstAdjacent(intru, sorties.get(i)) )
								{
									intrus.remove(intru);
									lblNewLabel_2.setText("Intrus restants: "+intrus.size());
								}
						}
						
						// le mouvement d'un intru d'une case à une autre
						if (intru.active==false) interrupt();
						
							
							if (MovementValide(intru, intru.direction))
							{
								intru.move();
								repaint();
								try {
									sleep(1000);
								} catch (InterruptedException e) {
									// TODO Auto-generated catch block
									e.printStackTrace();
								}
								
							}
						
					}
				
						
				}
							
				}
							
			}
		class MoveRobots extends Thread 
		{
			Robot robot;
			public MoveRobots(Robot robot) {
				this.robot = robot ;
			}

			@Override
			public void run() {
				// pas = 0;
				while(true)
				{
					if (jeuArrete) {
						//pas =0;
						try {
							sleep(1000);
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
					}
					else {
						
						// le mouvement d'un robot d'une case à une autre
						if (MovementValide(robot, robot.direction))
						{
							robot.move();
							repaint();
							
							try {
								//pas++;
								sleep(500);
								//if (pas==3) {
									//jeuArrete = true;
								//}
								
								
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						
					}
					
				}
							
				}
					
			}
		
		// dimensionner la JPanel
		@Override
		public Dimension getPreferredSize() {
			return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
			}
		// dessiner tous les objects 
		@Override
		protected void paintComponent(Graphics g) {
			super.paintComponent(g);
			
			if (intrus.size() == 0 )
			{
				jeuArrete = true;
				label.setText("le jeu est terminé !");
				ImageIcon imageIcon=new ImageIcon("resources\\GameOver.jpg");
				Image image = imageIcon.getImage();
				g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
				/*for (Thread t : Thread.getAllStackTraces().keySet()) 
				{  if (t.getState()==Thread.State.RUNNABLE) 
				     t.interrupt(); 
				} */

				
				repaint();
			}
			else {
				for (int i = 0; i < configuration.nbre_colonne; i++) {
					for (int j = 0; j < configuration.nbre_ligne; j++) {
						g.setColor(Color.WHITE);
						g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
					}
					
				}
				for (int i = 0; i < intrus.size(); i++) {
					if(intrus.get(i).active=true)
					{
						if (i == n ) {
							
							g.setColor(Color.red);
							g.draw3DRect(x, y, i, i, raised);(intrus.get(i).x*cellWidth,intrus.get(i).y*cellHeight, cellWidth, cellHeight,true);
						}
						intrus.get(i).draw(g);
					}
				}
				for (int i = 0; i < robots.size(); i++) {
					if (i == n ) {
						
						g.setColor(Color.red);
						g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
					}
					robots.get(i).draw(g);
				}
				for (int i = 0; i < obstacles.size(); i++) {
					
					obstacles.get(i).draw(g);
				}
				for (int i = 0; i < sacs.size(); i++) {
					
					sacs.get(i).draw(g);
				}
				/**for (int i = 0; i < sorties.size(); i++) {
					
					sorties.get(i).draw(g);
				}**/
			}
		}
		
		
		
		int n = -1 ;
		@Override
		public void keyTyped(KeyEvent e) {
			
			
			if (joueurActif == 1 && jeuArrete ) {
				if (robots.size() == 1) {
					n = 0;
				}
				if (n != -1) {
					
					Robot robot =  robots.get(n);
					switch (e.getKeyChar()) {
					case 'd': robot.TournerD();break;
					case 'q':robot.TournerG();break;
					case 'z':robot.TournerH();break;
					case 's':robot.TournerB();break;
					default:
						throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
					}
					joueurActif = 2 ;
					jeuArrete = false;
					n=-1;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
				
				
			}
			
				
				else if (joueurActif == 2 && jeuArrete ) {
					if (intrus.size() == 1 ) {
						n=0;
					}
					if (n != -1) {
						Intru intru =  intrus.get(n);
						switch (e.getKeyChar()) {
						case 'd': intru.TournerD();break;
						case 'q':intru.TournerG();break;
						case 'z':intru.TournerH();break;
						case 's':intru.TournerB();break;
						}
						joueurActif = 1 ;
						jeuArrete=false;
						n=-1;
					}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
					
			}	
			
		}
		@Override
		public void keyPressed(KeyEvent e) {
			// TODO Auto-generated method stub
			
		}
		@Override
		public void keyReleased(KeyEvent e) {
			// TODO Auto-generated method stub
			
		}
		@Override
		public void mouseClicked(MouseEvent e) {
			jeuArrete = true;
			n=-1;
			if (jeuArrete && (intrus.size() != 1 || robots.size() != 1)) {
				int colonne = e.getX()/cellWidth ;
				int ligne = e.getY() / cellWidth ;
				Point point = new Point(ligne,colonne);
				//System.out.println(point);
				if (joueurActif == 1  ) {
					for (int i = 0; i < robots.size(); i++) {
						if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
							n=i;
						}
					}
					if (n == -1 ) {
						JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
					}
					
				}
				if (joueurActif == 2  ) {
					for (int i = 0; i < intrus.size(); i++) {
						if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
							n=i;
						}
					}
					if (n == -1 ) {
						JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
					}
				}
				
			}
			
			
		}
		@Override
		public void mousePressed(MouseEvent e) {
			// TODO Auto-generated method stub
			
		}
		@Override
		public void mouseReleased(MouseEvent e) {
			// TODO Auto-generated method stub
			
		}
		@Override
		public void mouseEntered(MouseEvent e) {
			// TODO Auto-generated method stub
			
		}
		@Override
		public void mouseExited(MouseEvent e) {
			// TODO Auto-generated method stub
			
		}
		
		
		
		//verifier avant de quitter

		@Override
		public void windowActivated(WindowEvent e) {
			// TODO Auto-generated method stub
			
		}

		@Override
		public void windowClosed(WindowEvent e) {
			// TODO Auto-generated method stub
			
		}

		@Override
		public void windowClosing(WindowEvent e) {
			// TODO Auto-generated method stub
			exit();
			
			}
	
		void exit() {
			
			int a= JOptionPane.showConfirmDialog(null, "Clicker sur \"oui \" pour quitter vers le menu principal", "Quit options", JOptionPane.YES_NO_OPTION);
			if (a==JOptionPane.YES_OPTION) {
				dispose();
				Menu window = new Menu();
				window.main(null);
				
			}
			
			
			
		}
		

		@Override
		public void windowDeactivated(WindowEvent e) {
			// TODO Auto-generated method stub
			
		}

		@Override
		public void windowDeiconified(WindowEvent e) {
			// TODO Auto-generated method stub
			
		}

		@Override
		public void windowIconified(WindowEvent e) {
			// TODO Auto-generated method stub
			
		}

		@Override
		public void windowOpened(WindowEvent e) {
			// TODO Auto-generated method stub
			
		}
		
	}
}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-09-17 08:08:31.973
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-09-17 08:08:31.977
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-17 08:08:32.218
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.GridBagLayout;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.event.WindowEvent;
import java.awt.event.WindowListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import java.awt.GridBagConstraints;
import java.awt.Insets;
import java.awt.Component;
import javax.swing.Box;

public class Jeu extends JFrame{
	JLabel label;
	JPanel panel = new JPanel();
	JLabel lblNewLabel = new JLabel("Time :");
	JLabel lblNewLabel_1 = new JLabel("Sacs restants :");
	JLabel lblNewLabel_2 = new JLabel("Intrus restants :");
	JLabel lblNewLabel_3 = new JLabel("Robots :");
	private Component verticalStrut;
	private final Component horizontalStrut = Box.createHorizontalStrut(20);
	private final Component horizontalStrut_1 = Box.createHorizontalStrut(20);
	public Jeu(ConfigurationModel configuration) {
		super("Jeu");
		setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);
		getContentPane().setLayout(new BorderLayout());
		 label = new JLabel("Hello");
		 label.setForeground(Color.red);
		label.setVisible(true);
		getContentPane().add(label,BorderLayout.SOUTH);
		getContentPane().add(new Map(configuration),BorderLayout.CENTER);
		getContentPane().add(panel, BorderLayout.NORTH);
		GridBagLayout gbl_panel = new GridBagLayout();
		gbl_panel.columnWidths = new int[]{52, 0, 0, 0, 0, 56, 0};
		gbl_panel.rowHeights = new int[]{0, 0, 0, 16, 0};
		gbl_panel.columnWeights = new double[]{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, Double.MIN_VALUE};
		gbl_panel.rowWeights = new double[]{0.0, 0.0, 0.0, 0.0, Double.MIN_VALUE};
		panel.setLayout(gbl_panel);
		
		verticalStrut = Box.createVerticalStrut(20);
		GridBagConstraints gbc_verticalStrut = new GridBagConstraints();
		gbc_verticalStrut.insets = new Insets(0, 0, 5, 5);
		gbc_verticalStrut.gridx = 0;
		gbc_verticalStrut.gridy = 0;
		panel.add(verticalStrut, gbc_verticalStrut);
		
		//JLabel lblNewLabel = new JLabel("Time :");
		GridBagConstraints gbc_lblNewLabel = new GridBagConstraints();
		gbc_lblNewLabel.insets = new Insets(0, 0, 5, 5);
		gbc_lblNewLabel.anchor = GridBagConstraints.NORTHWEST;
		gbc_lblNewLabel.gridx = 0;
		gbc_lblNewLabel.gridy = 1;
		panel.add(lblNewLabel, gbc_lblNewLabel);
		
		
		
		
		//lblNewLabel_1 = new JLabel("Sacs restants :");
		GridBagConstraints gbc_lblNewLabel_1 = new GridBagConstraints();
		gbc_lblNewLabel_1.insets = new Insets(0, 0, 5, 5);
		gbc_lblNewLabel_1.gridx = 0;
		gbc_lblNewLabel_1.gridy = 2;
		panel.add(lblNewLabel_1, gbc_lblNewLabel_1);
		
		GridBagConstraints gbc_horizontalStrut = new GridBagConstraints();
		gbc_horizontalStrut.insets = new Insets(0, 0, 5, 5);
		gbc_horizontalStrut.gridx = 1;
		gbc_horizontalStrut.gridy = 2;
		panel.add(horizontalStrut, gbc_horizontalStrut);
		
		//lblNewLabel_2 = new JLabel("nbre d'Intrus restants :");
		GridBagConstraints gbc_lblNewLabel_2 = new GridBagConstraints();
		gbc_lblNewLabel_2.insets = new Insets(0, 0, 5, 5);
		gbc_lblNewLabel_2.gridx = 2;
		gbc_lblNewLabel_2.gridy = 2;
		panel.add(lblNewLabel_2, gbc_lblNewLabel_2);
		
		GridBagConstraints gbc_horizontalStrut_1 = new GridBagConstraints();
		gbc_horizontalStrut_1.insets = new Insets(0, 0, 5, 5);
		gbc_horizontalStrut_1.gridx = 3;
		gbc_horizontalStrut_1.gridy = 2;
		panel.add(horizontalStrut_1, gbc_horizontalStrut_1);
		
		//lblNewLabel_3 = new JLabel("nbre de robots :");
		GridBagConstraints gbc_lblNewLabel_3 = new GridBagConstraints();
		gbc_lblNewLabel_3.insets = new Insets(0, 0, 5, 5);
		gbc_lblNewLabel_3.gridx = 4;
		gbc_lblNewLabel_3.gridy = 2;
		panel.add(lblNewLabel_3, gbc_lblNewLabel_3);
		pack();
		setLocationRelativeTo(null);
		setResizable(false);
		setVisible(true);
		
	}
	private class Map extends JPanel implements KeyListener,MouseListener,WindowListener {
		int width,height,cellWidth,cellHeight;
		private ConfigurationModel configuration ;
		private Vector<Robot> robots = new Vector<Robot>();
		private Vector<Intru> intrus = new Vector<Intru>();
		private Vector<Sac> sacs = new Vector<Sac>();
		private Vector<Obstacle> obstacles = new Vector<Obstacle>();
		private Vector<Sortie> sorties = new Vector<Sortie>();
		private int joueurActif ;
		private boolean jeuArrete;
		
		public Map(ConfigurationModel configuration) {
			this.configuration = configuration ; 
			joueurActif = 1;
			jeuArrete = true;
			width=getWidth();
			height=getHeight();
			cellWidth =40;
			cellHeight =40;
			prepare();
			changerTour();
			calculertemps();
			lblNewLabel_1.setText("Sacs restants: "+ sacs.size());
			lblNewLabel_2.setText("Intrus restants: "+intrus.size());
			lblNewLabel_3.setText("Robots: "+ robots.size());
			//afficher();
			this.addKeyListener(this);
			this.addMouseListener(this);
			addWindowListener(this);
	        this.setFocusable(true);
	        this.requestFocusInWindow();
	        
	        
	         
		}
		
		
		
		
	/*	//Afficher le nombre de robots, intrus et sacs
		private void afficher() {

			Timer myTimer2 = new Timer();
			TimerTask task2= new TimerTask() {
				int s=0;
				@Override
				public void run() {
					s++;
					int x1=sacs.size();
					int x2=intrus.size();
					int x3=robots.size();
					lblNewLabel_1.setText("Sacs restants: "+ x1);
					lblNewLabel_2.setText("Intrus restants: "+ x2);
					lblNewLabel_3.setText("Robots: "+ x3);
					//System.out.println(sacs.size());
				}
			};
			myTimer2.scheduleAtFixedRate(task2, 1000, 1000);
		}
		*/
		
		//Calculer le temps passé
		private void calculertemps() {
			//System.out.println("temps");
			
			Timer myTimer1 = new Timer();
			TimerTask task1= new TimerTask() {
				int SecondesPassed1 = 0;
				int min=0,heu=0;
				@Override
				public void run() {
					if (intrus.size()!=0) {
						SecondesPassed1 ++;  
					}
					
					String ch ="";
					
					if (SecondesPassed1 ==60) {
						min+=1;
						SecondesPassed1=0;
					}
					if (min==60) {
						heu+=1;
						min=0;
					}
					//System.out.println("Time: "+ SecondesPassed1);
					
					if (SecondesPassed1 / 10 == 0 && min/ 10==0 ) {
						ch="0"+heu+" : "+"0"+min+" : "+"0"+SecondesPassed1;
					}
					if (SecondesPassed1 / 10 != 0 && min/ 10==0) {
						ch="0"+heu+" : "+"0"+min+" : "+SecondesPassed1;
					}
					if (SecondesPassed1 / 10 == 0 && min/ 10!=0) {
						ch="0"+heu+" : "+min+" : "+"0"+SecondesPassed1;
					}
					
					if (SecondesPassed1 / 10 != 0 && min/ 10!=0) {
						ch="0"+heu+" : "+min+" : "+SecondesPassed1; 
					}
					lblNewLabel.setText("Time: " + ch );
					
					
				}
			};
			
			
				myTimer1.scheduleAtFixedRate(task1, 1000, 1000);
			
		
			
			
			
		}
		
		
		
		// Changer automatiquement le tour chaque 5 secondes
		private void changerTour()
		{
			
			Timer timer = new Timer();
			TimerTask  timerTask = new TimerTask() {
				int secondPassed = 0 ;
				@Override
				public void run() {
					secondPassed ++ ; 
					if (!jeuArrete) {
						//System.out.println("Il reste "+(5-secondPassed)+" secondes pourque le joueur " + joueurActif + " joue son coup !");
						label.setText("Il reste "+(5-secondPassed)+" secondes pourque le joueur " + joueurActif + " joue son coup !  .. Cliquer pour prendre le coup ! ..");
						if (secondPassed == 5 && joueurActif == 1) {
							secondPassed =0;
							joueurActif =2;
						}
						if (secondPassed == 5 && joueurActif == 2) {
							secondPassed =0;
							joueurActif =1;
						}
					}
					if (jeuArrete) {
						secondPassed = 0 ;
						label.setText("Joueur "+joueurActif+" en train de jouer !  .. Choisir une direction .. ");
					}
					
				}
			};
			timer.scheduleAtFixedRate(timerTask, 1000, 1000);
		}
		// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
		private void prepare()
		
		{
			for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
				int x= configuration.Emplac_Intrus.get(i).x;
				int y= configuration.Emplac_Intrus.get(i).y;
				Intru intru = new Intru(y, x, 1000);
				intrus.add(intru);
				MoveIntrus moveIntrus =new MoveIntrus(intru);
				moveIntrus.start();
			}
			for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
				int x= configuration.Emplac_Robots.get(i).x;
				int y= configuration.Emplac_Robots.get(i).y;
				Robot robot = new Robot(y,x, 500);
				robots.add(robot);
				MoveRobots moveRobots = new MoveRobots(robot);
				moveRobots.start();
			}
			for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
				int x= configuration.Emplac_Obstacle.get(i).x;
				int y= configuration.Emplac_Obstacle.get(i).y;
				Obstacle obstacle = new Obstacle(y, x);
				obstacles.add(obstacle);
			}
			for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
				int x= configuration.Emplac_Sac.get(i).x;
				int y= configuration.Emplac_Sac.get(i).y;
				Sac sac = new Sac(y, x);
				sacs.add(sac);
			}
			for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
				int x= configuration.Emplac_Sortie.get(i).x;
				int y= configuration.Emplac_Sortie.get(i).y;
				Sortie sortie = new Sortie(y, x);
				sorties.add(sortie);
			}
		}
		// verifier si p1 est adjacent à p2
		private boolean EstAdjacent(Point p1,Point p2)
		{
			if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
			((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
			return true;
			else return false;
		}
		private boolean MovementValide(Point p , char direction) {
			Point pa = null;
			switch (direction) {
			case 'D': pa = new Point(p.x+1,p.y);break;
			case 'G': pa = new Point(p.x-1,p.y);break;
			case 'B': pa = new Point(p.x,p.y+1);break;
			case 'H': pa = new Point(p.x,p.y-1);break;
			default:
				break;
			}
			if (pa != null) {
				for (int i = 0; i < obstacles.size(); i++) {
					if (obstacles.get(i).x == pa.x && obstacles.get(i).y== pa.y ) {
						return false;
					}
				}
				for (int i = 0; i < sacs.size(); i++) {
					if (sacs.get(i).x == pa.x && sacs.get(i).y== pa.y ) {
						return false;
					}
				}
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == pa.x && intrus.get(i).y== pa.y ) {
						return false;
					}
				}
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == pa.x && robots.get(i).y== pa.y ) {
						return false;
					}
				}
				for (int i = 0; i < sorties.size(); i++) {
					if (sorties.get(i).x == pa.x && sorties.get(i).y== pa.y ) {
						return false;
					}
				}
			}
			
			return true;
		}

		
		public class MoveIntrus extends Thread 
		{
			Intru intru ;
			MoveIntrus(Intru intru)
			{
				this.intru=intru;
			}
			@Override
			public void run() {
			//	int pas =0;
				while(true)
				{	//  un intru prend un sac 
					if (jeuArrete) {
					//	pas = 0 ;
						try {
							sleep(1000);
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
					}
					else 
					{
						// un intru prend un sac
						for (int i = 0; i < sacs.size(); i++) {
							if (EstAdjacent(intru, sacs.get(i))) {
								if (intru.PrendSac(sacs.get(i))) {
									sacs.remove(sacs.get(i));
									System.out.println(sacs.size());
									lblNewLabel_1.setText("Sacs restants: "+ sacs.size());
									
								}
																}
						} 
						//un robot attrape un intru 
						for (int i = 0; i < robots.size(); i++) {
							
							if (EstAdjacent(intru, robots.get(i)) )
								{
									for (int j = 0; j < intru.sacs.size(); j++) {
										
										sacs.add(intru.sacs.get(j));
										lblNewLabel_1.setText("Sacs restants: "+ sacs.size());
										
									}
									intru.retournerSac();
									intrus.remove(intru);
									lblNewLabel_2.setText("Intrus restants: "+intrus.size());
								}
						}
						// un intru sort à partir d'une sortie 
						for (int i = 0; i < sorties.size(); i++) {
							
							if (EstAdjacent(intru, sorties.get(i)) )
								{
									intrus.remove(intru);
									lblNewLabel_2.setText("Intrus restants: "+intrus.size());
								}
						}
						
						// le mouvement d'un intru d'une case à une autre
						if (intru.active==false) interrupt();
						
							
							if (MovementValide(intru, intru.direction))
							{
								intru.move();
								repaint();
								try {
									sleep(1000);
								} catch (InterruptedException e) {
									// TODO Auto-generated catch block
									e.printStackTrace();
								}
								
							}
						
					}
				
						
				}
							
				}
							
			}
		class MoveRobots extends Thread 
		{
			Robot robot;
			public MoveRobots(Robot robot) {
				this.robot = robot ;
			}

			@Override
			public void run() {
				// pas = 0;
				while(true)
				{
					if (jeuArrete) {
						//pas =0;
						try {
							sleep(1000);
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
					}
					else {
						
						// le mouvement d'un robot d'une case à une autre
						if (MovementValide(robot, robot.direction))
						{
							robot.move();
							repaint();
							
							try {
								//pas++;
								sleep(500);
								//if (pas==3) {
									//jeuArrete = true;
								//}
								
								
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						
					}
					
				}
							
				}
					
			}
		
		// dimensionner la JPanel
		@Override
		public Dimension getPreferredSize() {
			return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
			}
		// dessiner tous les objects 
		@Override
		protected void paintComponent(Graphics g) {
			super.paintComponent(g);
			
			if (intrus.size() == 0 )
			{
				jeuArrete = true;
				label.setText("le jeu est terminé !");
				ImageIcon imageIcon=new ImageIcon("resources\\GameOver.jpg");
				Image image = imageIcon.getImage();
				g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
				/*for (Thread t : Thread.getAllStackTraces().keySet()) 
				{  if (t.getState()==Thread.State.RUNNABLE) 
				     t.interrupt(); 
				} */

				
				repaint();
			}
			else {
				for (int i = 0; i < configuration.nbre_colonne; i++) {
					for (int j = 0; j < configuration.nbre_ligne; j++) {
						g.setColor(Color.WHITE);
						g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
					}
					
				}
				for (int i = 0; i < intrus.size(); i++) {
					if(intrus.get(i).active=true)
					{
						if (i == n ) {
							
							g.setColor(Color.red);
							g.draw3DRect(x, y, i, i, raised);(intrus.get(i).x*cellWidth,intrus.get(i).y*cellHeight, cellWidth, cellHeight,true);
						}
						intrus.get(i).draw(g);
					}
				}
				for (int i = 0; i < robots.size(); i++) {
					if (i == n ) {
						
						g.setColor(Color.red);
						g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
					}
					robots.get(i).draw(g);
				}
				for (int i = 0; i < obstacles.size(); i++) {
					
					obstacles.get(i).draw(g);
				}
				for (int i = 0; i < sacs.size(); i++) {
					
					sacs.get(i).draw(g);
				}
				/**for (int i = 0; i < sorties.size(); i++) {
					
					sorties.get(i).draw(g);
				}**/
			}
		}
		
		
		
		int n = -1 ;
		@Override
		public void keyTyped(KeyEvent e) {
			
			
			if (joueurActif == 1 && jeuArrete ) {
				if (robots.size() == 1) {
					n = 0;
				}
				if (n != -1) {
					
					Robot robot =  robots.get(n);
					switch (e.getKeyChar()) {
					case 'd': robot.TournerD();break;
					case 'q':robot.TournerG();break;
					case 'z':robot.TournerH();break;
					case 's':robot.TournerB();break;
					default:
						throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
					}
					joueurActif = 2 ;
					jeuArrete = false;
					n=-1;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
				
				
			}
			
				
				else if (joueurActif == 2 && jeuArrete ) {
					if (intrus.size() == 1 ) {
						n=0;
					}
					if (n != -1) {
						Intru intru =  intrus.get(n);
						switch (e.getKeyChar()) {
						case 'd': intru.TournerD();break;
						case 'q':intru.TournerG();break;
						case 'z':intru.TournerH();break;
						case 's':intru.TournerB();break;
						}
						joueurActif = 1 ;
						jeuArrete=false;
						n=-1;
					}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
					
			}	
			
		}
		@Override
		public void keyPressed(KeyEvent e) {
			// TODO Auto-generated method stub
			
		}
		@Override
		public void keyReleased(KeyEvent e) {
			// TODO Auto-generated method stub
			
		}
		@Override
		public void mouseClicked(MouseEvent e) {
			jeuArrete = true;
			n=-1;
			if (jeuArrete && (intrus.size() != 1 || robots.size() != 1)) {
				int colonne = e.getX()/cellWidth ;
				int ligne = e.getY() / cellWidth ;
				Point point = new Point(ligne,colonne);
				//System.out.println(point);
				if (joueurActif == 1  ) {
					for (int i = 0; i < robots.size(); i++) {
						if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
							n=i;
						}
					}
					if (n == -1 ) {
						JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
					}
					
				}
				if (joueurActif == 2  ) {
					for (int i = 0; i < intrus.size(); i++) {
						if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
							n=i;
						}
					}
					if (n == -1 ) {
						JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
					}
				}
				
			}
			
			
		}
		@Override
		public void mousePressed(MouseEvent e) {
			// TODO Auto-generated method stub
			
		}
		@Override
		public void mouseReleased(MouseEvent e) {
			// TODO Auto-generated method stub
			
		}
		@Override
		public void mouseEntered(MouseEvent e) {
			// TODO Auto-generated method stub
			
		}
		@Override
		public void mouseExited(MouseEvent e) {
			// TODO Auto-generated method stub
			
		}
		
		
		
		//verifier avant de quitter

		@Override
		public void windowActivated(WindowEvent e) {
			// TODO Auto-generated method stub
			
		}

		@Override
		public void windowClosed(WindowEvent e) {
			// TODO Auto-generated method stub
			
		}

		@Override
		public void windowClosing(WindowEvent e) {
			// TODO Auto-generated method stub
			exit();
			
			}
	
		void exit() {
			
			int a= JOptionPane.showConfirmDialog(null, "Clicker sur \"oui \" pour quitter vers le menu principal", "Quit options", JOptionPane.YES_NO_OPTION);
			if (a==JOptionPane.YES_OPTION) {
				dispose();
				Menu window = new Menu();
				window.main(null);
				
			}
			
			
			
		}
		

		@Override
		public void windowDeactivated(WindowEvent e) {
			// TODO Auto-generated method stub
			
		}

		@Override
		public void windowDeiconified(WindowEvent e) {
			// TODO Auto-generated method stub
			
		}

		@Override
		public void windowIconified(WindowEvent e) {
			// TODO Auto-generated method stub
			
		}

		@Override
		public void windowOpened(WindowEvent e) {
			// TODO Auto-generated method stub
			
		}
		
	}
}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-09-17 08:08:32.223
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-09-17 08:08:32.227
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-17 08:15:18.005
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.GridBagLayout;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.event.WindowEvent;
import java.awt.event.WindowListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import java.awt.GridBagConstraints;
import java.awt.Insets;
import java.awt.Component;
import javax.swing.Box;

public class Jeu extends JFrame{
	JLabel label;
	JPanel panel = new JPanel();
	JLabel lblNewLabel = new JLabel("Time :");
	JLabel lblNewLabel_1 = new JLabel("Sacs restants :");
	JLabel lblNewLabel_2 = new JLabel("Intrus restants :");
	JLabel lblNewLabel_3 = new JLabel("Robots :");
	private Component verticalStrut;
	private final Component horizontalStrut = Box.createHorizontalStrut(20);
	private final Component horizontalStrut_1 = Box.createHorizontalStrut(20);
	public Jeu(ConfigurationModel configuration) {
		super("Jeu");
		setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);
		getContentPane().setLayout(new BorderLayout());
		 label = new JLabel("Hello");
		 label.setForeground(Color.red);
		label.setVisible(true);
		getContentPane().add(label,BorderLayout.SOUTH);
		getContentPane().add(new Map(configuration),BorderLayout.CENTER);
		getContentPane().add(panel, BorderLayout.NORTH);
		GridBagLayout gbl_panel = new GridBagLayout();
		gbl_panel.columnWidths = new int[]{52, 0, 0, 0, 0, 56, 0};
		gbl_panel.rowHeights = new int[]{0, 0, 0, 16, 0};
		gbl_panel.columnWeights = new double[]{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, Double.MIN_VALUE};
		gbl_panel.rowWeights = new double[]{0.0, 0.0, 0.0, 0.0, Double.MIN_VALUE};
		panel.setLayout(gbl_panel);
		
		verticalStrut = Box.createVerticalStrut(20);
		GridBagConstraints gbc_verticalStrut = new GridBagConstraints();
		gbc_verticalStrut.insets = new Insets(0, 0, 5, 5);
		gbc_verticalStrut.gridx = 0;
		gbc_verticalStrut.gridy = 0;
		panel.add(verticalStrut, gbc_verticalStrut);
		
		//JLabel lblNewLabel = new JLabel("Time :");
		GridBagConstraints gbc_lblNewLabel = new GridBagConstraints();
		gbc_lblNewLabel.insets = new Insets(0, 0, 5, 5);
		gbc_lblNewLabel.anchor = GridBagConstraints.NORTHWEST;
		gbc_lblNewLabel.gridx = 0;
		gbc_lblNewLabel.gridy = 1;
		panel.add(lblNewLabel, gbc_lblNewLabel);
		
		
		
		
		//lblNewLabel_1 = new JLabel("Sacs restants :");
		GridBagConstraints gbc_lblNewLabel_1 = new GridBagConstraints();
		gbc_lblNewLabel_1.insets = new Insets(0, 0, 5, 5);
		gbc_lblNewLabel_1.gridx = 0;
		gbc_lblNewLabel_1.gridy = 2;
		panel.add(lblNewLabel_1, gbc_lblNewLabel_1);
		
		GridBagConstraints gbc_horizontalStrut = new GridBagConstraints();
		gbc_horizontalStrut.insets = new Insets(0, 0, 5, 5);
		gbc_horizontalStrut.gridx = 1;
		gbc_horizontalStrut.gridy = 2;
		panel.add(horizontalStrut, gbc_horizontalStrut);
		
		//lblNewLabel_2 = new JLabel("nbre d'Intrus restants :");
		GridBagConstraints gbc_lblNewLabel_2 = new GridBagConstraints();
		gbc_lblNewLabel_2.insets = new Insets(0, 0, 5, 5);
		gbc_lblNewLabel_2.gridx = 2;
		gbc_lblNewLabel_2.gridy = 2;
		panel.add(lblNewLabel_2, gbc_lblNewLabel_2);
		
		GridBagConstraints gbc_horizontalStrut_1 = new GridBagConstraints();
		gbc_horizontalStrut_1.insets = new Insets(0, 0, 5, 5);
		gbc_horizontalStrut_1.gridx = 3;
		gbc_horizontalStrut_1.gridy = 2;
		panel.add(horizontalStrut_1, gbc_horizontalStrut_1);
		
		//lblNewLabel_3 = new JLabel("nbre de robots :");
		GridBagConstraints gbc_lblNewLabel_3 = new GridBagConstraints();
		gbc_lblNewLabel_3.insets = new Insets(0, 0, 5, 5);
		gbc_lblNewLabel_3.gridx = 4;
		gbc_lblNewLabel_3.gridy = 2;
		panel.add(lblNewLabel_3, gbc_lblNewLabel_3);
		pack();
		setLocationRelativeTo(null);
		setResizable(false);
		setVisible(true);
		
	}
	private class Map extends JPanel implements KeyListener,MouseListener,WindowListener {
		int width,height,cellWidth,cellHeight;
		private ConfigurationModel configuration ;
		private Vector<Robot> robots = new Vector<Robot>();
		private Vector<Intru> intrus = new Vector<Intru>();
		private Vector<Sac> sacs = new Vector<Sac>();
		private Vector<Obstacle> obstacles = new Vector<Obstacle>();
		private Vector<Sortie> sorties = new Vector<Sortie>();
		private int joueurActif ;
		private boolean jeuArrete;
		
		public Map(ConfigurationModel configuration) {
			this.configuration = configuration ; 
			joueurActif = 1;
			jeuArrete = true;
			width=getWidth();
			height=getHeight();
			cellWidth =40;
			cellHeight =40;
			prepare();
			changerTour();
			calculertemps();
			lblNewLabel_1.setText("Sacs restants: "+ sacs.size());
			lblNewLabel_2.setText("Intrus restants: "+intrus.size());
			lblNewLabel_3.setText("Robots: "+ robots.size());
			//afficher();
			this.addKeyListener(this);
			this.addMouseListener(this);
			addWindowListener(this);
	        this.setFocusable(true);
	        this.requestFocusInWindow();
	        
	        
	         
		}
		
		
		
		
	/*	//Afficher le nombre de robots, intrus et sacs
		private void afficher() {

			Timer myTimer2 = new Timer();
			TimerTask task2= new TimerTask() {
				int s=0;
				@Override
				public void run() {
					s++;
					int x1=sacs.size();
					int x2=intrus.size();
					int x3=robots.size();
					lblNewLabel_1.setText("Sacs restants: "+ x1);
					lblNewLabel_2.setText("Intrus restants: "+ x2);
					lblNewLabel_3.setText("Robots: "+ x3);
					//System.out.println(sacs.size());
				}
			};
			myTimer2.scheduleAtFixedRate(task2, 1000, 1000);
		}
		*/
		
		//Calculer le temps passé
		private void calculertemps() {
			//System.out.println("temps");
			
			Timer myTimer1 = new Timer();
			TimerTask task1= new TimerTask() {
				int SecondesPassed1 = 0;
				int min=0,heu=0;
				@Override
				public void run() {
					if (intrus.size()!=0) {
						SecondesPassed1 ++;  
					}
					
					String ch ="";
					
					if (SecondesPassed1 ==60) {
						min+=1;
						SecondesPassed1=0;
					}
					if (min==60) {
						heu+=1;
						min=0;
					}
					//System.out.println("Time: "+ SecondesPassed1);
					
					if (SecondesPassed1 / 10 == 0 && min/ 10==0 ) {
						ch="0"+heu+" : "+"0"+min+" : "+"0"+SecondesPassed1;
					}
					if (SecondesPassed1 / 10 != 0 && min/ 10==0) {
						ch="0"+heu+" : "+"0"+min+" : "+SecondesPassed1;
					}
					if (SecondesPassed1 / 10 == 0 && min/ 10!=0) {
						ch="0"+heu+" : "+min+" : "+"0"+SecondesPassed1;
					}
					
					if (SecondesPassed1 / 10 != 0 && min/ 10!=0) {
						ch="0"+heu+" : "+min+" : "+SecondesPassed1; 
					}
					lblNewLabel.setText("Time: " + ch );
					
					
				}
			};
			
			
				myTimer1.scheduleAtFixedRate(task1, 1000, 1000);
			
		
			
			
			
		}
		
		
		
		// Changer automatiquement le tour chaque 5 secondes
		private void changerTour()
		{
			
			Timer timer = new Timer();
			TimerTask  timerTask = new TimerTask() {
				int secondPassed = 0 ;
				@Override
				public void run() {
					secondPassed ++ ; 
					if (!jeuArrete) {
						//System.out.println("Il reste "+(5-secondPassed)+" secondes pourque le joueur " + joueurActif + " joue son coup !");
						label.setText("Il reste "+(5-secondPassed)+" secondes pourque le joueur " + joueurActif + " joue son coup !  .. Cliquer pour prendre le coup ! ..");
						if (secondPassed == 5 && joueurActif == 1) {
							secondPassed =0;
							joueurActif =2;
						}
						if (secondPassed == 5 && joueurActif == 2) {
							secondPassed =0;
							joueurActif =1;
						}
					}
					if (jeuArrete) {
						secondPassed = 0 ;
						label.setText("Joueur "+joueurActif+" en train de jouer !  .. Choisir une direction .. ");
					}
					
				}
			};
			timer.scheduleAtFixedRate(timerTask, 1000, 1000);
		}
		// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
		private void prepare()
		
		{
			for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
				int x= configuration.Emplac_Intrus.get(i).x;
				int y= configuration.Emplac_Intrus.get(i).y;
				Intru intru = new Intru(y, x, 1000);
				intrus.add(intru);
				MoveIntrus moveIntrus =new MoveIntrus(intru);
				moveIntrus.start();
			}
			for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
				int x= configuration.Emplac_Robots.get(i).x;
				int y= configuration.Emplac_Robots.get(i).y;
				Robot robot = new Robot(y,x, 500);
				robots.add(robot);
				MoveRobots moveRobots = new MoveRobots(robot);
				moveRobots.start();
			}
			for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
				int x= configuration.Emplac_Obstacle.get(i).x;
				int y= configuration.Emplac_Obstacle.get(i).y;
				Obstacle obstacle = new Obstacle(y, x);
				obstacles.add(obstacle);
			}
			for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
				int x= configuration.Emplac_Sac.get(i).x;
				int y= configuration.Emplac_Sac.get(i).y;
				Sac sac = new Sac(y, x);
				sacs.add(sac);
			}
			for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
				int x= configuration.Emplac_Sortie.get(i).x;
				int y= configuration.Emplac_Sortie.get(i).y;
				Sortie sortie = new Sortie(y, x);
				sorties.add(sortie);
			}
		}
		// verifier si p1 est adjacent à p2
		private boolean EstAdjacent(Point p1,Point p2)
		{
			if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
			((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
			return true;
			else return false;
		}
		private boolean MovementValide(Point p , char direction) {
			Point pa = null;
			switch (direction) {
			case 'D': pa = new Point(p.x+1,p.y);break;
			case 'G': pa = new Point(p.x-1,p.y);break;
			case 'B': pa = new Point(p.x,p.y+1);break;
			case 'H': pa = new Point(p.x,p.y-1);break;
			default:
				break;
			}
			if (pa != null) {
				for (int i = 0; i < obstacles.size(); i++) {
					if (obstacles.get(i).x == pa.x && obstacles.get(i).y== pa.y ) {
						return false;
					}
				}
				for (int i = 0; i < sacs.size(); i++) {
					if (sacs.get(i).x == pa.x && sacs.get(i).y== pa.y ) {
						return false;
					}
				}
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == pa.x && intrus.get(i).y== pa.y ) {
						return false;
					}
				}
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == pa.x && robots.get(i).y== pa.y ) {
						return false;
					}
				}
				for (int i = 0; i < sorties.size(); i++) {
					if (sorties.get(i).x == pa.x && sorties.get(i).y== pa.y ) {
						return false;
					}
				}
			}
			
			return true;
		}

		
		public class MoveIntrus extends Thread 
		{
			Intru intru ;
			MoveIntrus(Intru intru)
			{
				this.intru=intru;
			}
			@Override
			public void run() {
			//	int pas =0;
				while(true)
				{	//  un intru prend un sac 
					if (jeuArrete) {
					//	pas = 0 ;
						try {
							sleep(1000);
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
					}
					else 
					{
						// un intru prend un sac
						for (int i = 0; i < sacs.size(); i++) {
							if (EstAdjacent(intru, sacs.get(i))) {
								if (intru.PrendSac(sacs.get(i))) {
									sacs.remove(sacs.get(i));
									System.out.println(sacs.size());
									lblNewLabel_1.setText("Sacs restants: "+ sacs.size());
									
								}
																}
						} 
						//un robot attrape un intru 
						for (int i = 0; i < robots.size(); i++) {
							
							if (EstAdjacent(intru, robots.get(i)) )
								{
									for (int j = 0; j < intru.sacs.size(); j++) {
										
										sacs.add(intru.sacs.get(j));
										lblNewLabel_1.setText("Sacs restants: "+ sacs.size());
										
									}
									intru.retournerSac();
									intrus.remove(intru);
									lblNewLabel_2.setText("Intrus restants: "+intrus.size());
								}
						}
						// un intru sort à partir d'une sortie 
						for (int i = 0; i < sorties.size(); i++) {
							
							if (EstAdjacent(intru, sorties.get(i)) )
								{
									intrus.remove(intru);
									lblNewLabel_2.setText("Intrus restants: "+intrus.size());
								}
						}
						
						// le mouvement d'un intru d'une case à une autre
						if (intru.active==false) interrupt();
						
							
							if (MovementValide(intru, intru.direction))
							{
								intru.move();
								repaint();
								try {
									sleep(1000);
								} catch (InterruptedException e) {
									// TODO Auto-generated catch block
									e.printStackTrace();
								}
								
							}
						
					}
				
						
				}
							
				}
							
			}
		class MoveRobots extends Thread 
		{
			Robot robot;
			public MoveRobots(Robot robot) {
				this.robot = robot ;
			}

			@Override
			public void run() {
				// pas = 0;
				while(true)
				{
					if (jeuArrete) {
						//pas =0;
						try {
							sleep(1000);
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
					}
					else {
						
						// le mouvement d'un robot d'une case à une autre
						if (MovementValide(robot, robot.direction))
						{
							robot.move();
							repaint();
							
							try {
								//pas++;
								sleep(500);
								//if (pas==3) {
									//jeuArrete = true;
								//}
								
								
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						
					}
					
				}
							
				}
					
			}
		
		// dimensionner la JPanel
		@Override
		public Dimension getPreferredSize() {
			return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
			}
		// dessiner tous les objects 
		@Override
		protected void paintComponent(Graphics g) {
			super.paintComponent(g);
			
			if (intrus.size() == 0 )
			{
				jeuArrete = true;
				label.setText("le jeu est terminé !");
				ImageIcon imageIcon=new ImageIcon("resources\\GameOver.jpg");
				Image image = imageIcon.getImage();
				g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
				/*for (Thread t : Thread.getAllStackTraces().keySet()) 
				{  if (t.getState()==Thread.State.RUNNABLE) 
				     t.interrupt(); 
				} */

				
				repaint();
			}
			else {
				for (int i = 0; i < configuration.nbre_colonne; i++) {
					for (int j = 0; j < configuration.nbre_ligne; j++) {
						g.setColor(Color.WHITE);
						g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
					}
					
				}
				for (int i = 0; i < intrus.size(); i++) {
					if(intrus.get(i).active=true)
					{
						if (i == n && joueurActif == 1 ) {
							
							g.setColor(Color.green);
							g.fillRect(x, y, i, i);(intrus.get(i).x*cellWidth,intrus.get(i).y*cellHeight, cellWidth, cellHeight);
						}
						intrus.get(i).draw(g);
					}
				}
				for (int i = 0; i < robots.size(); i++) {
					if (i == n && joueurActif ==2) {
						
						g.setColor(Color.green);
						g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
					}
					robots.get(i).draw(g);
				}
				for (int i = 0; i < obstacles.size(); i++) {
					
					obstacles.get(i).draw(g);
				}
				for (int i = 0; i < sacs.size(); i++) {
					
					sacs.get(i).draw(g);
				}
				/**for (int i = 0; i < sorties.size(); i++) {
					
					sorties.get(i).draw(g);
				}**/
			}
		}
		
		
		
		int n = -1 ;
		@Override
		public void keyTyped(KeyEvent e) {
			
			
			if (joueurActif == 1 && jeuArrete ) {
				if (robots.size() == 1) {
					n = 0;
				}
				if (n != -1) {
					
					Robot robot =  robots.get(n);
					switch (e.getKeyChar()) {
					case 'd': robot.TournerD();break;
					case 'q':robot.TournerG();break;
					case 'z':robot.TournerH();break;
					case 's':robot.TournerB();break;
					default:
						throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
					}
					joueurActif = 2 ;
					jeuArrete = false;
					n=-1;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
				
				
			}
			
				
				else if (joueurActif == 2 && jeuArrete ) {
					if (intrus.size() == 1 ) {
						n=0;
					}
					if (n != -1) {
						Intru intru =  intrus.get(n);
						switch (e.getKeyChar()) {
						case 'd': intru.TournerD();break;
						case 'q':intru.TournerG();break;
						case 'z':intru.TournerH();break;
						case 's':intru.TournerB();break;
						}
						joueurActif = 1 ;
						jeuArrete=false;
						n=-1;
					}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
					
			}	
			
		}
		@Override
		public void keyPressed(KeyEvent e) {
			// TODO Auto-generated method stub
			
		}
		@Override
		public void keyReleased(KeyEvent e) {
			// TODO Auto-generated method stub
			
		}
		@Override
		public void mouseClicked(MouseEvent e) {
			jeuArrete = true;
			n=-1;
			if (jeuArrete && (intrus.size() != 1 || robots.size() != 1)) {
				int colonne = e.getX()/cellWidth ;
				int ligne = e.getY() / cellWidth ;
				Point point = new Point(ligne,colonne);
				//System.out.println(point);
				if (joueurActif == 1  ) {
					for (int i = 0; i < robots.size(); i++) {
						if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
							n=i;
						}
					}
					if (n == -1 ) {
						JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
					}
					
				}
				if (joueurActif == 2  ) {
					for (int i = 0; i < intrus.size(); i++) {
						if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
							n=i;
						}
					}
					if (n == -1 ) {
						JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
					}
				}
				
			}
			
			
		}
		@Override
		public void mousePressed(MouseEvent e) {
			// TODO Auto-generated method stub
			
		}
		@Override
		public void mouseReleased(MouseEvent e) {
			// TODO Auto-generated method stub
			
		}
		@Override
		public void mouseEntered(MouseEvent e) {
			// TODO Auto-generated method stub
			
		}
		@Override
		public void mouseExited(MouseEvent e) {
			// TODO Auto-generated method stub
			
		}
		
		
		
		//verifier avant de quitter

		@Override
		public void windowActivated(WindowEvent e) {
			// TODO Auto-generated method stub
			
		}

		@Override
		public void windowClosed(WindowEvent e) {
			// TODO Auto-generated method stub
			
		}

		@Override
		public void windowClosing(WindowEvent e) {
			// TODO Auto-generated method stub
			exit();
			
			}
	
		void exit() {
			
			int a= JOptionPane.showConfirmDialog(null, "Clicker sur \"oui \" pour quitter vers le menu principal", "Quit options", JOptionPane.YES_NO_OPTION);
			if (a==JOptionPane.YES_OPTION) {
				dispose();
				Menu window = new Menu();
				window.main(null);
				
			}
			
			
			
		}
		

		@Override
		public void windowDeactivated(WindowEvent e) {
			// TODO Auto-generated method stub
			
		}

		@Override
		public void windowDeiconified(WindowEvent e) {
			// TODO Auto-generated method stub
			
		}

		@Override
		public void windowIconified(WindowEvent e) {
			// TODO Auto-generated method stub
			
		}

		@Override
		public void windowOpened(WindowEvent e) {
			// TODO Auto-generated method stub
			
		}
		
	}
}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2020-09-17 08:15:18.010
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2020-09-17 08:15:18.014
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-17 08:15:18.858
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.GridBagLayout;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.event.WindowEvent;
import java.awt.event.WindowListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import java.awt.GridBagConstraints;
import java.awt.Insets;
import java.awt.Component;
import javax.swing.Box;

public class Jeu extends JFrame{
	JLabel label;
	JPanel panel = new JPanel();
	JLabel lblNewLabel = new JLabel("Time :");
	JLabel lblNewLabel_1 = new JLabel("Sacs restants :");
	JLabel lblNewLabel_2 = new JLabel("Intrus restants :");
	JLabel lblNewLabel_3 = new JLabel("Robots :");
	private Component verticalStrut;
	private final Component horizontalStrut = Box.createHorizontalStrut(20);
	private final Component horizontalStrut_1 = Box.createHorizontalStrut(20);
	public Jeu(ConfigurationModel configuration) {
		super("Jeu");
		setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);
		getContentPane().setLayout(new BorderLayout());
		 label = new JLabel("Hello");
		 label.setForeground(Color.red);
		label.setVisible(true);
		getContentPane().add(label,BorderLayout.SOUTH);
		getContentPane().add(new Map(configuration),BorderLayout.CENTER);
		getContentPane().add(panel, BorderLayout.NORTH);
		GridBagLayout gbl_panel = new GridBagLayout();
		gbl_panel.columnWidths = new int[]{52, 0, 0, 0, 0, 56, 0};
		gbl_panel.rowHeights = new int[]{0, 0, 0, 16, 0};
		gbl_panel.columnWeights = new double[]{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, Double.MIN_VALUE};
		gbl_panel.rowWeights = new double[]{0.0, 0.0, 0.0, 0.0, Double.MIN_VALUE};
		panel.setLayout(gbl_panel);
		
		verticalStrut = Box.createVerticalStrut(20);
		GridBagConstraints gbc_verticalStrut = new GridBagConstraints();
		gbc_verticalStrut.insets = new Insets(0, 0, 5, 5);
		gbc_verticalStrut.gridx = 0;
		gbc_verticalStrut.gridy = 0;
		panel.add(verticalStrut, gbc_verticalStrut);
		
		//JLabel lblNewLabel = new JLabel("Time :");
		GridBagConstraints gbc_lblNewLabel = new GridBagConstraints();
		gbc_lblNewLabel.insets = new Insets(0, 0, 5, 5);
		gbc_lblNewLabel.anchor = GridBagConstraints.NORTHWEST;
		gbc_lblNewLabel.gridx = 0;
		gbc_lblNewLabel.gridy = 1;
		panel.add(lblNewLabel, gbc_lblNewLabel);
		
		
		
		
		//lblNewLabel_1 = new JLabel("Sacs restants :");
		GridBagConstraints gbc_lblNewLabel_1 = new GridBagConstraints();
		gbc_lblNewLabel_1.insets = new Insets(0, 0, 5, 5);
		gbc_lblNewLabel_1.gridx = 0;
		gbc_lblNewLabel_1.gridy = 2;
		panel.add(lblNewLabel_1, gbc_lblNewLabel_1);
		
		GridBagConstraints gbc_horizontalStrut = new GridBagConstraints();
		gbc_horizontalStrut.insets = new Insets(0, 0, 5, 5);
		gbc_horizontalStrut.gridx = 1;
		gbc_horizontalStrut.gridy = 2;
		panel.add(horizontalStrut, gbc_horizontalStrut);
		
		//lblNewLabel_2 = new JLabel("nbre d'Intrus restants :");
		GridBagConstraints gbc_lblNewLabel_2 = new GridBagConstraints();
		gbc_lblNewLabel_2.insets = new Insets(0, 0, 5, 5);
		gbc_lblNewLabel_2.gridx = 2;
		gbc_lblNewLabel_2.gridy = 2;
		panel.add(lblNewLabel_2, gbc_lblNewLabel_2);
		
		GridBagConstraints gbc_horizontalStrut_1 = new GridBagConstraints();
		gbc_horizontalStrut_1.insets = new Insets(0, 0, 5, 5);
		gbc_horizontalStrut_1.gridx = 3;
		gbc_horizontalStrut_1.gridy = 2;
		panel.add(horizontalStrut_1, gbc_horizontalStrut_1);
		
		//lblNewLabel_3 = new JLabel("nbre de robots :");
		GridBagConstraints gbc_lblNewLabel_3 = new GridBagConstraints();
		gbc_lblNewLabel_3.insets = new Insets(0, 0, 5, 5);
		gbc_lblNewLabel_3.gridx = 4;
		gbc_lblNewLabel_3.gridy = 2;
		panel.add(lblNewLabel_3, gbc_lblNewLabel_3);
		pack();
		setLocationRelativeTo(null);
		setResizable(false);
		setVisible(true);
		
	}
	private class Map extends JPanel implements KeyListener,MouseListener,WindowListener {
		int width,height,cellWidth,cellHeight;
		private ConfigurationModel configuration ;
		private Vector<Robot> robots = new Vector<Robot>();
		private Vector<Intru> intrus = new Vector<Intru>();
		private Vector<Sac> sacs = new Vector<Sac>();
		private Vector<Obstacle> obstacles = new Vector<Obstacle>();
		private Vector<Sortie> sorties = new Vector<Sortie>();
		private int joueurActif ;
		private boolean jeuArrete;
		
		public Map(ConfigurationModel configuration) {
			this.configuration = configuration ; 
			joueurActif = 1;
			jeuArrete = true;
			width=getWidth();
			height=getHeight();
			cellWidth =40;
			cellHeight =40;
			prepare();
			changerTour();
			calculertemps();
			lblNewLabel_1.setText("Sacs restants: "+ sacs.size());
			lblNewLabel_2.setText("Intrus restants: "+intrus.size());
			lblNewLabel_3.setText("Robots: "+ robots.size());
			//afficher();
			this.addKeyListener(this);
			this.addMouseListener(this);
			addWindowListener(this);
	        this.setFocusable(true);
	        this.requestFocusInWindow();
	        
	        
	         
		}
		
		
		
		
	/*	//Afficher le nombre de robots, intrus et sacs
		private void afficher() {

			Timer myTimer2 = new Timer();
			TimerTask task2= new TimerTask() {
				int s=0;
				@Override
				public void run() {
					s++;
					int x1=sacs.size();
					int x2=intrus.size();
					int x3=robots.size();
					lblNewLabel_1.setText("Sacs restants: "+ x1);
					lblNewLabel_2.setText("Intrus restants: "+ x2);
					lblNewLabel_3.setText("Robots: "+ x3);
					//System.out.println(sacs.size());
				}
			};
			myTimer2.scheduleAtFixedRate(task2, 1000, 1000);
		}
		*/
		
		//Calculer le temps passé
		private void calculertemps() {
			//System.out.println("temps");
			
			Timer myTimer1 = new Timer();
			TimerTask task1= new TimerTask() {
				int SecondesPassed1 = 0;
				int min=0,heu=0;
				@Override
				public void run() {
					if (intrus.size()!=0) {
						SecondesPassed1 ++;  
					}
					
					String ch ="";
					
					if (SecondesPassed1 ==60) {
						min+=1;
						SecondesPassed1=0;
					}
					if (min==60) {
						heu+=1;
						min=0;
					}
					//System.out.println("Time: "+ SecondesPassed1);
					
					if (SecondesPassed1 / 10 == 0 && min/ 10==0 ) {
						ch="0"+heu+" : "+"0"+min+" : "+"0"+SecondesPassed1;
					}
					if (SecondesPassed1 / 10 != 0 && min/ 10==0) {
						ch="0"+heu+" : "+"0"+min+" : "+SecondesPassed1;
					}
					if (SecondesPassed1 / 10 == 0 && min/ 10!=0) {
						ch="0"+heu+" : "+min+" : "+"0"+SecondesPassed1;
					}
					
					if (SecondesPassed1 / 10 != 0 && min/ 10!=0) {
						ch="0"+heu+" : "+min+" : "+SecondesPassed1; 
					}
					lblNewLabel.setText("Time: " + ch );
					
					
				}
			};
			
			
				myTimer1.scheduleAtFixedRate(task1, 1000, 1000);
			
		
			
			
			
		}
		
		
		
		// Changer automatiquement le tour chaque 5 secondes
		private void changerTour()
		{
			
			Timer timer = new Timer();
			TimerTask  timerTask = new TimerTask() {
				int secondPassed = 0 ;
				@Override
				public void run() {
					secondPassed ++ ; 
					if (!jeuArrete) {
						//System.out.println("Il reste "+(5-secondPassed)+" secondes pourque le joueur " + joueurActif + " joue son coup !");
						label.setText("Il reste "+(5-secondPassed)+" secondes pourque le joueur " + joueurActif + " joue son coup !  .. Cliquer pour prendre le coup ! ..");
						if (secondPassed == 5 && joueurActif == 1) {
							secondPassed =0;
							joueurActif =2;
						}
						if (secondPassed == 5 && joueurActif == 2) {
							secondPassed =0;
							joueurActif =1;
						}
					}
					if (jeuArrete) {
						secondPassed = 0 ;
						label.setText("Joueur "+joueurActif+" en train de jouer !  .. Choisir une direction .. ");
					}
					
				}
			};
			timer.scheduleAtFixedRate(timerTask, 1000, 1000);
		}
		// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
		private void prepare()
		
		{
			for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
				int x= configuration.Emplac_Intrus.get(i).x;
				int y= configuration.Emplac_Intrus.get(i).y;
				Intru intru = new Intru(y, x, 1000);
				intrus.add(intru);
				MoveIntrus moveIntrus =new MoveIntrus(intru);
				moveIntrus.start();
			}
			for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
				int x= configuration.Emplac_Robots.get(i).x;
				int y= configuration.Emplac_Robots.get(i).y;
				Robot robot = new Robot(y,x, 500);
				robots.add(robot);
				MoveRobots moveRobots = new MoveRobots(robot);
				moveRobots.start();
			}
			for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
				int x= configuration.Emplac_Obstacle.get(i).x;
				int y= configuration.Emplac_Obstacle.get(i).y;
				Obstacle obstacle = new Obstacle(y, x);
				obstacles.add(obstacle);
			}
			for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
				int x= configuration.Emplac_Sac.get(i).x;
				int y= configuration.Emplac_Sac.get(i).y;
				Sac sac = new Sac(y, x);
				sacs.add(sac);
			}
			for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
				int x= configuration.Emplac_Sortie.get(i).x;
				int y= configuration.Emplac_Sortie.get(i).y;
				Sortie sortie = new Sortie(y, x);
				sorties.add(sortie);
			}
		}
		// verifier si p1 est adjacent à p2
		private boolean EstAdjacent(Point p1,Point p2)
		{
			if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
			((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
			return true;
			else return false;
		}
		private boolean MovementValide(Point p , char direction) {
			Point pa = null;
			switch (direction) {
			case 'D': pa = new Point(p.x+1,p.y);break;
			case 'G': pa = new Point(p.x-1,p.y);break;
			case 'B': pa = new Point(p.x,p.y+1);break;
			case 'H': pa = new Point(p.x,p.y-1);break;
			default:
				break;
			}
			if (pa != null) {
				for (int i = 0; i < obstacles.size(); i++) {
					if (obstacles.get(i).x == pa.x && obstacles.get(i).y== pa.y ) {
						return false;
					}
				}
				for (int i = 0; i < sacs.size(); i++) {
					if (sacs.get(i).x == pa.x && sacs.get(i).y== pa.y ) {
						return false;
					}
				}
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == pa.x && intrus.get(i).y== pa.y ) {
						return false;
					}
				}
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == pa.x && robots.get(i).y== pa.y ) {
						return false;
					}
				}
				for (int i = 0; i < sorties.size(); i++) {
					if (sorties.get(i).x == pa.x && sorties.get(i).y== pa.y ) {
						return false;
					}
				}
			}
			
			return true;
		}

		
		public class MoveIntrus extends Thread 
		{
			Intru intru ;
			MoveIntrus(Intru intru)
			{
				this.intru=intru;
			}
			@Override
			public void run() {
			//	int pas =0;
				while(true)
				{	//  un intru prend un sac 
					if (jeuArrete) {
					//	pas = 0 ;
						try {
							sleep(1000);
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
					}
					else 
					{
						// un intru prend un sac
						for (int i = 0; i < sacs.size(); i++) {
							if (EstAdjacent(intru, sacs.get(i))) {
								if (intru.PrendSac(sacs.get(i))) {
									sacs.remove(sacs.get(i));
									System.out.println(sacs.size());
									lblNewLabel_1.setText("Sacs restants: "+ sacs.size());
									
								}
																}
						} 
						//un robot attrape un intru 
						for (int i = 0; i < robots.size(); i++) {
							
							if (EstAdjacent(intru, robots.get(i)) )
								{
									for (int j = 0; j < intru.sacs.size(); j++) {
										
										sacs.add(intru.sacs.get(j));
										lblNewLabel_1.setText("Sacs restants: "+ sacs.size());
										
									}
									intru.retournerSac();
									intrus.remove(intru);
									lblNewLabel_2.setText("Intrus restants: "+intrus.size());
								}
						}
						// un intru sort à partir d'une sortie 
						for (int i = 0; i < sorties.size(); i++) {
							
							if (EstAdjacent(intru, sorties.get(i)) )
								{
									intrus.remove(intru);
									lblNewLabel_2.setText("Intrus restants: "+intrus.size());
								}
						}
						
						// le mouvement d'un intru d'une case à une autre
						if (intru.active==false) interrupt();
						
							
							if (MovementValide(intru, intru.direction))
							{
								intru.move();
								repaint();
								try {
									sleep(1000);
								} catch (InterruptedException e) {
									// TODO Auto-generated catch block
									e.printStackTrace();
								}
								
							}
						
					}
				
						
				}
							
				}
							
			}
		class MoveRobots extends Thread 
		{
			Robot robot;
			public MoveRobots(Robot robot) {
				this.robot = robot ;
			}

			@Override
			public void run() {
				// pas = 0;
				while(true)
				{
					if (jeuArrete) {
						//pas =0;
						try {
							sleep(1000);
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
					}
					else {
						
						// le mouvement d'un robot d'une case à une autre
						if (MovementValide(robot, robot.direction))
						{
							robot.move();
							repaint();
							
							try {
								//pas++;
								sleep(500);
								//if (pas==3) {
									//jeuArrete = true;
								//}
								
								
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						
					}
					
				}
							
				}
					
			}
		
		// dimensionner la JPanel
		@Override
		public Dimension getPreferredSize() {
			return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
			}
		// dessiner tous les objects 
		@Override
		protected void paintComponent(Graphics g) {
			super.paintComponent(g);
			
			if (intrus.size() == 0 )
			{
				jeuArrete = true;
				label.setText("le jeu est terminé !");
				ImageIcon imageIcon=new ImageIcon("resources\\GameOver.jpg");
				Image image = imageIcon.getImage();
				g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
				/*for (Thread t : Thread.getAllStackTraces().keySet()) 
				{  if (t.getState()==Thread.State.RUNNABLE) 
				     t.interrupt(); 
				} */

				
				repaint();
			}
			else {
				for (int i = 0; i < configuration.nbre_colonne; i++) {
					for (int j = 0; j < configuration.nbre_ligne; j++) {
						g.setColor(Color.WHITE);
						g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
					}
					
				}
				for (int i = 0; i < intrus.size(); i++) {
					if(intrus.get(i).active=true)
					{
						if (i == n && joueurActif == 1 ) {
							
							g.setColor(Color.green);
							g.fillRect(x, y, i, i);(intrus.get(i).x*cellWidth,intrus.get(i).y*cellHeight, cellWidth, cellHeight);
						}
						intrus.get(i).draw(g);
					}
				}
				for (int i = 0; i < robots.size(); i++) {
					if (i == n && joueurActif ==2) {
						
						g.setColor(Color.green);
						g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
					}
					robots.get(i).draw(g);
				}
				for (int i = 0; i < obstacles.size(); i++) {
					
					obstacles.get(i).draw(g);
				}
				for (int i = 0; i < sacs.size(); i++) {
					
					sacs.get(i).draw(g);
				}
				/**for (int i = 0; i < sorties.size(); i++) {
					
					sorties.get(i).draw(g);
				}**/
			}
		}
		
		
		
		int n = -1 ;
		@Override
		public void keyTyped(KeyEvent e) {
			
			
			if (joueurActif == 1 && jeuArrete ) {
				if (robots.size() == 1) {
					n = 0;
				}
				if (n != -1) {
					
					Robot robot =  robots.get(n);
					switch (e.getKeyChar()) {
					case 'd': robot.TournerD();break;
					case 'q':robot.TournerG();break;
					case 'z':robot.TournerH();break;
					case 's':robot.TournerB();break;
					default:
						throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
					}
					joueurActif = 2 ;
					jeuArrete = false;
					n=-1;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
				
				
			}
			
				
				else if (joueurActif == 2 && jeuArrete ) {
					if (intrus.size() == 1 ) {
						n=0;
					}
					if (n != -1) {
						Intru intru =  intrus.get(n);
						switch (e.getKeyChar()) {
						case 'd': intru.TournerD();break;
						case 'q':intru.TournerG();break;
						case 'z':intru.TournerH();break;
						case 's':intru.TournerB();break;
						}
						joueurActif = 1 ;
						jeuArrete=false;
						n=-1;
					}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
					
			}	
			
		}
		@Override
		public void keyPressed(KeyEvent e) {
			// TODO Auto-generated method stub
			
		}
		@Override
		public void keyReleased(KeyEvent e) {
			// TODO Auto-generated method stub
			
		}
		@Override
		public void mouseClicked(MouseEvent e) {
			jeuArrete = true;
			n=-1;
			if (jeuArrete && (intrus.size() != 1 || robots.size() != 1)) {
				int colonne = e.getX()/cellWidth ;
				int ligne = e.getY() / cellWidth ;
				Point point = new Point(ligne,colonne);
				//System.out.println(point);
				if (joueurActif == 1  ) {
					for (int i = 0; i < robots.size(); i++) {
						if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
							n=i;
						}
					}
					if (n == -1 ) {
						JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
					}
					
				}
				if (joueurActif == 2  ) {
					for (int i = 0; i < intrus.size(); i++) {
						if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
							n=i;
						}
					}
					if (n == -1 ) {
						JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
					}
				}
				
			}
			
			
		}
		@Override
		public void mousePressed(MouseEvent e) {
			// TODO Auto-generated method stub
			
		}
		@Override
		public void mouseReleased(MouseEvent e) {
			// TODO Auto-generated method stub
			
		}
		@Override
		public void mouseEntered(MouseEvent e) {
			// TODO Auto-generated method stub
			
		}
		@Override
		public void mouseExited(MouseEvent e) {
			// TODO Auto-generated method stub
			
		}
		
		
		
		//verifier avant de quitter

		@Override
		public void windowActivated(WindowEvent e) {
			// TODO Auto-generated method stub
			
		}

		@Override
		public void windowClosed(WindowEvent e) {
			// TODO Auto-generated method stub
			
		}

		@Override
		public void windowClosing(WindowEvent e) {
			// TODO Auto-generated method stub
			exit();
			
			}
	
		void exit() {
			
			int a= JOptionPane.showConfirmDialog(null, "Clicker sur \"oui \" pour quitter vers le menu principal", "Quit options", JOptionPane.YES_NO_OPTION);
			if (a==JOptionPane.YES_OPTION) {
				dispose();
				Menu window = new Menu();
				window.main(null);
				
			}
			
			
			
		}
		

		@Override
		public void windowDeactivated(WindowEvent e) {
			// TODO Auto-generated method stub
			
		}

		@Override
		public void windowDeiconified(WindowEvent e) {
			// TODO Auto-generated method stub
			
		}

		@Override
		public void windowIconified(WindowEvent e) {
			// TODO Auto-generated method stub
			
		}

		@Override
		public void windowOpened(WindowEvent e) {
			// TODO Auto-generated method stub
			
		}
		
	}
}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-09-17 08:15:18.862
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-09-17 08:15:18.866
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-17 08:15:21.021
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.GridBagLayout;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.event.WindowEvent;
import java.awt.event.WindowListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import java.awt.GridBagConstraints;
import java.awt.Insets;
import java.awt.Component;
import javax.swing.Box;

public class Jeu extends JFrame{
	JLabel label;
	JPanel panel = new JPanel();
	JLabel lblNewLabel = new JLabel("Time :");
	JLabel lblNewLabel_1 = new JLabel("Sacs restants :");
	JLabel lblNewLabel_2 = new JLabel("Intrus restants :");
	JLabel lblNewLabel_3 = new JLabel("Robots :");
	private Component verticalStrut;
	private final Component horizontalStrut = Box.createHorizontalStrut(20);
	private final Component horizontalStrut_1 = Box.createHorizontalStrut(20);
	public Jeu(ConfigurationModel configuration) {
		super("Jeu");
		setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);
		getContentPane().setLayout(new BorderLayout());
		 label = new JLabel("Hello");
		 label.setForeground(Color.red);
		label.setVisible(true);
		getContentPane().add(label,BorderLayout.SOUTH);
		getContentPane().add(new Map(configuration),BorderLayout.CENTER);
		getContentPane().add(panel, BorderLayout.NORTH);
		GridBagLayout gbl_panel = new GridBagLayout();
		gbl_panel.columnWidths = new int[]{52, 0, 0, 0, 0, 56, 0};
		gbl_panel.rowHeights = new int[]{0, 0, 0, 16, 0};
		gbl_panel.columnWeights = new double[]{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, Double.MIN_VALUE};
		gbl_panel.rowWeights = new double[]{0.0, 0.0, 0.0, 0.0, Double.MIN_VALUE};
		panel.setLayout(gbl_panel);
		
		verticalStrut = Box.createVerticalStrut(20);
		GridBagConstraints gbc_verticalStrut = new GridBagConstraints();
		gbc_verticalStrut.insets = new Insets(0, 0, 5, 5);
		gbc_verticalStrut.gridx = 0;
		gbc_verticalStrut.gridy = 0;
		panel.add(verticalStrut, gbc_verticalStrut);
		
		//JLabel lblNewLabel = new JLabel("Time :");
		GridBagConstraints gbc_lblNewLabel = new GridBagConstraints();
		gbc_lblNewLabel.insets = new Insets(0, 0, 5, 5);
		gbc_lblNewLabel.anchor = GridBagConstraints.NORTHWEST;
		gbc_lblNewLabel.gridx = 0;
		gbc_lblNewLabel.gridy = 1;
		panel.add(lblNewLabel, gbc_lblNewLabel);
		
		
		
		
		//lblNewLabel_1 = new JLabel("Sacs restants :");
		GridBagConstraints gbc_lblNewLabel_1 = new GridBagConstraints();
		gbc_lblNewLabel_1.insets = new Insets(0, 0, 5, 5);
		gbc_lblNewLabel_1.gridx = 0;
		gbc_lblNewLabel_1.gridy = 2;
		panel.add(lblNewLabel_1, gbc_lblNewLabel_1);
		
		GridBagConstraints gbc_horizontalStrut = new GridBagConstraints();
		gbc_horizontalStrut.insets = new Insets(0, 0, 5, 5);
		gbc_horizontalStrut.gridx = 1;
		gbc_horizontalStrut.gridy = 2;
		panel.add(horizontalStrut, gbc_horizontalStrut);
		
		//lblNewLabel_2 = new JLabel("nbre d'Intrus restants :");
		GridBagConstraints gbc_lblNewLabel_2 = new GridBagConstraints();
		gbc_lblNewLabel_2.insets = new Insets(0, 0, 5, 5);
		gbc_lblNewLabel_2.gridx = 2;
		gbc_lblNewLabel_2.gridy = 2;
		panel.add(lblNewLabel_2, gbc_lblNewLabel_2);
		
		GridBagConstraints gbc_horizontalStrut_1 = new GridBagConstraints();
		gbc_horizontalStrut_1.insets = new Insets(0, 0, 5, 5);
		gbc_horizontalStrut_1.gridx = 3;
		gbc_horizontalStrut_1.gridy = 2;
		panel.add(horizontalStrut_1, gbc_horizontalStrut_1);
		
		//lblNewLabel_3 = new JLabel("nbre de robots :");
		GridBagConstraints gbc_lblNewLabel_3 = new GridBagConstraints();
		gbc_lblNewLabel_3.insets = new Insets(0, 0, 5, 5);
		gbc_lblNewLabel_3.gridx = 4;
		gbc_lblNewLabel_3.gridy = 2;
		panel.add(lblNewLabel_3, gbc_lblNewLabel_3);
		pack();
		setLocationRelativeTo(null);
		setResizable(false);
		setVisible(true);
		
	}
	private class Map extends JPanel implements KeyListener,MouseListener,WindowListener {
		int width,height,cellWidth,cellHeight;
		private ConfigurationModel configuration ;
		private Vector<Robot> robots = new Vector<Robot>();
		private Vector<Intru> intrus = new Vector<Intru>();
		private Vector<Sac> sacs = new Vector<Sac>();
		private Vector<Obstacle> obstacles = new Vector<Obstacle>();
		private Vector<Sortie> sorties = new Vector<Sortie>();
		private int joueurActif ;
		private boolean jeuArrete;
		
		public Map(ConfigurationModel configuration) {
			this.configuration = configuration ; 
			joueurActif = 1;
			jeuArrete = true;
			width=getWidth();
			height=getHeight();
			cellWidth =40;
			cellHeight =40;
			prepare();
			changerTour();
			calculertemps();
			lblNewLabel_1.setText("Sacs restants: "+ sacs.size());
			lblNewLabel_2.setText("Intrus restants: "+intrus.size());
			lblNewLabel_3.setText("Robots: "+ robots.size());
			//afficher();
			this.addKeyListener(this);
			this.addMouseListener(this);
			addWindowListener(this);
	        this.setFocusable(true);
	        this.requestFocusInWindow();
	        
	        
	         
		}
		
		
		
		
	/*	//Afficher le nombre de robots, intrus et sacs
		private void afficher() {

			Timer myTimer2 = new Timer();
			TimerTask task2= new TimerTask() {
				int s=0;
				@Override
				public void run() {
					s++;
					int x1=sacs.size();
					int x2=intrus.size();
					int x3=robots.size();
					lblNewLabel_1.setText("Sacs restants: "+ x1);
					lblNewLabel_2.setText("Intrus restants: "+ x2);
					lblNewLabel_3.setText("Robots: "+ x3);
					//System.out.println(sacs.size());
				}
			};
			myTimer2.scheduleAtFixedRate(task2, 1000, 1000);
		}
		*/
		
		//Calculer le temps passé
		private void calculertemps() {
			//System.out.println("temps");
			
			Timer myTimer1 = new Timer();
			TimerTask task1= new TimerTask() {
				int SecondesPassed1 = 0;
				int min=0,heu=0;
				@Override
				public void run() {
					if (intrus.size()!=0) {
						SecondesPassed1 ++;  
					}
					
					String ch ="";
					
					if (SecondesPassed1 ==60) {
						min+=1;
						SecondesPassed1=0;
					}
					if (min==60) {
						heu+=1;
						min=0;
					}
					//System.out.println("Time: "+ SecondesPassed1);
					
					if (SecondesPassed1 / 10 == 0 && min/ 10==0 ) {
						ch="0"+heu+" : "+"0"+min+" : "+"0"+SecondesPassed1;
					}
					if (SecondesPassed1 / 10 != 0 && min/ 10==0) {
						ch="0"+heu+" : "+"0"+min+" : "+SecondesPassed1;
					}
					if (SecondesPassed1 / 10 == 0 && min/ 10!=0) {
						ch="0"+heu+" : "+min+" : "+"0"+SecondesPassed1;
					}
					
					if (SecondesPassed1 / 10 != 0 && min/ 10!=0) {
						ch="0"+heu+" : "+min+" : "+SecondesPassed1; 
					}
					lblNewLabel.setText("Time: " + ch );
					
					
				}
			};
			
			
				myTimer1.scheduleAtFixedRate(task1, 1000, 1000);
			
		
			
			
			
		}
		
		
		
		// Changer automatiquement le tour chaque 5 secondes
		private void changerTour()
		{
			
			Timer timer = new Timer();
			TimerTask  timerTask = new TimerTask() {
				int secondPassed = 0 ;
				@Override
				public void run() {
					secondPassed ++ ; 
					if (!jeuArrete) {
						//System.out.println("Il reste "+(5-secondPassed)+" secondes pourque le joueur " + joueurActif + " joue son coup !");
						label.setText("Il reste "+(5-secondPassed)+" secondes pourque le joueur " + joueurActif + " joue son coup !  .. Cliquer pour prendre le coup ! ..");
						if (secondPassed == 5 && joueurActif == 1) {
							secondPassed =0;
							joueurActif =2;
						}
						if (secondPassed == 5 && joueurActif == 2) {
							secondPassed =0;
							joueurActif =1;
						}
					}
					if (jeuArrete) {
						secondPassed = 0 ;
						label.setText("Joueur "+joueurActif+" en train de jouer !  .. Choisir une direction .. ");
					}
					
				}
			};
			timer.scheduleAtFixedRate(timerTask, 1000, 1000);
		}
		// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
		private void prepare()
		
		{
			for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
				int x= configuration.Emplac_Intrus.get(i).x;
				int y= configuration.Emplac_Intrus.get(i).y;
				Intru intru = new Intru(y, x, 1000);
				intrus.add(intru);
				MoveIntrus moveIntrus =new MoveIntrus(intru);
				moveIntrus.start();
			}
			for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
				int x= configuration.Emplac_Robots.get(i).x;
				int y= configuration.Emplac_Robots.get(i).y;
				Robot robot = new Robot(y,x, 500);
				robots.add(robot);
				MoveRobots moveRobots = new MoveRobots(robot);
				moveRobots.start();
			}
			for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
				int x= configuration.Emplac_Obstacle.get(i).x;
				int y= configuration.Emplac_Obstacle.get(i).y;
				Obstacle obstacle = new Obstacle(y, x);
				obstacles.add(obstacle);
			}
			for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
				int x= configuration.Emplac_Sac.get(i).x;
				int y= configuration.Emplac_Sac.get(i).y;
				Sac sac = new Sac(y, x);
				sacs.add(sac);
			}
			for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
				int x= configuration.Emplac_Sortie.get(i).x;
				int y= configuration.Emplac_Sortie.get(i).y;
				Sortie sortie = new Sortie(y, x);
				sorties.add(sortie);
			}
		}
		// verifier si p1 est adjacent à p2
		private boolean EstAdjacent(Point p1,Point p2)
		{
			if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
			((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
			return true;
			else return false;
		}
		private boolean MovementValide(Point p , char direction) {
			Point pa = null;
			switch (direction) {
			case 'D': pa = new Point(p.x+1,p.y);break;
			case 'G': pa = new Point(p.x-1,p.y);break;
			case 'B': pa = new Point(p.x,p.y+1);break;
			case 'H': pa = new Point(p.x,p.y-1);break;
			default:
				break;
			}
			if (pa != null) {
				for (int i = 0; i < obstacles.size(); i++) {
					if (obstacles.get(i).x == pa.x && obstacles.get(i).y== pa.y ) {
						return false;
					}
				}
				for (int i = 0; i < sacs.size(); i++) {
					if (sacs.get(i).x == pa.x && sacs.get(i).y== pa.y ) {
						return false;
					}
				}
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == pa.x && intrus.get(i).y== pa.y ) {
						return false;
					}
				}
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == pa.x && robots.get(i).y== pa.y ) {
						return false;
					}
				}
				for (int i = 0; i < sorties.size(); i++) {
					if (sorties.get(i).x == pa.x && sorties.get(i).y== pa.y ) {
						return false;
					}
				}
			}
			
			return true;
		}

		
		public class MoveIntrus extends Thread 
		{
			Intru intru ;
			MoveIntrus(Intru intru)
			{
				this.intru=intru;
			}
			@Override
			public void run() {
			//	int pas =0;
				while(true)
				{	//  un intru prend un sac 
					if (jeuArrete) {
					//	pas = 0 ;
						try {
							sleep(1000);
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
					}
					else 
					{
						// un intru prend un sac
						for (int i = 0; i < sacs.size(); i++) {
							if (EstAdjacent(intru, sacs.get(i))) {
								if (intru.PrendSac(sacs.get(i))) {
									sacs.remove(sacs.get(i));
									System.out.println(sacs.size());
									lblNewLabel_1.setText("Sacs restants: "+ sacs.size());
									
								}
																}
						} 
						//un robot attrape un intru 
						for (int i = 0; i < robots.size(); i++) {
							
							if (EstAdjacent(intru, robots.get(i)) )
								{
									for (int j = 0; j < intru.sacs.size(); j++) {
										
										sacs.add(intru.sacs.get(j));
										lblNewLabel_1.setText("Sacs restants: "+ sacs.size());
										
									}
									intru.retournerSac();
									intrus.remove(intru);
									lblNewLabel_2.setText("Intrus restants: "+intrus.size());
								}
						}
						// un intru sort à partir d'une sortie 
						for (int i = 0; i < sorties.size(); i++) {
							
							if (EstAdjacent(intru, sorties.get(i)) )
								{
									intrus.remove(intru);
									lblNewLabel_2.setText("Intrus restants: "+intrus.size());
								}
						}
						
						// le mouvement d'un intru d'une case à une autre
						if (intru.active==false) interrupt();
						
							
							if (MovementValide(intru, intru.direction))
							{
								intru.move();
								repaint();
								try {
									sleep(1000);
								} catch (InterruptedException e) {
									// TODO Auto-generated catch block
									e.printStackTrace();
								}
								
							}
						
					}
				
						
				}
							
				}
							
			}
		class MoveRobots extends Thread 
		{
			Robot robot;
			public MoveRobots(Robot robot) {
				this.robot = robot ;
			}

			@Override
			public void run() {
				// pas = 0;
				while(true)
				{
					if (jeuArrete) {
						//pas =0;
						try {
							sleep(1000);
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
					}
					else {
						
						// le mouvement d'un robot d'une case à une autre
						if (MovementValide(robot, robot.direction))
						{
							robot.move();
							repaint();
							
							try {
								//pas++;
								sleep(500);
								//if (pas==3) {
									//jeuArrete = true;
								//}
								
								
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						
					}
					
				}
							
				}
					
			}
		
		// dimensionner la JPanel
		@Override
		public Dimension getPreferredSize() {
			return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
			}
		// dessiner tous les objects 
		@Override
		protected void paintComponent(Graphics g) {
			super.paintComponent(g);
			
			if (intrus.size() == 0 )
			{
				jeuArrete = true;
				label.setText("le jeu est terminé !");
				ImageIcon imageIcon=new ImageIcon("resources\\GameOver.jpg");
				Image image = imageIcon.getImage();
				g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
				/*for (Thread t : Thread.getAllStackTraces().keySet()) 
				{  if (t.getState()==Thread.State.RUNNABLE) 
				     t.interrupt(); 
				} */

				
				repaint();
			}
			else {
				for (int i = 0; i < configuration.nbre_colonne; i++) {
					for (int j = 0; j < configuration.nbre_ligne; j++) {
						g.setColor(Color.WHITE);
						g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
					}
					
				}
				for (int i = 0; i < intrus.size(); i++) {
					if(intrus.get(i).active=true)
					{
						if (i == n && joueurActif == 1 ) {
							
							g.setColor(Color.green);
							g.fillRect(x, y, i, i);(intrus.get(i).x*cellWidth,intrus.get(i).y*cellHeight, cellWidth, cellHeight);
						}
						intrus.get(i).draw(g);
					}
				}
				for (int i = 0; i < robots.size(); i++) {
					if (i == n && joueurActif ==2) {
						
						g.setColor(Color.green);
						g.drawRect(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
					}
					robots.get(i).draw(g);
				}
				for (int i = 0; i < obstacles.size(); i++) {
					
					obstacles.get(i).draw(g);
				}
				for (int i = 0; i < sacs.size(); i++) {
					
					sacs.get(i).draw(g);
				}
				/**for (int i = 0; i < sorties.size(); i++) {
					
					sorties.get(i).draw(g);
				}**/
			}
		}
		
		
		
		int n = -1 ;
		@Override
		public void keyTyped(KeyEvent e) {
			
			
			if (joueurActif == 1 && jeuArrete ) {
				if (robots.size() == 1) {
					n = 0;
				}
				if (n != -1) {
					
					Robot robot =  robots.get(n);
					switch (e.getKeyChar()) {
					case 'd': robot.TournerD();break;
					case 'q':robot.TournerG();break;
					case 'z':robot.TournerH();break;
					case 's':robot.TournerB();break;
					default:
						throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
					}
					joueurActif = 2 ;
					jeuArrete = false;
					n=-1;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
				
				
			}
			
				
				else if (joueurActif == 2 && jeuArrete ) {
					if (intrus.size() == 1 ) {
						n=0;
					}
					if (n != -1) {
						Intru intru =  intrus.get(n);
						switch (e.getKeyChar()) {
						case 'd': intru.TournerD();break;
						case 'q':intru.TournerG();break;
						case 'z':intru.TournerH();break;
						case 's':intru.TournerB();break;
						}
						joueurActif = 1 ;
						jeuArrete=false;
						n=-1;
					}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
					
			}	
			
		}
		@Override
		public void keyPressed(KeyEvent e) {
			// TODO Auto-generated method stub
			
		}
		@Override
		public void keyReleased(KeyEvent e) {
			// TODO Auto-generated method stub
			
		}
		@Override
		public void mouseClicked(MouseEvent e) {
			jeuArrete = true;
			n=-1;
			if (jeuArrete && (intrus.size() != 1 || robots.size() != 1)) {
				int colonne = e.getX()/cellWidth ;
				int ligne = e.getY() / cellWidth ;
				Point point = new Point(ligne,colonne);
				//System.out.println(point);
				if (joueurActif == 1  ) {
					for (int i = 0; i < robots.size(); i++) {
						if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
							n=i;
						}
					}
					if (n == -1 ) {
						JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
					}
					
				}
				if (joueurActif == 2  ) {
					for (int i = 0; i < intrus.size(); i++) {
						if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
							n=i;
						}
					}
					if (n == -1 ) {
						JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
					}
				}
				
			}
			
			
		}
		@Override
		public void mousePressed(MouseEvent e) {
			// TODO Auto-generated method stub
			
		}
		@Override
		public void mouseReleased(MouseEvent e) {
			// TODO Auto-generated method stub
			
		}
		@Override
		public void mouseEntered(MouseEvent e) {
			// TODO Auto-generated method stub
			
		}
		@Override
		public void mouseExited(MouseEvent e) {
			// TODO Auto-generated method stub
			
		}
		
		
		
		//verifier avant de quitter

		@Override
		public void windowActivated(WindowEvent e) {
			// TODO Auto-generated method stub
			
		}

		@Override
		public void windowClosed(WindowEvent e) {
			// TODO Auto-generated method stub
			
		}

		@Override
		public void windowClosing(WindowEvent e) {
			// TODO Auto-generated method stub
			exit();
			
			}
	
		void exit() {
			
			int a= JOptionPane.showConfirmDialog(null, "Clicker sur \"oui \" pour quitter vers le menu principal", "Quit options", JOptionPane.YES_NO_OPTION);
			if (a==JOptionPane.YES_OPTION) {
				dispose();
				Menu window = new Menu();
				window.main(null);
				
			}
			
			
			
		}
		

		@Override
		public void windowDeactivated(WindowEvent e) {
			// TODO Auto-generated method stub
			
		}

		@Override
		public void windowDeiconified(WindowEvent e) {
			// TODO Auto-generated method stub
			
		}

		@Override
		public void windowIconified(WindowEvent e) {
			// TODO Auto-generated method stub
			
		}

		@Override
		public void windowOpened(WindowEvent e) {
			// TODO Auto-generated method stub
			
		}
		
	}
}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-09-17 08:15:21.025
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-09-17 08:15:21.029
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-17 08:15:38.117
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.GridBagLayout;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.event.WindowEvent;
import java.awt.event.WindowListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import java.awt.GridBagConstraints;
import java.awt.Insets;
import java.awt.Component;
import javax.swing.Box;

public class Jeu extends JFrame{
	JLabel label;
	JPanel panel = new JPanel();
	JLabel lblNewLabel = new JLabel("Time :");
	JLabel lblNewLabel_1 = new JLabel("Sacs restants :");
	JLabel lblNewLabel_2 = new JLabel("Intrus restants :");
	JLabel lblNewLabel_3 = new JLabel("Robots :");
	private Component verticalStrut;
	private final Component horizontalStrut = Box.createHorizontalStrut(20);
	private final Component horizontalStrut_1 = Box.createHorizontalStrut(20);
	public Jeu(ConfigurationModel configuration) {
		super("Jeu");
		setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);
		getContentPane().setLayout(new BorderLayout());
		 label = new JLabel("Hello");
		 label.setForeground(Color.red);
		label.setVisible(true);
		getContentPane().add(label,BorderLayout.SOUTH);
		getContentPane().add(new Map(configuration),BorderLayout.CENTER);
		getContentPane().add(panel, BorderLayout.NORTH);
		GridBagLayout gbl_panel = new GridBagLayout();
		gbl_panel.columnWidths = new int[]{52, 0, 0, 0, 0, 56, 0};
		gbl_panel.rowHeights = new int[]{0, 0, 0, 16, 0};
		gbl_panel.columnWeights = new double[]{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, Double.MIN_VALUE};
		gbl_panel.rowWeights = new double[]{0.0, 0.0, 0.0, 0.0, Double.MIN_VALUE};
		panel.setLayout(gbl_panel);
		
		verticalStrut = Box.createVerticalStrut(20);
		GridBagConstraints gbc_verticalStrut = new GridBagConstraints();
		gbc_verticalStrut.insets = new Insets(0, 0, 5, 5);
		gbc_verticalStrut.gridx = 0;
		gbc_verticalStrut.gridy = 0;
		panel.add(verticalStrut, gbc_verticalStrut);
		
		//JLabel lblNewLabel = new JLabel("Time :");
		GridBagConstraints gbc_lblNewLabel = new GridBagConstraints();
		gbc_lblNewLabel.insets = new Insets(0, 0, 5, 5);
		gbc_lblNewLabel.anchor = GridBagConstraints.NORTHWEST;
		gbc_lblNewLabel.gridx = 0;
		gbc_lblNewLabel.gridy = 1;
		panel.add(lblNewLabel, gbc_lblNewLabel);
		
		
		
		
		//lblNewLabel_1 = new JLabel("Sacs restants :");
		GridBagConstraints gbc_lblNewLabel_1 = new GridBagConstraints();
		gbc_lblNewLabel_1.insets = new Insets(0, 0, 5, 5);
		gbc_lblNewLabel_1.gridx = 0;
		gbc_lblNewLabel_1.gridy = 2;
		panel.add(lblNewLabel_1, gbc_lblNewLabel_1);
		
		GridBagConstraints gbc_horizontalStrut = new GridBagConstraints();
		gbc_horizontalStrut.insets = new Insets(0, 0, 5, 5);
		gbc_horizontalStrut.gridx = 1;
		gbc_horizontalStrut.gridy = 2;
		panel.add(horizontalStrut, gbc_horizontalStrut);
		
		//lblNewLabel_2 = new JLabel("nbre d'Intrus restants :");
		GridBagConstraints gbc_lblNewLabel_2 = new GridBagConstraints();
		gbc_lblNewLabel_2.insets = new Insets(0, 0, 5, 5);
		gbc_lblNewLabel_2.gridx = 2;
		gbc_lblNewLabel_2.gridy = 2;
		panel.add(lblNewLabel_2, gbc_lblNewLabel_2);
		
		GridBagConstraints gbc_horizontalStrut_1 = new GridBagConstraints();
		gbc_horizontalStrut_1.insets = new Insets(0, 0, 5, 5);
		gbc_horizontalStrut_1.gridx = 3;
		gbc_horizontalStrut_1.gridy = 2;
		panel.add(horizontalStrut_1, gbc_horizontalStrut_1);
		
		//lblNewLabel_3 = new JLabel("nbre de robots :");
		GridBagConstraints gbc_lblNewLabel_3 = new GridBagConstraints();
		gbc_lblNewLabel_3.insets = new Insets(0, 0, 5, 5);
		gbc_lblNewLabel_3.gridx = 4;
		gbc_lblNewLabel_3.gridy = 2;
		panel.add(lblNewLabel_3, gbc_lblNewLabel_3);
		pack();
		setLocationRelativeTo(null);
		setResizable(false);
		setVisible(true);
		
	}
	private class Map extends JPanel implements KeyListener,MouseListener,WindowListener {
		int width,height,cellWidth,cellHeight;
		private ConfigurationModel configuration ;
		private Vector<Robot> robots = new Vector<Robot>();
		private Vector<Intru> intrus = new Vector<Intru>();
		private Vector<Sac> sacs = new Vector<Sac>();
		private Vector<Obstacle> obstacles = new Vector<Obstacle>();
		private Vector<Sortie> sorties = new Vector<Sortie>();
		private int joueurActif ;
		private boolean jeuArrete;
		
		public Map(ConfigurationModel configuration) {
			this.configuration = configuration ; 
			joueurActif = 1;
			jeuArrete = true;
			width=getWidth();
			height=getHeight();
			cellWidth =40;
			cellHeight =40;
			prepare();
			changerTour();
			calculertemps();
			lblNewLabel_1.setText("Sacs restants: "+ sacs.size());
			lblNewLabel_2.setText("Intrus restants: "+intrus.size());
			lblNewLabel_3.setText("Robots: "+ robots.size());
			//afficher();
			this.addKeyListener(this);
			this.addMouseListener(this);
			addWindowListener(this);
	        this.setFocusable(true);
	        this.requestFocusInWindow();
	        
	        
	         
		}
		
		
		
		
	/*	//Afficher le nombre de robots, intrus et sacs
		private void afficher() {

			Timer myTimer2 = new Timer();
			TimerTask task2= new TimerTask() {
				int s=0;
				@Override
				public void run() {
					s++;
					int x1=sacs.size();
					int x2=intrus.size();
					int x3=robots.size();
					lblNewLabel_1.setText("Sacs restants: "+ x1);
					lblNewLabel_2.setText("Intrus restants: "+ x2);
					lblNewLabel_3.setText("Robots: "+ x3);
					//System.out.println(sacs.size());
				}
			};
			myTimer2.scheduleAtFixedRate(task2, 1000, 1000);
		}
		*/
		
		//Calculer le temps passé
		private void calculertemps() {
			//System.out.println("temps");
			
			Timer myTimer1 = new Timer();
			TimerTask task1= new TimerTask() {
				int SecondesPassed1 = 0;
				int min=0,heu=0;
				@Override
				public void run() {
					if (intrus.size()!=0) {
						SecondesPassed1 ++;  
					}
					
					String ch ="";
					
					if (SecondesPassed1 ==60) {
						min+=1;
						SecondesPassed1=0;
					}
					if (min==60) {
						heu+=1;
						min=0;
					}
					//System.out.println("Time: "+ SecondesPassed1);
					
					if (SecondesPassed1 / 10 == 0 && min/ 10==0 ) {
						ch="0"+heu+" : "+"0"+min+" : "+"0"+SecondesPassed1;
					}
					if (SecondesPassed1 / 10 != 0 && min/ 10==0) {
						ch="0"+heu+" : "+"0"+min+" : "+SecondesPassed1;
					}
					if (SecondesPassed1 / 10 == 0 && min/ 10!=0) {
						ch="0"+heu+" : "+min+" : "+"0"+SecondesPassed1;
					}
					
					if (SecondesPassed1 / 10 != 0 && min/ 10!=0) {
						ch="0"+heu+" : "+min+" : "+SecondesPassed1; 
					}
					lblNewLabel.setText("Time: " + ch );
					
					
				}
			};
			
			
				myTimer1.scheduleAtFixedRate(task1, 1000, 1000);
			
		
			
			
			
		}
		
		
		
		// Changer automatiquement le tour chaque 5 secondes
		private void changerTour()
		{
			
			Timer timer = new Timer();
			TimerTask  timerTask = new TimerTask() {
				int secondPassed = 0 ;
				@Override
				public void run() {
					secondPassed ++ ; 
					if (!jeuArrete) {
						//System.out.println("Il reste "+(5-secondPassed)+" secondes pourque le joueur " + joueurActif + " joue son coup !");
						label.setText("Il reste "+(5-secondPassed)+" secondes pourque le joueur " + joueurActif + " joue son coup !  .. Cliquer pour prendre le coup ! ..");
						if (secondPassed == 5 && joueurActif == 1) {
							secondPassed =0;
							joueurActif =2;
						}
						if (secondPassed == 5 && joueurActif == 2) {
							secondPassed =0;
							joueurActif =1;
						}
					}
					if (jeuArrete) {
						secondPassed = 0 ;
						label.setText("Joueur "+joueurActif+" en train de jouer !  .. Choisir une direction .. ");
					}
					
				}
			};
			timer.scheduleAtFixedRate(timerTask, 1000, 1000);
		}
		// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
		private void prepare()
		
		{
			for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
				int x= configuration.Emplac_Intrus.get(i).x;
				int y= configuration.Emplac_Intrus.get(i).y;
				Intru intru = new Intru(y, x, 1000);
				intrus.add(intru);
				MoveIntrus moveIntrus =new MoveIntrus(intru);
				moveIntrus.start();
			}
			for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
				int x= configuration.Emplac_Robots.get(i).x;
				int y= configuration.Emplac_Robots.get(i).y;
				Robot robot = new Robot(y,x, 500);
				robots.add(robot);
				MoveRobots moveRobots = new MoveRobots(robot);
				moveRobots.start();
			}
			for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
				int x= configuration.Emplac_Obstacle.get(i).x;
				int y= configuration.Emplac_Obstacle.get(i).y;
				Obstacle obstacle = new Obstacle(y, x);
				obstacles.add(obstacle);
			}
			for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
				int x= configuration.Emplac_Sac.get(i).x;
				int y= configuration.Emplac_Sac.get(i).y;
				Sac sac = new Sac(y, x);
				sacs.add(sac);
			}
			for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
				int x= configuration.Emplac_Sortie.get(i).x;
				int y= configuration.Emplac_Sortie.get(i).y;
				Sortie sortie = new Sortie(y, x);
				sorties.add(sortie);
			}
		}
		// verifier si p1 est adjacent à p2
		private boolean EstAdjacent(Point p1,Point p2)
		{
			if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
			((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
			return true;
			else return false;
		}
		private boolean MovementValide(Point p , char direction) {
			Point pa = null;
			switch (direction) {
			case 'D': pa = new Point(p.x+1,p.y);break;
			case 'G': pa = new Point(p.x-1,p.y);break;
			case 'B': pa = new Point(p.x,p.y+1);break;
			case 'H': pa = new Point(p.x,p.y-1);break;
			default:
				break;
			}
			if (pa != null) {
				for (int i = 0; i < obstacles.size(); i++) {
					if (obstacles.get(i).x == pa.x && obstacles.get(i).y== pa.y ) {
						return false;
					}
				}
				for (int i = 0; i < sacs.size(); i++) {
					if (sacs.get(i).x == pa.x && sacs.get(i).y== pa.y ) {
						return false;
					}
				}
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == pa.x && intrus.get(i).y== pa.y ) {
						return false;
					}
				}
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == pa.x && robots.get(i).y== pa.y ) {
						return false;
					}
				}
				for (int i = 0; i < sorties.size(); i++) {
					if (sorties.get(i).x == pa.x && sorties.get(i).y== pa.y ) {
						return false;
					}
				}
			}
			
			return true;
		}

		
		public class MoveIntrus extends Thread 
		{
			Intru intru ;
			MoveIntrus(Intru intru)
			{
				this.intru=intru;
			}
			@Override
			public void run() {
			//	int pas =0;
				while(true)
				{	//  un intru prend un sac 
					if (jeuArrete) {
					//	pas = 0 ;
						try {
							sleep(1000);
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
					}
					else 
					{
						// un intru prend un sac
						for (int i = 0; i < sacs.size(); i++) {
							if (EstAdjacent(intru, sacs.get(i))) {
								if (intru.PrendSac(sacs.get(i))) {
									sacs.remove(sacs.get(i));
									System.out.println(sacs.size());
									lblNewLabel_1.setText("Sacs restants: "+ sacs.size());
									
								}
																}
						} 
						//un robot attrape un intru 
						for (int i = 0; i < robots.size(); i++) {
							
							if (EstAdjacent(intru, robots.get(i)) )
								{
									for (int j = 0; j < intru.sacs.size(); j++) {
										
										sacs.add(intru.sacs.get(j));
										lblNewLabel_1.setText("Sacs restants: "+ sacs.size());
										
									}
									intru.retournerSac();
									intrus.remove(intru);
									lblNewLabel_2.setText("Intrus restants: "+intrus.size());
								}
						}
						// un intru sort à partir d'une sortie 
						for (int i = 0; i < sorties.size(); i++) {
							
							if (EstAdjacent(intru, sorties.get(i)) )
								{
									intrus.remove(intru);
									lblNewLabel_2.setText("Intrus restants: "+intrus.size());
								}
						}
						
						// le mouvement d'un intru d'une case à une autre
						if (intru.active==false) interrupt();
						
							
							if (MovementValide(intru, intru.direction))
							{
								intru.move();
								repaint();
								try {
									sleep(1000);
								} catch (InterruptedException e) {
									// TODO Auto-generated catch block
									e.printStackTrace();
								}
								
							}
						
					}
				
						
				}
							
				}
							
			}
		class MoveRobots extends Thread 
		{
			Robot robot;
			public MoveRobots(Robot robot) {
				this.robot = robot ;
			}

			@Override
			public void run() {
				// pas = 0;
				while(true)
				{
					if (jeuArrete) {
						//pas =0;
						try {
							sleep(1000);
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
					}
					else {
						
						// le mouvement d'un robot d'une case à une autre
						if (MovementValide(robot, robot.direction))
						{
							robot.move();
							repaint();
							
							try {
								//pas++;
								sleep(500);
								//if (pas==3) {
									//jeuArrete = true;
								//}
								
								
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						
					}
					
				}
							
				}
					
			}
		
		// dimensionner la JPanel
		@Override
		public Dimension getPreferredSize() {
			return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
			}
		// dessiner tous les objects 
		@Override
		protected void paintComponent(Graphics g) {
			super.paintComponent(g);
			
			if (intrus.size() == 0 )
			{
				jeuArrete = true;
				label.setText("le jeu est terminé !");
				ImageIcon imageIcon=new ImageIcon("resources\\GameOver.jpg");
				Image image = imageIcon.getImage();
				g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
				/*for (Thread t : Thread.getAllStackTraces().keySet()) 
				{  if (t.getState()==Thread.State.RUNNABLE) 
				     t.interrupt(); 
				} */

				
				repaint();
			}
			else {
				for (int i = 0; i < configuration.nbre_colonne; i++) {
					for (int j = 0; j < configuration.nbre_ligne; j++) {
						g.setColor(Color.WHITE);
						g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
					}
					
				}
				for (int i = 0; i < intrus.size(); i++) {
					if(intrus.get(i).active=true)
					{
						if (i == n && joueurActif == 1 ) {
							
							g.setColor(Color.green);
							g.fillRect(intrus.get(i).x*cellWidth,intrus.get(i).y*cellHeight, cellWidth, cellHeight);
						}
						intrus.get(i).draw(g);
					}
				}
				for (int i = 0; i < robots.size(); i++) {
					if (i == n && joueurActif ==2) {
						
						g.setColor(Color.green);
						g.fillRect(x, y, i, i);(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
					}
					robots.get(i).draw(g);
				}
				for (int i = 0; i < obstacles.size(); i++) {
					
					obstacles.get(i).draw(g);
				}
				for (int i = 0; i < sacs.size(); i++) {
					
					sacs.get(i).draw(g);
				}
				/**for (int i = 0; i < sorties.size(); i++) {
					
					sorties.get(i).draw(g);
				}**/
			}
		}
		
		
		
		int n = -1 ;
		@Override
		public void keyTyped(KeyEvent e) {
			
			
			if (joueurActif == 1 && jeuArrete ) {
				if (robots.size() == 1) {
					n = 0;
				}
				if (n != -1) {
					
					Robot robot =  robots.get(n);
					switch (e.getKeyChar()) {
					case 'd': robot.TournerD();break;
					case 'q':robot.TournerG();break;
					case 'z':robot.TournerH();break;
					case 's':robot.TournerB();break;
					default:
						throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
					}
					joueurActif = 2 ;
					jeuArrete = false;
					n=-1;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
				
				
			}
			
				
				else if (joueurActif == 2 && jeuArrete ) {
					if (intrus.size() == 1 ) {
						n=0;
					}
					if (n != -1) {
						Intru intru =  intrus.get(n);
						switch (e.getKeyChar()) {
						case 'd': intru.TournerD();break;
						case 'q':intru.TournerG();break;
						case 'z':intru.TournerH();break;
						case 's':intru.TournerB();break;
						}
						joueurActif = 1 ;
						jeuArrete=false;
						n=-1;
					}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
					
			}	
			
		}
		@Override
		public void keyPressed(KeyEvent e) {
			// TODO Auto-generated method stub
			
		}
		@Override
		public void keyReleased(KeyEvent e) {
			// TODO Auto-generated method stub
			
		}
		@Override
		public void mouseClicked(MouseEvent e) {
			jeuArrete = true;
			n=-1;
			if (jeuArrete && (intrus.size() != 1 || robots.size() != 1)) {
				int colonne = e.getX()/cellWidth ;
				int ligne = e.getY() / cellWidth ;
				Point point = new Point(ligne,colonne);
				//System.out.println(point);
				if (joueurActif == 1  ) {
					for (int i = 0; i < robots.size(); i++) {
						if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
							n=i;
						}
					}
					if (n == -1 ) {
						JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
					}
					
				}
				if (joueurActif == 2  ) {
					for (int i = 0; i < intrus.size(); i++) {
						if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
							n=i;
						}
					}
					if (n == -1 ) {
						JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
					}
				}
				
			}
			
			
		}
		@Override
		public void mousePressed(MouseEvent e) {
			// TODO Auto-generated method stub
			
		}
		@Override
		public void mouseReleased(MouseEvent e) {
			// TODO Auto-generated method stub
			
		}
		@Override
		public void mouseEntered(MouseEvent e) {
			// TODO Auto-generated method stub
			
		}
		@Override
		public void mouseExited(MouseEvent e) {
			// TODO Auto-generated method stub
			
		}
		
		
		
		//verifier avant de quitter

		@Override
		public void windowActivated(WindowEvent e) {
			// TODO Auto-generated method stub
			
		}

		@Override
		public void windowClosed(WindowEvent e) {
			// TODO Auto-generated method stub
			
		}

		@Override
		public void windowClosing(WindowEvent e) {
			// TODO Auto-generated method stub
			exit();
			
			}
	
		void exit() {
			
			int a= JOptionPane.showConfirmDialog(null, "Clicker sur \"oui \" pour quitter vers le menu principal", "Quit options", JOptionPane.YES_NO_OPTION);
			if (a==JOptionPane.YES_OPTION) {
				dispose();
				Menu window = new Menu();
				window.main(null);
				
			}
			
			
			
		}
		

		@Override
		public void windowDeactivated(WindowEvent e) {
			// TODO Auto-generated method stub
			
		}

		@Override
		public void windowDeiconified(WindowEvent e) {
			// TODO Auto-generated method stub
			
		}

		@Override
		public void windowIconified(WindowEvent e) {
			// TODO Auto-generated method stub
			
		}

		@Override
		public void windowOpened(WindowEvent e) {
			// TODO Auto-generated method stub
			
		}
		
	}
}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2020-09-17 08:15:38.123
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2020-09-17 08:15:38.128
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-17 08:15:42.691
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.GridBagLayout;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.event.WindowEvent;
import java.awt.event.WindowListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import java.awt.GridBagConstraints;
import java.awt.Insets;
import java.awt.Component;
import javax.swing.Box;

public class Jeu extends JFrame{
	JLabel label;
	JPanel panel = new JPanel();
	JLabel lblNewLabel = new JLabel("Time :");
	JLabel lblNewLabel_1 = new JLabel("Sacs restants :");
	JLabel lblNewLabel_2 = new JLabel("Intrus restants :");
	JLabel lblNewLabel_3 = new JLabel("Robots :");
	private Component verticalStrut;
	private final Component horizontalStrut = Box.createHorizontalStrut(20);
	private final Component horizontalStrut_1 = Box.createHorizontalStrut(20);
	public Jeu(ConfigurationModel configuration) {
		super("Jeu");
		setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);
		getContentPane().setLayout(new BorderLayout());
		 label = new JLabel("Hello");
		 label.setForeground(Color.red);
		label.setVisible(true);
		getContentPane().add(label,BorderLayout.SOUTH);
		getContentPane().add(new Map(configuration),BorderLayout.CENTER);
		getContentPane().add(panel, BorderLayout.NORTH);
		GridBagLayout gbl_panel = new GridBagLayout();
		gbl_panel.columnWidths = new int[]{52, 0, 0, 0, 0, 56, 0};
		gbl_panel.rowHeights = new int[]{0, 0, 0, 16, 0};
		gbl_panel.columnWeights = new double[]{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, Double.MIN_VALUE};
		gbl_panel.rowWeights = new double[]{0.0, 0.0, 0.0, 0.0, Double.MIN_VALUE};
		panel.setLayout(gbl_panel);
		
		verticalStrut = Box.createVerticalStrut(20);
		GridBagConstraints gbc_verticalStrut = new GridBagConstraints();
		gbc_verticalStrut.insets = new Insets(0, 0, 5, 5);
		gbc_verticalStrut.gridx = 0;
		gbc_verticalStrut.gridy = 0;
		panel.add(verticalStrut, gbc_verticalStrut);
		
		//JLabel lblNewLabel = new JLabel("Time :");
		GridBagConstraints gbc_lblNewLabel = new GridBagConstraints();
		gbc_lblNewLabel.insets = new Insets(0, 0, 5, 5);
		gbc_lblNewLabel.anchor = GridBagConstraints.NORTHWEST;
		gbc_lblNewLabel.gridx = 0;
		gbc_lblNewLabel.gridy = 1;
		panel.add(lblNewLabel, gbc_lblNewLabel);
		
		
		
		
		//lblNewLabel_1 = new JLabel("Sacs restants :");
		GridBagConstraints gbc_lblNewLabel_1 = new GridBagConstraints();
		gbc_lblNewLabel_1.insets = new Insets(0, 0, 5, 5);
		gbc_lblNewLabel_1.gridx = 0;
		gbc_lblNewLabel_1.gridy = 2;
		panel.add(lblNewLabel_1, gbc_lblNewLabel_1);
		
		GridBagConstraints gbc_horizontalStrut = new GridBagConstraints();
		gbc_horizontalStrut.insets = new Insets(0, 0, 5, 5);
		gbc_horizontalStrut.gridx = 1;
		gbc_horizontalStrut.gridy = 2;
		panel.add(horizontalStrut, gbc_horizontalStrut);
		
		//lblNewLabel_2 = new JLabel("nbre d'Intrus restants :");
		GridBagConstraints gbc_lblNewLabel_2 = new GridBagConstraints();
		gbc_lblNewLabel_2.insets = new Insets(0, 0, 5, 5);
		gbc_lblNewLabel_2.gridx = 2;
		gbc_lblNewLabel_2.gridy = 2;
		panel.add(lblNewLabel_2, gbc_lblNewLabel_2);
		
		GridBagConstraints gbc_horizontalStrut_1 = new GridBagConstraints();
		gbc_horizontalStrut_1.insets = new Insets(0, 0, 5, 5);
		gbc_horizontalStrut_1.gridx = 3;
		gbc_horizontalStrut_1.gridy = 2;
		panel.add(horizontalStrut_1, gbc_horizontalStrut_1);
		
		//lblNewLabel_3 = new JLabel("nbre de robots :");
		GridBagConstraints gbc_lblNewLabel_3 = new GridBagConstraints();
		gbc_lblNewLabel_3.insets = new Insets(0, 0, 5, 5);
		gbc_lblNewLabel_3.gridx = 4;
		gbc_lblNewLabel_3.gridy = 2;
		panel.add(lblNewLabel_3, gbc_lblNewLabel_3);
		pack();
		setLocationRelativeTo(null);
		setResizable(false);
		setVisible(true);
		
	}
	private class Map extends JPanel implements KeyListener,MouseListener,WindowListener {
		int width,height,cellWidth,cellHeight;
		private ConfigurationModel configuration ;
		private Vector<Robot> robots = new Vector<Robot>();
		private Vector<Intru> intrus = new Vector<Intru>();
		private Vector<Sac> sacs = new Vector<Sac>();
		private Vector<Obstacle> obstacles = new Vector<Obstacle>();
		private Vector<Sortie> sorties = new Vector<Sortie>();
		private int joueurActif ;
		private boolean jeuArrete;
		
		public Map(ConfigurationModel configuration) {
			this.configuration = configuration ; 
			joueurActif = 1;
			jeuArrete = true;
			width=getWidth();
			height=getHeight();
			cellWidth =40;
			cellHeight =40;
			prepare();
			changerTour();
			calculertemps();
			lblNewLabel_1.setText("Sacs restants: "+ sacs.size());
			lblNewLabel_2.setText("Intrus restants: "+intrus.size());
			lblNewLabel_3.setText("Robots: "+ robots.size());
			//afficher();
			this.addKeyListener(this);
			this.addMouseListener(this);
			addWindowListener(this);
	        this.setFocusable(true);
	        this.requestFocusInWindow();
	        
	        
	         
		}
		
		
		
		
	/*	//Afficher le nombre de robots, intrus et sacs
		private void afficher() {

			Timer myTimer2 = new Timer();
			TimerTask task2= new TimerTask() {
				int s=0;
				@Override
				public void run() {
					s++;
					int x1=sacs.size();
					int x2=intrus.size();
					int x3=robots.size();
					lblNewLabel_1.setText("Sacs restants: "+ x1);
					lblNewLabel_2.setText("Intrus restants: "+ x2);
					lblNewLabel_3.setText("Robots: "+ x3);
					//System.out.println(sacs.size());
				}
			};
			myTimer2.scheduleAtFixedRate(task2, 1000, 1000);
		}
		*/
		
		//Calculer le temps passé
		private void calculertemps() {
			//System.out.println("temps");
			
			Timer myTimer1 = new Timer();
			TimerTask task1= new TimerTask() {
				int SecondesPassed1 = 0;
				int min=0,heu=0;
				@Override
				public void run() {
					if (intrus.size()!=0) {
						SecondesPassed1 ++;  
					}
					
					String ch ="";
					
					if (SecondesPassed1 ==60) {
						min+=1;
						SecondesPassed1=0;
					}
					if (min==60) {
						heu+=1;
						min=0;
					}
					//System.out.println("Time: "+ SecondesPassed1);
					
					if (SecondesPassed1 / 10 == 0 && min/ 10==0 ) {
						ch="0"+heu+" : "+"0"+min+" : "+"0"+SecondesPassed1;
					}
					if (SecondesPassed1 / 10 != 0 && min/ 10==0) {
						ch="0"+heu+" : "+"0"+min+" : "+SecondesPassed1;
					}
					if (SecondesPassed1 / 10 == 0 && min/ 10!=0) {
						ch="0"+heu+" : "+min+" : "+"0"+SecondesPassed1;
					}
					
					if (SecondesPassed1 / 10 != 0 && min/ 10!=0) {
						ch="0"+heu+" : "+min+" : "+SecondesPassed1; 
					}
					lblNewLabel.setText("Time: " + ch );
					
					
				}
			};
			
			
				myTimer1.scheduleAtFixedRate(task1, 1000, 1000);
			
		
			
			
			
		}
		
		
		
		// Changer automatiquement le tour chaque 5 secondes
		private void changerTour()
		{
			
			Timer timer = new Timer();
			TimerTask  timerTask = new TimerTask() {
				int secondPassed = 0 ;
				@Override
				public void run() {
					secondPassed ++ ; 
					if (!jeuArrete) {
						//System.out.println("Il reste "+(5-secondPassed)+" secondes pourque le joueur " + joueurActif + " joue son coup !");
						label.setText("Il reste "+(5-secondPassed)+" secondes pourque le joueur " + joueurActif + " joue son coup !  .. Cliquer pour prendre le coup ! ..");
						if (secondPassed == 5 && joueurActif == 1) {
							secondPassed =0;
							joueurActif =2;
						}
						if (secondPassed == 5 && joueurActif == 2) {
							secondPassed =0;
							joueurActif =1;
						}
					}
					if (jeuArrete) {
						secondPassed = 0 ;
						label.setText("Joueur "+joueurActif+" en train de jouer !  .. Choisir une direction .. ");
					}
					
				}
			};
			timer.scheduleAtFixedRate(timerTask, 1000, 1000);
		}
		// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
		private void prepare()
		
		{
			for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
				int x= configuration.Emplac_Intrus.get(i).x;
				int y= configuration.Emplac_Intrus.get(i).y;
				Intru intru = new Intru(y, x, 1000);
				intrus.add(intru);
				MoveIntrus moveIntrus =new MoveIntrus(intru);
				moveIntrus.start();
			}
			for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
				int x= configuration.Emplac_Robots.get(i).x;
				int y= configuration.Emplac_Robots.get(i).y;
				Robot robot = new Robot(y,x, 500);
				robots.add(robot);
				MoveRobots moveRobots = new MoveRobots(robot);
				moveRobots.start();
			}
			for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
				int x= configuration.Emplac_Obstacle.get(i).x;
				int y= configuration.Emplac_Obstacle.get(i).y;
				Obstacle obstacle = new Obstacle(y, x);
				obstacles.add(obstacle);
			}
			for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
				int x= configuration.Emplac_Sac.get(i).x;
				int y= configuration.Emplac_Sac.get(i).y;
				Sac sac = new Sac(y, x);
				sacs.add(sac);
			}
			for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
				int x= configuration.Emplac_Sortie.get(i).x;
				int y= configuration.Emplac_Sortie.get(i).y;
				Sortie sortie = new Sortie(y, x);
				sorties.add(sortie);
			}
		}
		// verifier si p1 est adjacent à p2
		private boolean EstAdjacent(Point p1,Point p2)
		{
			if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
			((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
			return true;
			else return false;
		}
		private boolean MovementValide(Point p , char direction) {
			Point pa = null;
			switch (direction) {
			case 'D': pa = new Point(p.x+1,p.y);break;
			case 'G': pa = new Point(p.x-1,p.y);break;
			case 'B': pa = new Point(p.x,p.y+1);break;
			case 'H': pa = new Point(p.x,p.y-1);break;
			default:
				break;
			}
			if (pa != null) {
				for (int i = 0; i < obstacles.size(); i++) {
					if (obstacles.get(i).x == pa.x && obstacles.get(i).y== pa.y ) {
						return false;
					}
				}
				for (int i = 0; i < sacs.size(); i++) {
					if (sacs.get(i).x == pa.x && sacs.get(i).y== pa.y ) {
						return false;
					}
				}
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == pa.x && intrus.get(i).y== pa.y ) {
						return false;
					}
				}
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == pa.x && robots.get(i).y== pa.y ) {
						return false;
					}
				}
				for (int i = 0; i < sorties.size(); i++) {
					if (sorties.get(i).x == pa.x && sorties.get(i).y== pa.y ) {
						return false;
					}
				}
			}
			
			return true;
		}

		
		public class MoveIntrus extends Thread 
		{
			Intru intru ;
			MoveIntrus(Intru intru)
			{
				this.intru=intru;
			}
			@Override
			public void run() {
			//	int pas =0;
				while(true)
				{	//  un intru prend un sac 
					if (jeuArrete) {
					//	pas = 0 ;
						try {
							sleep(1000);
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
					}
					else 
					{
						// un intru prend un sac
						for (int i = 0; i < sacs.size(); i++) {
							if (EstAdjacent(intru, sacs.get(i))) {
								if (intru.PrendSac(sacs.get(i))) {
									sacs.remove(sacs.get(i));
									System.out.println(sacs.size());
									lblNewLabel_1.setText("Sacs restants: "+ sacs.size());
									
								}
																}
						} 
						//un robot attrape un intru 
						for (int i = 0; i < robots.size(); i++) {
							
							if (EstAdjacent(intru, robots.get(i)) )
								{
									for (int j = 0; j < intru.sacs.size(); j++) {
										
										sacs.add(intru.sacs.get(j));
										lblNewLabel_1.setText("Sacs restants: "+ sacs.size());
										
									}
									intru.retournerSac();
									intrus.remove(intru);
									lblNewLabel_2.setText("Intrus restants: "+intrus.size());
								}
						}
						// un intru sort à partir d'une sortie 
						for (int i = 0; i < sorties.size(); i++) {
							
							if (EstAdjacent(intru, sorties.get(i)) )
								{
									intrus.remove(intru);
									lblNewLabel_2.setText("Intrus restants: "+intrus.size());
								}
						}
						
						// le mouvement d'un intru d'une case à une autre
						if (intru.active==false) interrupt();
						
							
							if (MovementValide(intru, intru.direction))
							{
								intru.move();
								repaint();
								try {
									sleep(1000);
								} catch (InterruptedException e) {
									// TODO Auto-generated catch block
									e.printStackTrace();
								}
								
							}
						
					}
				
						
				}
							
				}
							
			}
		class MoveRobots extends Thread 
		{
			Robot robot;
			public MoveRobots(Robot robot) {
				this.robot = robot ;
			}

			@Override
			public void run() {
				// pas = 0;
				while(true)
				{
					if (jeuArrete) {
						//pas =0;
						try {
							sleep(1000);
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
					}
					else {
						
						// le mouvement d'un robot d'une case à une autre
						if (MovementValide(robot, robot.direction))
						{
							robot.move();
							repaint();
							
							try {
								//pas++;
								sleep(500);
								//if (pas==3) {
									//jeuArrete = true;
								//}
								
								
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						
					}
					
				}
							
				}
					
			}
		
		// dimensionner la JPanel
		@Override
		public Dimension getPreferredSize() {
			return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
			}
		// dessiner tous les objects 
		@Override
		protected void paintComponent(Graphics g) {
			super.paintComponent(g);
			
			if (intrus.size() == 0 )
			{
				jeuArrete = true;
				label.setText("le jeu est terminé !");
				ImageIcon imageIcon=new ImageIcon("resources\\GameOver.jpg");
				Image image = imageIcon.getImage();
				g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
				/*for (Thread t : Thread.getAllStackTraces().keySet()) 
				{  if (t.getState()==Thread.State.RUNNABLE) 
				     t.interrupt(); 
				} */

				
				repaint();
			}
			else {
				for (int i = 0; i < configuration.nbre_colonne; i++) {
					for (int j = 0; j < configuration.nbre_ligne; j++) {
						g.setColor(Color.WHITE);
						g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
					}
					
				}
				for (int i = 0; i < intrus.size(); i++) {
					if(intrus.get(i).active=true)
					{
						if (i == n && joueurActif == 1 ) {
							
							g.setColor(Color.green);
							g.fillRect(intrus.get(i).x*cellWidth,intrus.get(i).y*cellHeight, cellWidth, cellHeight);
						}
						intrus.get(i).draw(g);
					}
				}
				for (int i = 0; i < robots.size(); i++) {
					if (i == n && joueurActif ==2) {
						
						g.setColor(Color.green);
						g.fillRect(x, y, i, i);(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
					}
					robots.get(i).draw(g);
				}
				for (int i = 0; i < obstacles.size(); i++) {
					
					obstacles.get(i).draw(g);
				}
				for (int i = 0; i < sacs.size(); i++) {
					
					sacs.get(i).draw(g);
				}
				/**for (int i = 0; i < sorties.size(); i++) {
					
					sorties.get(i).draw(g);
				}**/
			}
		}
		
		
		
		int n = -1 ;
		@Override
		public void keyTyped(KeyEvent e) {
			
			
			if (joueurActif == 1 && jeuArrete ) {
				if (robots.size() == 1) {
					n = 0;
				}
				if (n != -1) {
					
					Robot robot =  robots.get(n);
					switch (e.getKeyChar()) {
					case 'd': robot.TournerD();break;
					case 'q':robot.TournerG();break;
					case 'z':robot.TournerH();break;
					case 's':robot.TournerB();break;
					default:
						throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
					}
					joueurActif = 2 ;
					jeuArrete = false;
					n=-1;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
				
				
			}
			
				
				else if (joueurActif == 2 && jeuArrete ) {
					if (intrus.size() == 1 ) {
						n=0;
					}
					if (n != -1) {
						Intru intru =  intrus.get(n);
						switch (e.getKeyChar()) {
						case 'd': intru.TournerD();break;
						case 'q':intru.TournerG();break;
						case 'z':intru.TournerH();break;
						case 's':intru.TournerB();break;
						}
						joueurActif = 1 ;
						jeuArrete=false;
						n=-1;
					}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
					
			}	
			
		}
		@Override
		public void keyPressed(KeyEvent e) {
			// TODO Auto-generated method stub
			
		}
		@Override
		public void keyReleased(KeyEvent e) {
			// TODO Auto-generated method stub
			
		}
		@Override
		public void mouseClicked(MouseEvent e) {
			jeuArrete = true;
			n=-1;
			if (jeuArrete && (intrus.size() != 1 || robots.size() != 1)) {
				int colonne = e.getX()/cellWidth ;
				int ligne = e.getY() / cellWidth ;
				Point point = new Point(ligne,colonne);
				//System.out.println(point);
				if (joueurActif == 1  ) {
					for (int i = 0; i < robots.size(); i++) {
						if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
							n=i;
						}
					}
					if (n == -1 ) {
						JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
					}
					
				}
				if (joueurActif == 2  ) {
					for (int i = 0; i < intrus.size(); i++) {
						if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
							n=i;
						}
					}
					if (n == -1 ) {
						JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
					}
				}
				
			}
			
			
		}
		@Override
		public void mousePressed(MouseEvent e) {
			// TODO Auto-generated method stub
			
		}
		@Override
		public void mouseReleased(MouseEvent e) {
			// TODO Auto-generated method stub
			
		}
		@Override
		public void mouseEntered(MouseEvent e) {
			// TODO Auto-generated method stub
			
		}
		@Override
		public void mouseExited(MouseEvent e) {
			// TODO Auto-generated method stub
			
		}
		
		
		
		//verifier avant de quitter

		@Override
		public void windowActivated(WindowEvent e) {
			// TODO Auto-generated method stub
			
		}

		@Override
		public void windowClosed(WindowEvent e) {
			// TODO Auto-generated method stub
			
		}

		@Override
		public void windowClosing(WindowEvent e) {
			// TODO Auto-generated method stub
			exit();
			
			}
	
		void exit() {
			
			int a= JOptionPane.showConfirmDialog(null, "Clicker sur \"oui \" pour quitter vers le menu principal", "Quit options", JOptionPane.YES_NO_OPTION);
			if (a==JOptionPane.YES_OPTION) {
				dispose();
				Menu window = new Menu();
				window.main(null);
				
			}
			
			
			
		}
		

		@Override
		public void windowDeactivated(WindowEvent e) {
			// TODO Auto-generated method stub
			
		}

		@Override
		public void windowDeiconified(WindowEvent e) {
			// TODO Auto-generated method stub
			
		}

		@Override
		public void windowIconified(WindowEvent e) {
			// TODO Auto-generated method stub
			
		}

		@Override
		public void windowOpened(WindowEvent e) {
			// TODO Auto-generated method stub
			
		}
		
	}
}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-09-17 08:15:42.695
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-09-17 08:15:42.699
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-17 08:15:45.458
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.GridBagLayout;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.event.WindowEvent;
import java.awt.event.WindowListener;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import java.awt.GridBagConstraints;
import java.awt.Insets;
import java.awt.Component;
import javax.swing.Box;

public class Jeu extends JFrame{
	JLabel label;
	JPanel panel = new JPanel();
	JLabel lblNewLabel = new JLabel("Time :");
	JLabel lblNewLabel_1 = new JLabel("Sacs restants :");
	JLabel lblNewLabel_2 = new JLabel("Intrus restants :");
	JLabel lblNewLabel_3 = new JLabel("Robots :");
	private Component verticalStrut;
	private final Component horizontalStrut = Box.createHorizontalStrut(20);
	private final Component horizontalStrut_1 = Box.createHorizontalStrut(20);
	public Jeu(ConfigurationModel configuration) {
		super("Jeu");
		setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);
		getContentPane().setLayout(new BorderLayout());
		 label = new JLabel("Hello");
		 label.setForeground(Color.red);
		label.setVisible(true);
		getContentPane().add(label,BorderLayout.SOUTH);
		getContentPane().add(new Map(configuration),BorderLayout.CENTER);
		getContentPane().add(panel, BorderLayout.NORTH);
		GridBagLayout gbl_panel = new GridBagLayout();
		gbl_panel.columnWidths = new int[]{52, 0, 0, 0, 0, 56, 0};
		gbl_panel.rowHeights = new int[]{0, 0, 0, 16, 0};
		gbl_panel.columnWeights = new double[]{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, Double.MIN_VALUE};
		gbl_panel.rowWeights = new double[]{0.0, 0.0, 0.0, 0.0, Double.MIN_VALUE};
		panel.setLayout(gbl_panel);
		
		verticalStrut = Box.createVerticalStrut(20);
		GridBagConstraints gbc_verticalStrut = new GridBagConstraints();
		gbc_verticalStrut.insets = new Insets(0, 0, 5, 5);
		gbc_verticalStrut.gridx = 0;
		gbc_verticalStrut.gridy = 0;
		panel.add(verticalStrut, gbc_verticalStrut);
		
		//JLabel lblNewLabel = new JLabel("Time :");
		GridBagConstraints gbc_lblNewLabel = new GridBagConstraints();
		gbc_lblNewLabel.insets = new Insets(0, 0, 5, 5);
		gbc_lblNewLabel.anchor = GridBagConstraints.NORTHWEST;
		gbc_lblNewLabel.gridx = 0;
		gbc_lblNewLabel.gridy = 1;
		panel.add(lblNewLabel, gbc_lblNewLabel);
		
		
		
		
		//lblNewLabel_1 = new JLabel("Sacs restants :");
		GridBagConstraints gbc_lblNewLabel_1 = new GridBagConstraints();
		gbc_lblNewLabel_1.insets = new Insets(0, 0, 5, 5);
		gbc_lblNewLabel_1.gridx = 0;
		gbc_lblNewLabel_1.gridy = 2;
		panel.add(lblNewLabel_1, gbc_lblNewLabel_1);
		
		GridBagConstraints gbc_horizontalStrut = new GridBagConstraints();
		gbc_horizontalStrut.insets = new Insets(0, 0, 5, 5);
		gbc_horizontalStrut.gridx = 1;
		gbc_horizontalStrut.gridy = 2;
		panel.add(horizontalStrut, gbc_horizontalStrut);
		
		//lblNewLabel_2 = new JLabel("nbre d'Intrus restants :");
		GridBagConstraints gbc_lblNewLabel_2 = new GridBagConstraints();
		gbc_lblNewLabel_2.insets = new Insets(0, 0, 5, 5);
		gbc_lblNewLabel_2.gridx = 2;
		gbc_lblNewLabel_2.gridy = 2;
		panel.add(lblNewLabel_2, gbc_lblNewLabel_2);
		
		GridBagConstraints gbc_horizontalStrut_1 = new GridBagConstraints();
		gbc_horizontalStrut_1.insets = new Insets(0, 0, 5, 5);
		gbc_horizontalStrut_1.gridx = 3;
		gbc_horizontalStrut_1.gridy = 2;
		panel.add(horizontalStrut_1, gbc_horizontalStrut_1);
		
		//lblNewLabel_3 = new JLabel("nbre de robots :");
		GridBagConstraints gbc_lblNewLabel_3 = new GridBagConstraints();
		gbc_lblNewLabel_3.insets = new Insets(0, 0, 5, 5);
		gbc_lblNewLabel_3.gridx = 4;
		gbc_lblNewLabel_3.gridy = 2;
		panel.add(lblNewLabel_3, gbc_lblNewLabel_3);
		pack();
		setLocationRelativeTo(null);
		setResizable(false);
		setVisible(true);
		
	}
	private class Map extends JPanel implements KeyListener,MouseListener,WindowListener {
		int width,height,cellWidth,cellHeight;
		private ConfigurationModel configuration ;
		private Vector<Robot> robots = new Vector<Robot>();
		private Vector<Intru> intrus = new Vector<Intru>();
		private Vector<Sac> sacs = new Vector<Sac>();
		private Vector<Obstacle> obstacles = new Vector<Obstacle>();
		private Vector<Sortie> sorties = new Vector<Sortie>();
		private int joueurActif ;
		private boolean jeuArrete;
		
		public Map(ConfigurationModel configuration) {
			this.configuration = configuration ; 
			joueurActif = 1;
			jeuArrete = true;
			width=getWidth();
			height=getHeight();
			cellWidth =40;
			cellHeight =40;
			prepare();
			changerTour();
			calculertemps();
			lblNewLabel_1.setText("Sacs restants: "+ sacs.size());
			lblNewLabel_2.setText("Intrus restants: "+intrus.size());
			lblNewLabel_3.setText("Robots: "+ robots.size());
			//afficher();
			this.addKeyListener(this);
			this.addMouseListener(this);
			addWindowListener(this);
	        this.setFocusable(true);
	        this.requestFocusInWindow();
	        
	        
	         
		}
		
		
		
		
	/*	//Afficher le nombre de robots, intrus et sacs
		private void afficher() {

			Timer myTimer2 = new Timer();
			TimerTask task2= new TimerTask() {
				int s=0;
				@Override
				public void run() {
					s++;
					int x1=sacs.size();
					int x2=intrus.size();
					int x3=robots.size();
					lblNewLabel_1.setText("Sacs restants: "+ x1);
					lblNewLabel_2.setText("Intrus restants: "+ x2);
					lblNewLabel_3.setText("Robots: "+ x3);
					//System.out.println(sacs.size());
				}
			};
			myTimer2.scheduleAtFixedRate(task2, 1000, 1000);
		}
		*/
		
		//Calculer le temps passé
		private void calculertemps() {
			//System.out.println("temps");
			
			Timer myTimer1 = new Timer();
			TimerTask task1= new TimerTask() {
				int SecondesPassed1 = 0;
				int min=0,heu=0;
				@Override
				public void run() {
					if (intrus.size()!=0) {
						SecondesPassed1 ++;  
					}
					
					String ch ="";
					
					if (SecondesPassed1 ==60) {
						min+=1;
						SecondesPassed1=0;
					}
					if (min==60) {
						heu+=1;
						min=0;
					}
					//System.out.println("Time: "+ SecondesPassed1);
					
					if (SecondesPassed1 / 10 == 0 && min/ 10==0 ) {
						ch="0"+heu+" : "+"0"+min+" : "+"0"+SecondesPassed1;
					}
					if (SecondesPassed1 / 10 != 0 && min/ 10==0) {
						ch="0"+heu+" : "+"0"+min+" : "+SecondesPassed1;
					}
					if (SecondesPassed1 / 10 == 0 && min/ 10!=0) {
						ch="0"+heu+" : "+min+" : "+"0"+SecondesPassed1;
					}
					
					if (SecondesPassed1 / 10 != 0 && min/ 10!=0) {
						ch="0"+heu+" : "+min+" : "+SecondesPassed1; 
					}
					lblNewLabel.setText("Time: " + ch );
					
					
				}
			};
			
			
				myTimer1.scheduleAtFixedRate(task1, 1000, 1000);
			
		
			
			
			
		}
		
		
		
		// Changer automatiquement le tour chaque 5 secondes
		private void changerTour()
		{
			
			Timer timer = new Timer();
			TimerTask  timerTask = new TimerTask() {
				int secondPassed = 0 ;
				@Override
				public void run() {
					secondPassed ++ ; 
					if (!jeuArrete) {
						//System.out.println("Il reste "+(5-secondPassed)+" secondes pourque le joueur " + joueurActif + " joue son coup !");
						label.setText("Il reste "+(5-secondPassed)+" secondes pourque le joueur " + joueurActif + " joue son coup !  .. Cliquer pour prendre le coup ! ..");
						if (secondPassed == 5 && joueurActif == 1) {
							secondPassed =0;
							joueurActif =2;
						}
						if (secondPassed == 5 && joueurActif == 2) {
							secondPassed =0;
							joueurActif =1;
						}
					}
					if (jeuArrete) {
						secondPassed = 0 ;
						label.setText("Joueur "+joueurActif+" en train de jouer !  .. Choisir une direction .. ");
					}
					
				}
			};
			timer.scheduleAtFixedRate(timerTask, 1000, 1000);
		}
		// Construire les objects obstacle / sac / sortie / robot / intru à partir de la configuration
		private void prepare()
		
		{
			for (int i = 0; i < configuration.Emplac_Intrus.size(); i++) {
				int x= configuration.Emplac_Intrus.get(i).x;
				int y= configuration.Emplac_Intrus.get(i).y;
				Intru intru = new Intru(y, x, 1000);
				intrus.add(intru);
				MoveIntrus moveIntrus =new MoveIntrus(intru);
				moveIntrus.start();
			}
			for (int i = 0; i < configuration.Emplac_Robots.size(); i++) {
				int x= configuration.Emplac_Robots.get(i).x;
				int y= configuration.Emplac_Robots.get(i).y;
				Robot robot = new Robot(y,x, 500);
				robots.add(robot);
				MoveRobots moveRobots = new MoveRobots(robot);
				moveRobots.start();
			}
			for (int i = 0; i < configuration.Emplac_Obstacle.size(); i++) {
				int x= configuration.Emplac_Obstacle.get(i).x;
				int y= configuration.Emplac_Obstacle.get(i).y;
				Obstacle obstacle = new Obstacle(y, x);
				obstacles.add(obstacle);
			}
			for (int i = 0; i < configuration.Emplac_Sac.size(); i++) {
				int x= configuration.Emplac_Sac.get(i).x;
				int y= configuration.Emplac_Sac.get(i).y;
				Sac sac = new Sac(y, x);
				sacs.add(sac);
			}
			for (int i = 0; i < configuration.Emplac_Sortie.size(); i++) {
				int x= configuration.Emplac_Sortie.get(i).x;
				int y= configuration.Emplac_Sortie.get(i).y;
				Sortie sortie = new Sortie(y, x);
				sorties.add(sortie);
			}
		}
		// verifier si p1 est adjacent à p2
		private boolean EstAdjacent(Point p1,Point p2)
		{
			if(((p1.y+1 == p2.y || p1.y-1 == p2.y) && (p1.x+1 == p2.x || p1.x-1 == p2.x ||p1.x == p2.x))||
			((p1.x+1 == p2.x || p1.x-1 == p2.x) && (p1.y+1 == p2.y || p1.y-1 == p2.y ||p1.y == p2.y)))
			return true;
			else return false;
		}
		private boolean MovementValide(Point p , char direction) {
			Point pa = null;
			switch (direction) {
			case 'D': pa = new Point(p.x+1,p.y);break;
			case 'G': pa = new Point(p.x-1,p.y);break;
			case 'B': pa = new Point(p.x,p.y+1);break;
			case 'H': pa = new Point(p.x,p.y-1);break;
			default:
				break;
			}
			if (pa != null) {
				for (int i = 0; i < obstacles.size(); i++) {
					if (obstacles.get(i).x == pa.x && obstacles.get(i).y== pa.y ) {
						return false;
					}
				}
				for (int i = 0; i < sacs.size(); i++) {
					if (sacs.get(i).x == pa.x && sacs.get(i).y== pa.y ) {
						return false;
					}
				}
				for (int i = 0; i < intrus.size(); i++) {
					if (intrus.get(i).x == pa.x && intrus.get(i).y== pa.y ) {
						return false;
					}
				}
				for (int i = 0; i < robots.size(); i++) {
					if (robots.get(i).x == pa.x && robots.get(i).y== pa.y ) {
						return false;
					}
				}
				for (int i = 0; i < sorties.size(); i++) {
					if (sorties.get(i).x == pa.x && sorties.get(i).y== pa.y ) {
						return false;
					}
				}
			}
			
			return true;
		}

		
		public class MoveIntrus extends Thread 
		{
			Intru intru ;
			MoveIntrus(Intru intru)
			{
				this.intru=intru;
			}
			@Override
			public void run() {
			//	int pas =0;
				while(true)
				{	//  un intru prend un sac 
					if (jeuArrete) {
					//	pas = 0 ;
						try {
							sleep(1000);
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
					}
					else 
					{
						// un intru prend un sac
						for (int i = 0; i < sacs.size(); i++) {
							if (EstAdjacent(intru, sacs.get(i))) {
								if (intru.PrendSac(sacs.get(i))) {
									sacs.remove(sacs.get(i));
									System.out.println(sacs.size());
									lblNewLabel_1.setText("Sacs restants: "+ sacs.size());
									
								}
																}
						} 
						//un robot attrape un intru 
						for (int i = 0; i < robots.size(); i++) {
							
							if (EstAdjacent(intru, robots.get(i)) )
								{
									for (int j = 0; j < intru.sacs.size(); j++) {
										
										sacs.add(intru.sacs.get(j));
										lblNewLabel_1.setText("Sacs restants: "+ sacs.size());
										
									}
									intru.retournerSac();
									intrus.remove(intru);
									lblNewLabel_2.setText("Intrus restants: "+intrus.size());
								}
						}
						// un intru sort à partir d'une sortie 
						for (int i = 0; i < sorties.size(); i++) {
							
							if (EstAdjacent(intru, sorties.get(i)) )
								{
									intrus.remove(intru);
									lblNewLabel_2.setText("Intrus restants: "+intrus.size());
								}
						}
						
						// le mouvement d'un intru d'une case à une autre
						if (intru.active==false) interrupt();
						
							
							if (MovementValide(intru, intru.direction))
							{
								intru.move();
								repaint();
								try {
									sleep(1000);
								} catch (InterruptedException e) {
									// TODO Auto-generated catch block
									e.printStackTrace();
								}
								
							}
						
					}
				
						
				}
							
				}
							
			}
		class MoveRobots extends Thread 
		{
			Robot robot;
			public MoveRobots(Robot robot) {
				this.robot = robot ;
			}

			@Override
			public void run() {
				// pas = 0;
				while(true)
				{
					if (jeuArrete) {
						//pas =0;
						try {
							sleep(1000);
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
					}
					else {
						
						// le mouvement d'un robot d'une case à une autre
						if (MovementValide(robot, robot.direction))
						{
							robot.move();
							repaint();
							
							try {
								//pas++;
								sleep(500);
								//if (pas==3) {
									//jeuArrete = true;
								//}
								
								
							} catch (InterruptedException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							
						}
						
					}
					
				}
							
				}
					
			}
		
		// dimensionner la JPanel
		@Override
		public Dimension getPreferredSize() {
			return new Dimension(configuration.nbre_colonne*cellWidth, configuration.nbre_ligne*cellHeight);
			}
		// dessiner tous les objects 
		@Override
		protected void paintComponent(Graphics g) {
			super.paintComponent(g);
			
			if (intrus.size() == 0 )
			{
				jeuArrete = true;
				label.setText("le jeu est terminé !");
				ImageIcon imageIcon=new ImageIcon("resources\\GameOver.jpg");
				Image image = imageIcon.getImage();
				g.drawImage(image, 0, 0, getHeight(), getHeight(), null);
				/*for (Thread t : Thread.getAllStackTraces().keySet()) 
				{  if (t.getState()==Thread.State.RUNNABLE) 
				     t.interrupt(); 
				} */

				
				repaint();
			}
			else {
				for (int i = 0; i < configuration.nbre_colonne; i++) {
					for (int j = 0; j < configuration.nbre_ligne; j++) {
						g.setColor(Color.WHITE);
						g.fillRect(i*cellWidth, j*cellHeight, cellWidth, cellHeight);
					}
					
				}
				for (int i = 0; i < intrus.size(); i++) {
					if(intrus.get(i).active=true)
					{
						if (i == n && joueurActif == 1 ) {
							
							g.setColor(Color.green);
							g.fillRect(intrus.get(i).x*cellWidth,intrus.get(i).y*cellHeight, cellWidth, cellHeight);
						}
						intrus.get(i).draw(g);
					}
				}
				for (int i = 0; i < robots.size(); i++) {
					if (i == n && joueurActif ==2) {
						
						g.setColor(Color.green);
						g.fillRect(x, y, i, i);(robots.get(i).x*cellWidth,robots.get(i).y*cellHeight, cellWidth, cellHeight);
					}
					robots.get(i).draw(g);
				}
				for (int i = 0; i < obstacles.size(); i++) {
					
					obstacles.get(i).draw(g);
				}
				for (int i = 0; i < sacs.size(); i++) {
					
					sacs.get(i).draw(g);
				}
				/**for (int i = 0; i < sorties.size(); i++) {
					
					sorties.get(i).draw(g);
				}**/
			}
		}
		
		
		
		int n = -1 ;
		@Override
		public void keyTyped(KeyEvent e) {
			
			
			if (joueurActif == 1 && jeuArrete ) {
				if (robots.size() == 1) {
					n = 0;
				}
				if (n != -1) {
					
					Robot robot =  robots.get(n);
					switch (e.getKeyChar()) {
					case 'd': robot.TournerD();break;
					case 'q':robot.TournerG();break;
					case 'z':robot.TournerH();break;
					case 's':robot.TournerB();break;
					default:
						throw new IllegalArgumentException("Unexpected value: " + e.getKeyChar());
					}
					joueurActif = 2 ;
					jeuArrete = false;
					n=-1;
				}else JOptionPane.showMessageDialog(null, "Cliquez sur un robot !");
				
				
			}
			
				
				else if (joueurActif == 2 && jeuArrete ) {
					if (intrus.size() == 1 ) {
						n=0;
					}
					if (n != -1) {
						Intru intru =  intrus.get(n);
						switch (e.getKeyChar()) {
						case 'd': intru.TournerD();break;
						case 'q':intru.TournerG();break;
						case 'z':intru.TournerH();break;
						case 's':intru.TournerB();break;
						}
						joueurActif = 1 ;
						jeuArrete=false;
						n=-1;
					}else JOptionPane.showMessageDialog(null, "Cliquez sur un intru !");
					
			}	
			
		}
		@Override
		public void keyPressed(KeyEvent e) {
			// TODO Auto-generated method stub
			
		}
		@Override
		public void keyReleased(KeyEvent e) {
			// TODO Auto-generated method stub
			
		}
		@Override
		public void mouseClicked(MouseEvent e) {
			jeuArrete = true;
			n=-1;
			if (jeuArrete && (intrus.size() != 1 || robots.size() != 1)) {
				int colonne = e.getX()/cellWidth ;
				int ligne = e.getY() / cellWidth ;
				Point point = new Point(ligne,colonne);
				//System.out.println(point);
				if (joueurActif == 1  ) {
					for (int i = 0; i < robots.size(); i++) {
						if (robots.get(i).x == point.y && robots.get(i).y == point.x) {
							n=i;
						}
					}
					if (n == -1 ) {
						JOptionPane.showMessageDialog(null, "Choisir  un robot ! ");
					}
					
				}
				if (joueurActif == 2  ) {
					for (int i = 0; i < intrus.size(); i++) {
						if (intrus.get(i).x == point.y && intrus.get(i).y == point.x) {
							n=i;
						}
					}
					if (n == -1 ) {
						JOptionPane.showMessageDialog(null, "Choisir un intru ! ");
					}
				}
				
			}
			
			
		}
		@Override
		public void mousePressed(MouseEvent e) {
			// TODO Auto-generated method stub
			
		}
		@Override
		public void mouseReleased(MouseEvent e) {
			// TODO Auto-generated method stub
			
		}
		@Override
		public void mouseEntered(MouseEvent e) {
			// TODO Auto-generated method stub
			
		}
		@Override
		public void mouseExited(MouseEvent e) {
			// TODO Auto-generated method stub
			
		}
		
		
		
		//verifier avant de quitter

		@Override
		public void windowActivated(WindowEvent e) {
			// TODO Auto-generated method stub
			
		}

		@Override
		public void windowClosed(WindowEvent e) {
			// TODO Auto-generated method stub
			
		}

		@Override
		public void windowClosing(WindowEvent e) {
			// TODO Auto-generated method stub
			exit();
			
			}
	
		void exit() {
			
			int a= JOptionPane.showConfirmDialog(null, "Clicker sur \"oui \" pour quitter vers le menu principal", "Quit options", JOptionPane.YES_NO_OPTION);
			if (a==JOptionPane.YES_OPTION) {
				dispose();
				Menu window = new Menu();
				window.main(null);
				
			}
			
			
			
		}
		

		@Override
		public void windowDeactivated(WindowEvent e) {
			// TODO Auto-generated method stub
			
		}

		@Override
		public void windowDeiconified(WindowEvent e) {
			// TODO Auto-generated method stub
			
		}

		@Override
		public void windowIconified(WindowEvent e) {
			// TODO Auto-generated method stub
			
		}

		@Override
		public void windowOpened(WindowEvent e) {
			// TODO Auto-generated method stub
			
		}
		
	}
}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-09-17 08:15:45.463
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-09-17 08:15:45.466
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)
!SESSION 2020-09-27 16:55:20.482 -----------------------------------------------
eclipse.buildId=4.16.0.I20200604-0540
java.version=14.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=fr_FR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2020-09-27 16:59:30.728
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2020-09-27 16:59:30.728
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@14c5283,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1eb7ec59,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2020-09-27 16:59:35.391
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\ayadi'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2020-09-27 17:08:16.877 -----------------------------------------------
eclipse.buildId=4.16.0.I20200604-0540
java.version=14.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=fr_FR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2020-09-27 17:08:39.428
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2020-09-27 17:08:39.428
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@13047d3d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4b240276,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2020-09-27 17:08:43.525
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\ayadi'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.ui 4 0 2020-09-27 21:10:11.088
!MESSAGE Unhandled event loop exception
!STACK 0
org.eclipse.e4.core.di.InjectionException: org.eclipse.swt.SWTException: i/o error (java.io.FileNotFoundException: C:\Program Files\Git\mingw64\share\git\git-for-windows.ico (Le chemin d’accès spécifié est introuvable))
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:68)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:236)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4735)
	at org.eclipse.e4.ui.internal.workbench.swt.E4Application$1.syncExec(E4Application.java:219)
	at org.eclipse.e4.ui.internal.di.UIEventObjectSupplier$UIEventHandler.handleEvent(UIEventObjectSupplier.java:64)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:132)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.e4.ui.model.application.ui.impl.UIElementImpl.setVisible(UIElementImpl.java:361)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributionRecord.updateVisibility(ContributionRecord.java:113)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRendererFilter.updateElementVisibility(MenuManagerRendererFilter.java:197)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRendererFilter.updateElementVisibility(MenuManagerRendererFilter.java:208)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerShowProcessor.showMenu(MenuManagerShowProcessor.java:258)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerShowProcessor.menuAboutToHide(MenuManagerShowProcessor.java:115)
	at org.eclipse.jface.internal.MenuManagerEventHelper.showEventPostHelper(MenuManagerEventHelper.java:95)
	at org.eclipse.jface.action.MenuManager.handleAboutToShow(MenuManager.java:469)
	at org.eclipse.jface.action.MenuManager.access$1(MenuManager.java:463)
	at org.eclipse.jface.action.MenuManager$2.menuShown(MenuManager.java:495)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:259)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4213)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1037)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1042)
	at org.eclipse.swt.widgets.Control.WM_INITMENUPOPUP(Control.java:5137)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4769)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1480)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2142)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4923)
	at org.eclipse.swt.internal.win32.OS.TrackPopupMenu(Native Method)
	at org.eclipse.swt.widgets.Menu._setVisible(Menu.java:237)
	at org.eclipse.swt.widgets.Display.runPopups(Display.java:4071)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3624)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1158)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1047)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:658)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:557)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:154)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:137)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:107)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1447)
Caused by: org.eclipse.swt.SWTException: i/o error (java.io.FileNotFoundException: C:\Program Files\Git\mingw64\share\git\git-for-windows.ico (Le chemin d’accès spécifié est introuvable))
	at org.eclipse.swt.SWT.error(SWT.java:4723)
	at org.eclipse.swt.SWT.error(SWT.java:4638)
	at org.eclipse.swt.graphics.ImageLoader.load(ImageLoader.java:184)
	at org.eclipse.tm.terminal.view.ui.local.showin.ExternalExecutablesManager.loadImage(ExternalExecutablesManager.java:282)
	at org.eclipse.tm.terminal.view.ui.local.showin.DynamicContributionItems.getContributionItems(DynamicContributionItems.java:74)
	at org.eclipse.ui.actions.CompoundContributionItem.getContributionItemsToFill(CompoundContributionItem.java:83)
	at org.eclipse.ui.actions.CompoundContributionItem.fill(CompoundContributionItem.java:57)
	at org.eclipse.ui.internal.menus.DynamicMenuContributionItem.fill(DynamicMenuContributionItem.java:146)
	at org.eclipse.jface.action.MenuManager.doItemFill(MenuManager.java:729)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:806)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:673)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.scheduleManagerUpdate(MenuManagerRenderer.java:1224)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.subscribeUIElementTopicVisible(MenuManagerRenderer.java:213)
	at jdk.internal.reflect.GeneratedMethodAccessor37.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	... 63 more
Caused by: java.io.FileNotFoundException: C:\Program Files\Git\mingw64\share\git\git-for-windows.ico (Le chemin d’accès spécifié est introuvable)
	at java.base/java.io.FileInputStream.open0(Native Method)
	at java.base/java.io.FileInputStream.open(FileInputStream.java:212)
	at java.base/java.io.FileInputStream.<init>(FileInputStream.java:154)
	at java.base/java.io.FileInputStream.<init>(FileInputStream.java:109)
	at org.eclipse.swt.graphics.ImageLoader.load(ImageLoader.java:181)
	... 77 more

!ENTRY org.eclipse.ui 4 0 2020-09-27 21:21:16.698
!MESSAGE Unhandled event loop exception
!STACK 0
org.eclipse.e4.core.di.InjectionException: org.eclipse.swt.SWTException: i/o error (java.io.FileNotFoundException: C:\Program Files\Git\mingw64\share\git\git-for-windows.ico (Le chemin d’accès spécifié est introuvable))
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:68)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:236)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4735)
	at org.eclipse.e4.ui.internal.workbench.swt.E4Application$1.syncExec(E4Application.java:219)
	at org.eclipse.e4.ui.internal.di.UIEventObjectSupplier$UIEventHandler.handleEvent(UIEventObjectSupplier.java:64)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:132)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.e4.ui.model.application.ui.impl.UIElementImpl.setVisible(UIElementImpl.java:361)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributionRecord.updateVisibility(ContributionRecord.java:113)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRendererFilter.updateElementVisibility(MenuManagerRendererFilter.java:197)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRendererFilter.updateElementVisibility(MenuManagerRendererFilter.java:208)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerShowProcessor.showMenu(MenuManagerShowProcessor.java:258)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerShowProcessor.menuAboutToHide(MenuManagerShowProcessor.java:115)
	at org.eclipse.jface.internal.MenuManagerEventHelper.showEventPostHelper(MenuManagerEventHelper.java:95)
	at org.eclipse.jface.action.MenuManager.handleAboutToShow(MenuManager.java:469)
	at org.eclipse.jface.action.MenuManager.access$1(MenuManager.java:463)
	at org.eclipse.jface.action.MenuManager$2.menuShown(MenuManager.java:495)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:259)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4213)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1037)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1042)
	at org.eclipse.swt.widgets.Control.WM_INITMENUPOPUP(Control.java:5137)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4769)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1480)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2142)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4923)
	at org.eclipse.swt.internal.win32.OS.TrackPopupMenu(Native Method)
	at org.eclipse.swt.widgets.Menu._setVisible(Menu.java:237)
	at org.eclipse.swt.widgets.Display.runPopups(Display.java:4071)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3624)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1158)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1047)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:658)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:557)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:154)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:137)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:107)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1447)
Caused by: org.eclipse.swt.SWTException: i/o error (java.io.FileNotFoundException: C:\Program Files\Git\mingw64\share\git\git-for-windows.ico (Le chemin d’accès spécifié est introuvable))
	at org.eclipse.swt.SWT.error(SWT.java:4723)
	at org.eclipse.swt.SWT.error(SWT.java:4638)
	at org.eclipse.swt.graphics.ImageLoader.load(ImageLoader.java:184)
	at org.eclipse.tm.terminal.view.ui.local.showin.ExternalExecutablesManager.loadImage(ExternalExecutablesManager.java:282)
	at org.eclipse.tm.terminal.view.ui.local.showin.DynamicContributionItems.getContributionItems(DynamicContributionItems.java:74)
	at org.eclipse.ui.actions.CompoundContributionItem.getContributionItemsToFill(CompoundContributionItem.java:83)
	at org.eclipse.ui.actions.CompoundContributionItem.fill(CompoundContributionItem.java:57)
	at org.eclipse.ui.internal.menus.DynamicMenuContributionItem.fill(DynamicMenuContributionItem.java:146)
	at org.eclipse.jface.action.MenuManager.doItemFill(MenuManager.java:729)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:806)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:673)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.scheduleManagerUpdate(MenuManagerRenderer.java:1224)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.subscribeUIElementTopicVisible(MenuManagerRenderer.java:213)
	at jdk.internal.reflect.GeneratedMethodAccessor37.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	... 63 more
Caused by: java.io.FileNotFoundException: C:\Program Files\Git\mingw64\share\git\git-for-windows.ico (Le chemin d’accès spécifié est introuvable)
	at java.base/java.io.FileInputStream.open0(Native Method)
	at java.base/java.io.FileInputStream.open(FileInputStream.java:212)
	at java.base/java.io.FileInputStream.<init>(FileInputStream.java:154)
	at java.base/java.io.FileInputStream.<init>(FileInputStream.java:109)
	at org.eclipse.swt.graphics.ImageLoader.load(ImageLoader.java:181)
	... 77 more

!ENTRY org.eclipse.ui 4 0 2020-09-30 20:15:53.045
!MESSAGE Unhandled event loop exception
!STACK 0
org.eclipse.e4.core.di.InjectionException: org.eclipse.swt.SWTException: i/o error (java.io.FileNotFoundException: C:\Program Files\Git\mingw64\share\git\git-for-windows.ico (Le chemin d’accès spécifié est introuvable))
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:68)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:236)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4735)
	at org.eclipse.e4.ui.internal.workbench.swt.E4Application$1.syncExec(E4Application.java:219)
	at org.eclipse.e4.ui.internal.di.UIEventObjectSupplier$UIEventHandler.handleEvent(UIEventObjectSupplier.java:64)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:132)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.e4.ui.model.application.ui.impl.UIElementImpl.setVisible(UIElementImpl.java:361)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributionRecord.updateVisibility(ContributionRecord.java:113)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRendererFilter.updateElementVisibility(MenuManagerRendererFilter.java:197)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRendererFilter.updateElementVisibility(MenuManagerRendererFilter.java:208)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerShowProcessor.showMenu(MenuManagerShowProcessor.java:258)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerShowProcessor.menuAboutToHide(MenuManagerShowProcessor.java:115)
	at org.eclipse.jface.internal.MenuManagerEventHelper.showEventPostHelper(MenuManagerEventHelper.java:95)
	at org.eclipse.jface.action.MenuManager.handleAboutToShow(MenuManager.java:469)
	at org.eclipse.jface.action.MenuManager.access$1(MenuManager.java:463)
	at org.eclipse.jface.action.MenuManager$2.menuShown(MenuManager.java:495)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:259)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4213)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1037)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1042)
	at org.eclipse.swt.widgets.Control.WM_INITMENUPOPUP(Control.java:5137)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4769)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1480)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2142)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4923)
	at org.eclipse.swt.internal.win32.OS.TrackPopupMenu(Native Method)
	at org.eclipse.swt.widgets.Menu._setVisible(Menu.java:237)
	at org.eclipse.swt.widgets.Display.runPopups(Display.java:4071)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3624)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1158)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1047)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:658)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:557)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:154)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:137)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:107)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1447)
Caused by: org.eclipse.swt.SWTException: i/o error (java.io.FileNotFoundException: C:\Program Files\Git\mingw64\share\git\git-for-windows.ico (Le chemin d’accès spécifié est introuvable))
	at org.eclipse.swt.SWT.error(SWT.java:4723)
	at org.eclipse.swt.SWT.error(SWT.java:4638)
	at org.eclipse.swt.graphics.ImageLoader.load(ImageLoader.java:184)
	at org.eclipse.tm.terminal.view.ui.local.showin.ExternalExecutablesManager.loadImage(ExternalExecutablesManager.java:282)
	at org.eclipse.tm.terminal.view.ui.local.showin.DynamicContributionItems.getContributionItems(DynamicContributionItems.java:74)
	at org.eclipse.ui.actions.CompoundContributionItem.getContributionItemsToFill(CompoundContributionItem.java:83)
	at org.eclipse.ui.actions.CompoundContributionItem.fill(CompoundContributionItem.java:57)
	at org.eclipse.ui.internal.menus.DynamicMenuContributionItem.fill(DynamicMenuContributionItem.java:146)
	at org.eclipse.jface.action.MenuManager.doItemFill(MenuManager.java:729)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:806)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:673)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.scheduleManagerUpdate(MenuManagerRenderer.java:1224)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.subscribeUIElementTopicVisible(MenuManagerRenderer.java:213)
	at jdk.internal.reflect.GeneratedMethodAccessor37.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	... 63 more
Caused by: java.io.FileNotFoundException: C:\Program Files\Git\mingw64\share\git\git-for-windows.ico (Le chemin d’accès spécifié est introuvable)
	at java.base/java.io.FileInputStream.open0(Native Method)
	at java.base/java.io.FileInputStream.open(FileInputStream.java:212)
	at java.base/java.io.FileInputStream.<init>(FileInputStream.java:154)
	at java.base/java.io.FileInputStream.<init>(FileInputStream.java:109)
	at org.eclipse.swt.graphics.ImageLoader.load(ImageLoader.java:181)
	... 77 more

!ENTRY org.eclipse.jdt.core 4 4 2020-09-30 21:11:15.069
!MESSAGE Could not retrieve declared methods
!STACK 0
org.eclipse.jdt.internal.compiler.problem.AbortCompilation: Pb(324) The type java.lang.annotation.Annotation cannot be resolved. It is indirectly referenced from required .class files
	at org.eclipse.jdt.internal.compiler.problem.ProblemHandler.handle(ProblemHandler.java:162)
	at org.eclipse.jdt.internal.compiler.problem.ProblemHandler.handle(ProblemHandler.java:229)
	at org.eclipse.jdt.internal.compiler.problem.ProblemReporter.handle(ProblemReporter.java:2611)
	at org.eclipse.jdt.internal.compiler.problem.ProblemReporter.isClassPathCorrect(ProblemReporter.java:5068)
	at org.eclipse.jdt.internal.compiler.lookup.UnresolvedReferenceBinding.resolve(UnresolvedReferenceBinding.java:123)
	at org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.resolveType(BinaryTypeBinding.java:243)
	at org.eclipse.jdt.internal.compiler.lookup.TypeVariableBinding.resolve(TypeVariableBinding.java:805)
	at org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.resolveType(BinaryTypeBinding.java:233)
	at org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.resolveType(BinaryTypeBinding.java:224)
	at org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.resolveTypesFor(BinaryTypeBinding.java:1666)
	at org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.methods(BinaryTypeBinding.java:1610)
	at org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding.methods(ParameterizedTypeBinding.java:1135)
	at org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding.availableMethods(ReferenceBinding.java:275)
	at org.eclipse.jdt.core.dom.TypeBinding.getDeclaredMethods(TypeBinding.java:293)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:156)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:114)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:152)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:106)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerMethodBinding.<init>(DesignerMethodBinding.java:53)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:87)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:160)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:146)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:114)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:122)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:130)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:106)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:146)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:114)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerMethodBinding.<init>(DesignerMethodBinding.java:53)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:87)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:160)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:106)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerMethodBinding.<init>(DesignerMethodBinding.java:59)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:87)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:160)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:106)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerMethodBinding.<init>(DesignerMethodBinding.java:53)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:87)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:160)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:146)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:114)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerMethodBinding.<init>(DesignerMethodBinding.java:59)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:87)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:160)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:106)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerMethodBinding.<init>(DesignerMethodBinding.java:53)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:87)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:160)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:152)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:114)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:152)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerMethodBinding.<init>(DesignerMethodBinding.java:53)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:87)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:160)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:152)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerMethodBinding.<init>(DesignerMethodBinding.java:59)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:87)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:160)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:146)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:146)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerMethodBinding.<init>(DesignerMethodBinding.java:67)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:87)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:160)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:146)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:145)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.AstParser$3.postVisit(AstParser.java:946)
	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2974)
	at org.eclipse.jdt.core.dom.ASTNode.acceptChild(ASTNode.java:3019)
	at org.eclipse.jdt.core.dom.TypeDeclaration.accept0(TypeDeclaration.java:443)
	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2971)
	at org.eclipse.wb.internal.core.utils.ast.AstParser.copyBindings(AstParser.java:925)
	at org.eclipse.wb.internal.core.utils.ast.AstParser.findNode0(AstParser.java:827)
	at org.eclipse.wb.internal.core.utils.ast.AstParser.findNode(AstParser.java:770)
	at org.eclipse.wb.internal.core.utils.ast.AstParser.parseBodyDeclaration(AstParser.java:179)
	at org.eclipse.wb.internal.core.utils.ast.AstEditor.addBodyDeclaration(AstEditor.java:2581)
	at org.eclipse.wb.internal.core.utils.ast.AstEditor.addTypeDeclaration(AstEditor.java:2371)
	at org.eclipse.wb.internal.core.model.util.live.AbstractLiveManager.parse(AbstractLiveManager.java:181)
	at org.eclipse.wb.internal.swing.model.component.live.SwingLiveManager.createLiveComponent(SwingLiveManager.java:56)
	at org.eclipse.wb.internal.core.model.util.live.AbstractLiveManager.createCacheEntryEx(AbstractLiveManager.java:103)
	at org.eclipse.wb.internal.core.model.util.live.AbstractLiveManager.createCacheEntry(AbstractLiveManager.java:82)
	at org.eclipse.wb.internal.core.model.util.live.AbstractLiveManager.getCachedEntry(AbstractLiveManager.java:264)
	at org.eclipse.wb.internal.core.model.util.live.AbstractLiveManager.getCachedEntry(AbstractLiveManager.java:245)
	at org.eclipse.wb.internal.swing.model.component.live.SwingLiveManager.getImage(SwingLiveManager.java:131)
	at org.eclipse.wb.internal.swing.model.component.ComponentInfo.getLiveImage(ComponentInfo.java:259)
	at org.eclipse.wb.core.model.AbstractComponentInfo.getImage(AbstractComponentInfo.java:165)
	at org.eclipse.wb.internal.core.gef.policy.layout.absolute.AbsoluteBasedLayoutEditPolicy.showCreationFeedback(AbsoluteBasedLayoutEditPolicy.java:614)
	at org.eclipse.wb.internal.core.gef.policy.layout.absolute.AbsoluteBasedLayoutEditPolicy.showLayoutTargetFeedback(AbsoluteBasedLayoutEditPolicy.java:307)
	at org.eclipse.wb.gef.graphical.policies.LayoutEditPolicy.showTargetFeedback(LayoutEditPolicy.java:210)
	at org.eclipse.wb.gef.core.EditPart.showTargetFeedback(EditPart.java:827)
	at org.eclipse.wb.gef.core.tools.TargetingTool.showTargetFeedback(TargetingTool.java:242)
	at org.eclipse.wb.gef.core.tools.TargetingTool.handleEnteredEditPart(TargetingTool.java:99)
	at org.eclipse.wb.gef.core.tools.TargetingTool.setTargetEditPart(TargetingTool.java:76)
	at org.eclipse.wb.gef.core.tools.TargetingTool.updateTargetUnderMouse(TargetingTool.java:177)
	at org.eclipse.wb.gef.core.tools.AbstractCreationTool.handleMove(AbstractCreationTool.java:73)
	at org.eclipse.wb.gef.core.tools.Tool.mouseMove(Tool.java:426)
	at org.eclipse.wb.internal.gef.core.EditDomain.mouseMove(EditDomain.java:266)
	at org.eclipse.wb.internal.gef.graphical.EditEventManager.mouseMove(EditEventManager.java:170)
	at jdk.internal.reflect.GeneratedMethodAccessor70.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.wb.internal.draw2d.EventManager$8.invoke(EventManager.java:325)
	at com.sun.proxy.$Proxy24.mouseMove(Unknown Source)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:216)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4213)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1037)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4030)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3630)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1158)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1047)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:658)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:557)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:154)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:137)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:107)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1447)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-30 21:11:15.089
!MESSAGE Could not retrieve declared methods
!STACK 0
org.eclipse.jdt.internal.compiler.problem.AbortCompilation: Pb(324) The type java.lang.annotation.Annotation cannot be resolved. It is indirectly referenced from required .class files
	at org.eclipse.jdt.internal.compiler.problem.ProblemHandler.handle(ProblemHandler.java:162)
	at org.eclipse.jdt.internal.compiler.problem.ProblemHandler.handle(ProblemHandler.java:229)
	at org.eclipse.jdt.internal.compiler.problem.ProblemReporter.handle(ProblemReporter.java:2611)
	at org.eclipse.jdt.internal.compiler.problem.ProblemReporter.isClassPathCorrect(ProblemReporter.java:5068)
	at org.eclipse.jdt.internal.compiler.lookup.UnresolvedReferenceBinding.resolve(UnresolvedReferenceBinding.java:123)
	at org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.resolveType(BinaryTypeBinding.java:243)
	at org.eclipse.jdt.internal.compiler.lookup.TypeVariableBinding.resolve(TypeVariableBinding.java:805)
	at org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.resolveType(BinaryTypeBinding.java:233)
	at org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.resolveType(BinaryTypeBinding.java:224)
	at org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.resolveTypesFor(BinaryTypeBinding.java:1666)
	at org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.methods(BinaryTypeBinding.java:1610)
	at org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding.methods(ParameterizedTypeBinding.java:1135)
	at org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding.availableMethods(ReferenceBinding.java:275)
	at org.eclipse.jdt.core.dom.TypeBinding.getDeclaredMethods(TypeBinding.java:293)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:156)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:114)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerMethodBinding.<init>(DesignerMethodBinding.java:53)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:87)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:160)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:146)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerMethodBinding.<init>(DesignerMethodBinding.java:59)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:87)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:160)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerMethodBinding.<init>(DesignerMethodBinding.java:59)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:87)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:160)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:139)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerMethodBinding.<init>(DesignerMethodBinding.java:59)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:87)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:160)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerMethodBinding.<init>(DesignerMethodBinding.java:53)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:87)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:160)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerMethodBinding.<init>(DesignerMethodBinding.java:53)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:87)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:160)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerMethodBinding.<init>(DesignerMethodBinding.java:59)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:87)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:160)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerMethodBinding.<init>(DesignerMethodBinding.java:53)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:87)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:160)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerMethodBinding.<init>(DesignerMethodBinding.java:59)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:87)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:160)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerMethodBinding.<init>(DesignerMethodBinding.java:59)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:87)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:160)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerMethodBinding.<init>(DesignerMethodBinding.java:67)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:87)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:160)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:152)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerMethodBinding.<init>(DesignerMethodBinding.java:59)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:87)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:160)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerMethodBinding.<init>(DesignerMethodBinding.java:53)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:87)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:160)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerMethodBinding.<init>(DesignerMethodBinding.java:59)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:87)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:160)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerMethodBinding.<init>(DesignerMethodBinding.java:59)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:87)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:160)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerMethodBinding.<init>(DesignerMethodBinding.java:59)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:87)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:160)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerMethodBinding.<init>(DesignerMethodBinding.java:59)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:87)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:160)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:106)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerMethodBinding.<init>(DesignerMethodBinding.java:53)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:87)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:160)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:146)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:114)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:122)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:130)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:106)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:146)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:114)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerMethodBinding.<init>(DesignerMethodBinding.java:53)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:87)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:160)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:106)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerMethodBinding.<init>(DesignerMethodBinding.java:59)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:87)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:160)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:106)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerMethodBinding.<init>(DesignerMethodBinding.java:53)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:87)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:160)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:146)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:114)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerMethodBinding.<init>(DesignerMethodBinding.java:59)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:87)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:160)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:106)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerMethodBinding.<init>(DesignerMethodBinding.java:53)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:87)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:160)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:152)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:114)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:152)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerMethodBinding.<init>(DesignerMethodBinding.java:53)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:87)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:160)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:152)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerMethodBinding.<init>(DesignerMethodBinding.java:59)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:87)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:160)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:146)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:146)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerMethodBinding.<init>(DesignerMethodBinding.java:67)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:87)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:160)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:146)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:145)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.AstParser$3.postVisit(AstParser.java:946)
	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2974)
	at org.eclipse.jdt.core.dom.ASTNode.acceptChild(ASTNode.java:3019)
	at org.eclipse.jdt.core.dom.TypeDeclaration.accept0(TypeDeclaration.java:443)
	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2971)
	at org.eclipse.wb.internal.core.utils.ast.AstParser.copyBindings(AstParser.java:925)
	at org.eclipse.wb.internal.core.utils.ast.AstParser.findNode0(AstParser.java:827)
	at org.eclipse.wb.internal.core.utils.ast.AstParser.findNode(AstParser.java:770)
	at org.eclipse.wb.internal.core.utils.ast.AstParser.parseBodyDeclaration(AstParser.java:179)
	at org.eclipse.wb.internal.core.utils.ast.AstEditor.addBodyDeclaration(AstEditor.java:2581)
	at org.eclipse.wb.internal.core.utils.ast.AstEditor.addTypeDeclaration(AstEditor.java:2371)
	at org.eclipse.wb.internal.core.model.util.live.AbstractLiveManager.parse(AbstractLiveManager.java:181)
	at org.eclipse.wb.internal.swing.model.component.live.SwingLiveManager.createLiveComponent(SwingLiveManager.java:56)
	at org.eclipse.wb.internal.core.model.util.live.AbstractLiveManager.createCacheEntryEx(AbstractLiveManager.java:103)
	at org.eclipse.wb.internal.core.model.util.live.AbstractLiveManager.createCacheEntry(AbstractLiveManager.java:82)
	at org.eclipse.wb.internal.core.model.util.live.AbstractLiveManager.getCachedEntry(AbstractLiveManager.java:264)
	at org.eclipse.wb.internal.core.model.util.live.AbstractLiveManager.getCachedEntry(AbstractLiveManager.java:245)
	at org.eclipse.wb.internal.swing.model.component.live.SwingLiveManager.getImage(SwingLiveManager.java:131)
	at org.eclipse.wb.internal.swing.model.component.ComponentInfo.getLiveImage(ComponentInfo.java:259)
	at org.eclipse.wb.core.model.AbstractComponentInfo.getImage(AbstractComponentInfo.java:165)
	at org.eclipse.wb.internal.core.gef.policy.layout.absolute.AbsoluteBasedLayoutEditPolicy.showCreationFeedback(AbsoluteBasedLayoutEditPolicy.java:614)
	at org.eclipse.wb.internal.core.gef.policy.layout.absolute.AbsoluteBasedLayoutEditPolicy.showLayoutTargetFeedback(AbsoluteBasedLayoutEditPolicy.java:307)
	at org.eclipse.wb.gef.graphical.policies.LayoutEditPolicy.showTargetFeedback(LayoutEditPolicy.java:210)
	at org.eclipse.wb.gef.core.EditPart.showTargetFeedback(EditPart.java:827)
	at org.eclipse.wb.gef.core.tools.TargetingTool.showTargetFeedback(TargetingTool.java:242)
	at org.eclipse.wb.gef.core.tools.TargetingTool.handleEnteredEditPart(TargetingTool.java:99)
	at org.eclipse.wb.gef.core.tools.TargetingTool.setTargetEditPart(TargetingTool.java:76)
	at org.eclipse.wb.gef.core.tools.TargetingTool.updateTargetUnderMouse(TargetingTool.java:177)
	at org.eclipse.wb.gef.core.tools.AbstractCreationTool.handleMove(AbstractCreationTool.java:73)
	at org.eclipse.wb.gef.core.tools.Tool.mouseMove(Tool.java:426)
	at org.eclipse.wb.internal.gef.core.EditDomain.mouseMove(EditDomain.java:266)
	at org.eclipse.wb.internal.gef.graphical.EditEventManager.mouseMove(EditEventManager.java:170)
	at jdk.internal.reflect.GeneratedMethodAccessor70.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.wb.internal.draw2d.EventManager$8.invoke(EventManager.java:325)
	at com.sun.proxy.$Proxy24.mouseMove(Unknown Source)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:216)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4213)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1037)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4030)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3630)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1158)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1047)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:658)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:557)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:154)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:137)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:107)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1447)

!ENTRY org.eclipse.jdt.core 4 4 2020-09-30 21:11:15.101
!MESSAGE Could not retrieve declared methods
!STACK 0
org.eclipse.jdt.internal.compiler.problem.AbortCompilation: Pb(324) The type java.lang.annotation.Annotation cannot be resolved. It is indirectly referenced from required .class files
	at org.eclipse.jdt.internal.compiler.problem.ProblemHandler.handle(ProblemHandler.java:162)
	at org.eclipse.jdt.internal.compiler.problem.ProblemHandler.handle(ProblemHandler.java:229)
	at org.eclipse.jdt.internal.compiler.problem.ProblemReporter.handle(ProblemReporter.java:2611)
	at org.eclipse.jdt.internal.compiler.problem.ProblemReporter.isClassPathCorrect(ProblemReporter.java:5068)
	at org.eclipse.jdt.internal.compiler.lookup.UnresolvedReferenceBinding.resolve(UnresolvedReferenceBinding.java:123)
	at org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.resolveType(BinaryTypeBinding.java:243)
	at org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.resolveType(BinaryTypeBinding.java:224)
	at org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.resolveTypesFor(BinaryTypeBinding.java:1666)
	at org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.methods(BinaryTypeBinding.java:1610)
	at org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding.methods(ParameterizedTypeBinding.java:1135)
	at org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding.availableMethods(ReferenceBinding.java:275)
	at org.eclipse.jdt.core.dom.TypeBinding.getDeclaredMethods(TypeBinding.java:293)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:156)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerMethodBinding.<init>(DesignerMethodBinding.java:59)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:87)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:160)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerMethodBinding.<init>(DesignerMethodBinding.java:59)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:87)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:160)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:139)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerMethodBinding.<init>(DesignerMethodBinding.java:59)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:87)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:160)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerMethodBinding.<init>(DesignerMethodBinding.java:53)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:87)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:160)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerMethodBinding.<init>(DesignerMethodBinding.java:53)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:87)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:160)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerMethodBinding.<init>(DesignerMethodBinding.java:59)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:87)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:160)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerMethodBinding.<init>(DesignerMethodBinding.java:53)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:87)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:160)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerMethodBinding.<init>(DesignerMethodBinding.java:59)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:87)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:160)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerMethodBinding.<init>(DesignerMethodBinding.java:59)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:87)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:160)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerMethodBinding.<init>(DesignerMethodBinding.java:67)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:87)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:160)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:152)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerMethodBinding.<init>(DesignerMethodBinding.java:59)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:87)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:160)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerMethodBinding.<init>(DesignerMethodBinding.java:53)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:87)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:160)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerMethodBinding.<init>(DesignerMethodBinding.java:59)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:87)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:160)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerMethodBinding.<init>(DesignerMethodBinding.java:59)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:87)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:160)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerMethodBinding.<init>(DesignerMethodBinding.java:59)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:87)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:160)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerMethodBinding.<init>(DesignerMethodBinding.java:59)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:87)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:160)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:106)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerMethodBinding.<init>(DesignerMethodBinding.java:53)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:87)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:160)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:146)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:114)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:122)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:130)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:106)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:146)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:114)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerMethodBinding.<init>(DesignerMethodBinding.java:53)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:87)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:160)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:106)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerMethodBinding.<init>(DesignerMethodBinding.java:59)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:87)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:160)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:106)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerMethodBinding.<init>(DesignerMethodBinding.java:53)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:87)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:160)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:146)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:114)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerMethodBinding.<init>(DesignerMethodBinding.java:59)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:87)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:160)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:106)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerMethodBinding.<init>(DesignerMethodBinding.java:53)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:87)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:160)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:152)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:114)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:152)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerMethodBinding.<init>(DesignerMethodBinding.java:53)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:87)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:160)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:152)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerMethodBinding.<init>(DesignerMethodBinding.java:59)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:87)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:160)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:146)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:146)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerMethodBinding.<init>(DesignerMethodBinding.java:67)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:87)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:160)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:146)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:145)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.AstParser$3.postVisit(AstParser.java:946)
	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2974)
	at org.eclipse.jdt.core.dom.ASTNode.acceptChild(ASTNode.java:3019)
	at org.eclipse.jdt.core.dom.TypeDeclaration.accept0(TypeDeclaration.java:443)
	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2971)
	at org.eclipse.wb.internal.core.utils.ast.AstParser.copyBindings(AstParser.java:925)
	at org.eclipse.wb.internal.core.utils.ast.AstParser.findNode0(AstParser.java:827)
	at org.eclipse.wb.internal.core.utils.ast.AstParser.findNode(AstParser.java:770)
	at org.eclipse.wb.internal.core.utils.ast.AstParser.parseBodyDeclaration(AstParser.java:179)
	at org.eclipse.wb.internal.core.utils.ast.AstEditor.addBodyDeclaration(AstEditor.java:2581)
	at org.eclipse.wb.internal.core.utils.ast.AstEditor.addTypeDeclaration(AstEditor.java:2371)
	at org.eclipse.wb.internal.core.model.util.live.AbstractLiveManager.parse(AbstractLiveManager.java:181)
	at org.eclipse.wb.internal.swing.model.component.live.SwingLiveManager.createLiveComponent(SwingLiveManager.java:56)
	at org.eclipse.wb.internal.core.model.util.live.AbstractLiveManager.createCacheEntryEx(AbstractLiveManager.java:103)
	at org.eclipse.wb.internal.core.model.util.live.AbstractLiveManager.createCacheEntry(AbstractLiveManager.java:82)
	at org.eclipse.wb.internal.core.model.util.live.AbstractLiveManager.getCachedEntry(AbstractLiveManager.java:264)
	at org.eclipse.wb.internal.core.model.util.live.AbstractLiveManager.getCachedEntry(AbstractLiveManager.java:245)
	at org.eclipse.wb.internal.swing.model.component.live.SwingLiveManager.getImage(SwingLiveManager.java:131)
	at org.eclipse.wb.internal.swing.model.component.ComponentInfo.getLiveImage(ComponentInfo.java:259)
	at org.eclipse.wb.core.model.AbstractComponentInfo.getImage(AbstractComponentInfo.java:165)
	at org.eclipse.wb.internal.core.gef.policy.layout.absolute.AbsoluteBasedLayoutEditPolicy.showCreationFeedback(AbsoluteBasedLayoutEditPolicy.java:614)
	at org.eclipse.wb.internal.core.gef.policy.layout.absolute.AbsoluteBasedLayoutEditPolicy.showLayoutTargetFeedback(AbsoluteBasedLayoutEditPolicy.java:307)
	at org.eclipse.wb.gef.graphical.policies.LayoutEditPolicy.showTargetFeedback(LayoutEditPolicy.java:210)
	at org.eclipse.wb.gef.core.EditPart.showTargetFeedback(EditPart.java:827)
	at org.eclipse.wb.gef.core.tools.TargetingTool.showTargetFeedback(TargetingTool.java:242)
	at org.eclipse.wb.gef.core.tools.TargetingTool.handleEnteredEditPart(TargetingTool.java:99)
	at org.eclipse.wb.gef.core.tools.TargetingTool.setTargetEditPart(TargetingTool.java:76)
	at org.eclipse.wb.gef.core.tools.TargetingTool.updateTargetUnderMouse(TargetingTool.java:177)
	at org.eclipse.wb.gef.core.tools.AbstractCreationTool.handleMove(AbstractCreationTool.java:73)
	at org.eclipse.wb.gef.core.tools.Tool.mouseMove(Tool.java:426)
	at org.eclipse.wb.internal.gef.core.EditDomain.mouseMove(EditDomain.java:266)
	at org.eclipse.wb.internal.gef.graphical.EditEventManager.mouseMove(EditEventManager.java:170)
	at jdk.internal.reflect.GeneratedMethodAccessor70.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.wb.internal.draw2d.EventManager$8.invoke(EventManager.java:325)
	at com.sun.proxy.$Proxy24.mouseMove(Unknown Source)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:216)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4213)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1037)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4030)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3630)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1158)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1047)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:658)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:557)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:154)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:137)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:107)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1447)

!ENTRY org.eclipse.wb.core 4 4 2020-09-30 21:11:15.241
!MESSAGE Designer [1.10.0.201812270937.202009302111]: 205 (Unable to parse source.). 	private static class __Tmp {
	}
 line: 402 The static method main(String[]) from the type Menu should be accessed in a static way
!STACK 0
org.eclipse.wb.internal.core.utils.exception.DesignerException: 205 (Unable to parse source.). 	private static class __Tmp {
	}
 line: 402 The static method main(String[]) from the type Menu should be accessed in a static way
	at org.eclipse.wb.internal.core.utils.ast.AstParser.parseBodyDeclaration(AstParser.java:182)
	at org.eclipse.wb.internal.core.utils.ast.AstEditor.addBodyDeclaration(AstEditor.java:2581)
	at org.eclipse.wb.internal.core.utils.ast.AstEditor.addTypeDeclaration(AstEditor.java:2371)
	at org.eclipse.wb.internal.core.model.util.live.AbstractLiveManager.parse(AbstractLiveManager.java:181)
	at org.eclipse.wb.internal.swing.model.component.live.SwingLiveManager.createLiveComponent(SwingLiveManager.java:56)
	at org.eclipse.wb.internal.core.model.util.live.AbstractLiveManager.createCacheEntryEx(AbstractLiveManager.java:103)
	at org.eclipse.wb.internal.core.model.util.live.AbstractLiveManager.createCacheEntry(AbstractLiveManager.java:82)
	at org.eclipse.wb.internal.core.model.util.live.AbstractLiveManager.getCachedEntry(AbstractLiveManager.java:264)
	at org.eclipse.wb.internal.core.model.util.live.AbstractLiveManager.getCachedEntry(AbstractLiveManager.java:245)
	at org.eclipse.wb.internal.swing.model.component.live.SwingLiveManager.getImage(SwingLiveManager.java:131)
	at org.eclipse.wb.internal.swing.model.component.ComponentInfo.getLiveImage(ComponentInfo.java:259)
	at org.eclipse.wb.core.model.AbstractComponentInfo.getImage(AbstractComponentInfo.java:165)
	at org.eclipse.wb.internal.core.gef.policy.layout.absolute.AbsoluteBasedLayoutEditPolicy.showCreationFeedback(AbsoluteBasedLayoutEditPolicy.java:614)
	at org.eclipse.wb.internal.core.gef.policy.layout.absolute.AbsoluteBasedLayoutEditPolicy.showLayoutTargetFeedback(AbsoluteBasedLayoutEditPolicy.java:307)
	at org.eclipse.wb.gef.graphical.policies.LayoutEditPolicy.showTargetFeedback(LayoutEditPolicy.java:210)
	at org.eclipse.wb.gef.core.EditPart.showTargetFeedback(EditPart.java:827)
	at org.eclipse.wb.gef.core.tools.TargetingTool.showTargetFeedback(TargetingTool.java:242)
	at org.eclipse.wb.gef.core.tools.TargetingTool.handleEnteredEditPart(TargetingTool.java:99)
	at org.eclipse.wb.gef.core.tools.TargetingTool.setTargetEditPart(TargetingTool.java:76)
	at org.eclipse.wb.gef.core.tools.TargetingTool.updateTargetUnderMouse(TargetingTool.java:177)
	at org.eclipse.wb.gef.core.tools.AbstractCreationTool.handleMove(AbstractCreationTool.java:73)
	at org.eclipse.wb.gef.core.tools.Tool.mouseMove(Tool.java:426)
	at org.eclipse.wb.internal.gef.core.EditDomain.mouseMove(EditDomain.java:266)
	at org.eclipse.wb.internal.gef.graphical.EditEventManager.mouseMove(EditEventManager.java:170)
	at jdk.internal.reflect.GeneratedMethodAccessor70.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.wb.internal.draw2d.EventManager$8.invoke(EventManager.java:325)
	at com.sun.proxy.$Proxy24.mouseMove(Unknown Source)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:216)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4213)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1037)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4030)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3630)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1158)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1047)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:658)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:557)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:154)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:137)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:107)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1447)
Caused by: org.eclipse.wb.internal.core.utils.exception.DesignerException: 205 (Unable to parse source.). import java.awt.EventQueue;

import javax.swing.JFrame;
import javax.swing.BoxLayout;
import javax.swing.GroupLayout;
import javax.swing.GroupLayout.Alignment;
import java.awt.FlowLayout;
import javax.swing.JPanel;
import java.awt.BorderLayout;
import javax.swing.JLabel;
import javax.swing.JOptionPane;

import java.awt.Font;
import java.awt.Graphics;
import java.awt.Insets;
import java.awt.Point;

import javax.swing.JTextField;
import javax.swing.JButton;
import java.awt.event.ActionListener;
import java.awt.event.ActionEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.Vector;
import javax.swing.ImageIcon;
import java.awt.event.FocusAdapter;
import java.awt.event.FocusEvent;
import javax.swing.border.TitledBorder;

import javax.swing.border.Border;
import javax.swing.border.EtchedBorder;
import java.awt.Color;
import java.awt.Component;

import javax.swing.SwingConstants;
import java.awt.SystemColor;
import javax.swing.UIManager;
import javax.swing.border.EmptyBorder;
import javax.swing.border.BevelBorder;
import java.awt.Toolkit;

public class ConfigurationView {

	private JFrame frmConfiguration;
	private JTextField nbre_ligne_Field;
	private  JTextField nbre_colonne_Field;
	private JTextField nom1;
	private JTextField nom2;
	public ConfigurationModel configuration = new ConfigurationModel();
	GridLayoutManager gridLayoutManager;
	private boolean grilleCreated = false ; 
	
	public static boolean tryParseInt(String value) {  //on test si on peut convertir un string vers un entier
	     try {  
	         Integer.parseInt(value);  
	         return true;  
	      } catch (NumberFormatException e) {  
	         return false;  
	      }  
	}
	

	/**
	 * Create the application.
	 */
	public ConfigurationView() { // constructeur
		initialize();
	}

	/**
	 * Initialize the contents of the frame.
	 */
	private void initialize() { // 
		frmConfiguration = new JFrame();
		frmConfiguration.setIconImage(Toolkit.getDefaultToolkit().getImage("resources\\SettingsIcon.png"));
		frmConfiguration.setTitle("Configuration");
		frmConfiguration.setBounds(500, 250, 750, 600);
		frmConfiguration.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
		frmConfiguration.getContentPane().setLayout(null);
		frmConfiguration.setResizable(false);
		frmConfiguration.setUndecorated(true);
		frmConfiguration.setVisible(true);
		
		JPanel LigneColonnePanel = new JPanel();
		LigneColonnePanel.setBorder(new BevelBorder(BevelBorder.LOWERED, new Color(191, 205, 219), SystemColor.activeCaption, null, null));
		LigneColonnePanel.setBackground(Color.DARK_GRAY);
		LigneColonnePanel.setBounds(202, 36, 332, 111);
		frmConfiguration.getContentPane().add(LigneColonnePanel);
		LigneColonnePanel.setLayout(null);
		
		JLabel lblNewLabel = new JLabel("Nombre de ligne : ");
		lblNewLabel.setBounds(10, 11, 199, 37);
		LigneColonnePanel.add(lblNewLabel);
		lblNewLabel.setBackground(SystemColor.info);
		lblNewLabel.setForeground(Color.LIGHT_GRAY);
		lblNewLabel.setFont(new Font("Tahoma", Font.PLAIN, 20));
		
		JLabel lblNombreDeColonne = new JLabel("Nombre de colonne : ");
		lblNombreDeColonne.setForeground(Color.LIGHT_GRAY);
		lblNombreDeColonne.setBounds(10, 63, 199, 37);
		LigneColonnePanel.add(lblNombreDeColonne);
		lblNombreDeColonne.setBackground(SystemColor.inactiveCaption);
		lblNombreDeColonne.setFont(new Font("Tahoma", Font.PLAIN, 20));
		
		nbre_ligne_Field = new JTextField();
		nbre_ligne_Field.setForeground(Color.LIGHT_GRAY);
		nbre_ligne_Field.setBounds(209, 11, 96, 37);
		LigneColonnePanel.add(nbre_ligne_Field);
		nbre_ligne_Field.setBackground(Color.GRAY);
		nbre_ligne_Field.setHorizontalAlignment(SwingConstants.CENTER);
		nbre_ligne_Field.setText("15");
		nbre_ligne_Field.addFocusListener(new FocusAdapter() {
			@Override
			public void focusLost(FocusEvent e) {
				if(nbre_ligne_Field.getText().isEmpty() == false )
				{ int n=0; 
					if (tryParseInt(nbre_ligne_Field.getText())  ) {
						n=Integer.parseInt(nbre_ligne_Field.getText());
					}else JOptionPane.showMessageDialog(null, "Entrer un entier !");
					if(n != 0)
					{
						configuration.nbre_ligne=n;
						
					}else JOptionPane.showMessageDialog(null, "le nombre de ligne  ne doit pas etre 0");
				}else JOptionPane.showMessageDialog(null, "Saisir le nombre de ligne ");
			}
		});
		nbre_ligne_Field.setFont(new Font("Tahoma", Font.PLAIN, 20));
		nbre_ligne_Field.setColumns(3);
		
		
		
		nbre_colonne_Field = new JTextField();
		nbre_colonne_Field.setForeground(Color.LIGHT_GRAY);
		nbre_colonne_Field.setBounds(209, 63, 96, 37);
		LigneColonnePanel.add(nbre_colonne_Field);
		nbre_colonne_Field.setBackground(Color.GRAY);
		nbre_colonne_Field.setHorizontalAlignment(SwingConstants.CENTER);
		nbre_colonne_Field.setText("30");
		nbre_colonne_Field.addFocusListener(new FocusAdapter() {
			@Override
			public void focusLost(FocusEvent e) {
				if(nbre_colonne_Field.getText().isEmpty() == false )
				{ int n=0; 
					if (tryParseInt(nbre_colonne_Field.getText())  ) {
						n=Integer.parseInt(nbre_colonne_Field.getText());
					}else JOptionPane.showMessageDialog(null, "Entrer un entier !");
					if(n != 0)
					{
						configuration.nbre_colonne=n;
					}else JOptionPane.showMessageDialog(null, "le nombre de colonne  ne doit pas etre 0 !");
				}else JOptionPane.showMessageDialog(null, "Saisir le nombre de colonne ! ");
			}
		});
		nbre_colonne_Field.setFont(new Font("Tahoma", Font.PLAIN, 20));
		nbre_colonne_Field.setColumns(3);
		
		JButton btnObstacleButton = new JButton("Obstacle");
		btnObstacleButton.setForeground(Color.LIGHT_GRAY);
		btnObstacleButton.setBackground(Color.DARK_GRAY);
		btnObstacleButton.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseClicked(MouseEvent e) {
				
				nbre_ligne_Field.setEditable(false);
				nbre_colonne_Field.setEditable(false);
				if (grilleCreated == false) {
					gridLayoutManager=new GridLayoutManager(configuration);
					grilleCreated = true;
				}
				gridLayoutManager.SetEmplacement("Obstacle");
				gridLayoutManager.setVisible(true);
				
			}
			
			@Override
			public void mouseEntered(MouseEvent e) {
				btnObstacleButton.setBackground(SystemColor.gray);
			}
			@Override
			public void mouseExited(MouseEvent e) {
				btnObstacleButton.setBackground(SystemColor.DARK_GRAY);
			}
		});
		btnObstacleButton.setFont(new Font("Tahoma", Font.PLAIN, 20));
		btnObstacleButton.setBounds(83, 181, 127, 50);
		frmConfiguration.getContentPane().add(btnObstacleButton);
		
		JButton btnSacButton = new JButton("Sac");
		btnSacButton.setForeground(Color.LIGHT_GRAY);
		btnSacButton.setBackground(Color.DARK_GRAY);
		btnSacButton.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseClicked(MouseEvent e) {
				nbre_ligne_Field.setEditable(false);
				nbre_colonne_Field.setEditable(false);
				if (grilleCreated == false) {
					gridLayoutManager=new GridLayoutManager(configuration);
					grilleCreated = true;
				}
				gridLayoutManager.SetEmplacement("Sac");
				gridLayoutManager.setVisible(true);
				
				
			}
			@Override
			public void mouseEntered(MouseEvent e) {
				btnSacButton.setBackground(SystemColor.gray);
			}
			@Override
			public void mouseExited(MouseEvent e) {
				btnSacButton.setBackground(SystemColor.darkGray);
			}
		});
		btnSacButton.setFont(new Font("Tahoma", Font.PLAIN, 20));
		btnSacButton.setBounds(298, 181, 127, 50);
		frmConfiguration.getContentPane().add(btnSacButton);
		
		JButton btnSortieButton = new JButton("Sortie");
		btnSortieButton.setForeground(Color.LIGHT_GRAY);
		btnSortieButton.setBackground(Color.DARK_GRAY);
		btnSortieButton.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseClicked(MouseEvent e) {
				nbre_ligne_Field.setEditable(false);
				nbre_colonne_Field.setEditable(false);
				if (grilleCreated == false) {
					gridLayoutManager=new GridLayoutManager(configuration);
					grilleCreated = true;
				}
				gridLayoutManager.SetEmplacement("Sortie");
				gridLayoutManager.setVisible(true);
			}
			@Override
			public void mouseEntered(MouseEvent e) {
				btnSortieButton.setBackground(SystemColor.gray);
			}
			@Override
			public void mouseExited(MouseEvent e) {
				btnSortieButton.setBackground(SystemColor.darkGray);
			}
		});
		btnSortieButton.setFont(new Font("Tahoma", Font.PLAIN, 20));
		btnSortieButton.setBounds(523, 181, 127, 50);
		frmConfiguration.getContentPane().add(btnSortieButton);
		
		JPanel Joueur1Panel = new JPanel();
		Joueur1Panel.setBackground(Color.DARK_GRAY);
		Joueur1Panel.setBorder(new TitledBorder(new EtchedBorder(EtchedBorder.LOWERED, new Color(255, 255, 255), new Color(160, 160, 160)), "Joueur 1 ", TitledBorder.CENTER, TitledBorder.TOP, null, new Color(0, 0, 0)));
		Joueur1Panel.setBounds(40, 271, 274, 160);
		frmConfiguration.getContentPane().add(Joueur1Panel);
		Joueur1Panel.setLayout(null);
		
		JButton btnRobotButton = new JButton("G\u00E9rer les emplacements des robots");
		btnRobotButton.setBackground(Color.GRAY);
		btnRobotButton.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseClicked(MouseEvent e) {
				nbre_ligne_Field.setEditable(false);
				nbre_colonne_Field.setEditable(false);
				if (grilleCreated == false) {
					gridLayoutManager=new GridLayoutManager(configuration);
					grilleCreated = true;
				}
				gridLayoutManager.SetEmplacement("Robots");
				gridLayoutManager.setVisible(true);
			}
			@Override
			public void mouseEntered(MouseEvent e) {
				btnRobotButton.setBackground(SystemColor.lightGray);
			}
			@Override
			public void mouseExited(MouseEvent e) {
				btnRobotButton.setBackground(SystemColor.gray);
			}
		});
		btnRobotButton.setBounds(10, 83, 250, 37);
		Joueur1Panel.add(btnRobotButton);
		btnRobotButton.setFont(new Font("Tahoma", Font.BOLD, 11));
		
		JLabel lblNewLabel_4 = new JLabel(configuration.Nom_joueur1);
		lblNewLabel_4.setForeground(Color.LIGHT_GRAY);
		lblNewLabel_4.setBounds(84, 22, 146, 18);
		Joueur1Panel.add(lblNewLabel_4);
		lblNewLabel_4.setFont(new Font("Tahoma", Font.PLAIN, 15));
		
		nom1 = new JTextField();
		nom1.setText("joueur 1");
		nom1.setBackground(Color.LIGHT_GRAY);
		nom1.addFocusListener(new FocusAdapter() {
			@Override
			public void focusLost(FocusEvent e) {
				configuration.Nom_joueur1 = nom1.getText();
			}
			
		});
		nom1.setBounds(10, 47, 250, 25);
		Joueur1Panel.add(nom1);
		nom1.setFont(new Font("Tahoma", Font.PLAIN, 15));
		nom1.setColumns(10);
		
		
		JPanel Joueur2Panel = new JPanel();
		Joueur2Panel.setBackground(Color.DARK_GRAY);
		Joueur2Panel.setBorder(new TitledBorder(new EtchedBorder(EtchedBorder.LOWERED, new Color(255, 255, 255), new Color(160, 160, 160)), "Joueur 2 :", TitledBorder.CENTER, TitledBorder.TOP, null, new Color(0, 0, 0)));
		Joueur2Panel.setBounds(421, 271, 274, 160);
		frmConfiguration.getContentPane().add(Joueur2Panel);
		Joueur2Panel.setLayout(null);
		
		JButton btnIntruButton = new JButton("G\u00E9rer les emplacements des intrus");
		btnIntruButton.setBackground(Color.GRAY);
		btnIntruButton.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseClicked(MouseEvent e) {
				nbre_ligne_Field.setEditable(false);
				nbre_colonne_Field.setEditable(false);
				if (grilleCreated == false) {
					gridLayoutManager=new GridLayoutManager(configuration);
					grilleCreated = true;
				}
				gridLayoutManager.SetEmplacement("Intrus");
				gridLayoutManager.setVisible(true);
			}
			@Override
			public void mouseEntered(MouseEvent e) {
				btnIntruButton.setBackground(SystemColor.lightGray);
			}
			@Override
			public void mouseExited(MouseEvent e) {
				btnIntruButton.setBackground(SystemColor.gray);

			}
		});
		btnIntruButton.setBounds(16, 81, 246, 37);
		Joueur2Panel.add(btnIntruButton);
		btnIntruButton.setFont(new Font("Tahoma", Font.BOLD, 11));
		
		JLabel label = new JLabel(configuration.Nom_joueur2);
		label.setForeground(Color.LIGHT_GRAY);
		label.setBounds(84, 19, 146, 18);
		Joueur2Panel.add(label);
		label.setFont(new Font("Tahoma", Font.PLAIN, 15));
		
		nom2 = new JTextField();
		nom2.setBackground(Color.LIGHT_GRAY);
		nom2.setText("joueur 2");
		nom2.addFocusListener(new FocusAdapter() {
			@Override
			public void focusLost(FocusEvent e) {
				configuration.Nom_joueur2=nom2.getText();
			}
		});
		nom2.setBounds(16, 48, 246, 25);
		Joueur2Panel.add(nom2);
		nom2.setFont(new Font("Tahoma", Font.PLAIN, 15));
		nom2.setColumns(10);
		
		JButton btnStartButton = new JButton("Commencer le jeu ");
		btnStartButton.setForeground(Color.LIGHT_GRAY);
		btnStartButton.setBackground(Color.DARK_GRAY);
		btnStartButton.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseClicked(MouseEvent e) {
				
				
				if(configuration.Emplac_Intrus.size() !=0  && configuration.Emplac_Robots.size() != 0  &&
						configuration.Emplac_Sac.size() != 0 && configuration.Emplac_Sortie.size() != 0 &&
						!configuration.Nom_joueur1.isEmpty() && !configuration.Nom_joueur2.isEmpty())
				{
					frmConfiguration.dispose();
					gridLayoutManager.dispose();
					Jeu startJeu = new Jeu(configuration);				
					
				}else JOptionPane.showMessageDialog(null, "verifier la configuration ! ..");
				
			}
			@Override
			public void mouseEntered(MouseEvent e) {
				btnStartButton.setBackground(SystemColor.gray);
				
			}
			@Override
			public void mouseExited(MouseEvent e) {
				btnStartButton.setBackground(SystemColor.darkGray);
			}
		});
		btnStartButton.setFont(new Font("Tahoma", Font.PLAIN, 17));
		btnStartButton.setBounds(287, 481, 199, 31);
		frmConfiguration.getContentPane().add(btnStartButton);
		
		JButton btnQuitter = new JButton("Quitter");
		btnQuitter.setForeground(Color.LIGHT_GRAY);
		btnQuitter.setBackground(Color.DARK_GRAY);
		btnQuitter.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseClicked(MouseEvent e) {
				frmConfiguration.dispose();
				if (grilleCreated) {
					gridLayoutManager.dispose();
				}
				Menu window = new Menu();
				window.main(null);
				}
			@Override
			public void mouseEntered(MouseEvent e) {
				btnQuitter.setBackground(SystemColor.gray);
			}
			@Override
			public void mouseExited(MouseEvent e) {
				btnQuitter.setBackground(SystemColor.darkGray);
			}
		});
		
		btnQuitter.setFont(new Font("Tahoma", Font.PLAIN, 17));
		btnQuitter.setBounds(287, 523, 199, 31);
		frmConfiguration.getContentPane().add(btnQuitter);
		
		JLabel Background = new JLabel("New label");
		Background.setForeground(Color.WHITE);
		Background.setIcon(new ImageIcon("resources\\SettingsBackground.png"));
		Background.setBounds(0, 0, 744, 601);
		frmConfiguration.getContentPane().add(Background);
		
		
		
		
		
		
	}
	private static class __Tmp {
	}
}
 line: 402 The static method main(String[]) from the type Menu should be accessed in a static way
	at org.eclipse.wb.internal.core.utils.ast.AstParser.findNode(AstParser.java:773)
	at org.eclipse.wb.internal.core.utils.ast.AstParser.parseBodyDeclaration(AstParser.java:179)
	... 55 more
Caused by: org.eclipse.jdt.internal.compiler.problem.AbortCompilation: Pb(324) The type java.lang.annotation.Annotation cannot be resolved. It is indirectly referenced from required .class files
	at org.eclipse.jdt.internal.compiler.problem.ProblemHandler.handle(ProblemHandler.java:162)
	at org.eclipse.jdt.internal.compiler.problem.ProblemHandler.handle(ProblemHandler.java:229)
	at org.eclipse.jdt.internal.compiler.problem.ProblemReporter.handle(ProblemReporter.java:2611)
	at org.eclipse.jdt.internal.compiler.problem.ProblemReporter.isClassPathCorrect(ProblemReporter.java:5068)
	at org.eclipse.jdt.internal.compiler.lookup.UnresolvedReferenceBinding.resolve(UnresolvedReferenceBinding.java:123)
	at org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.resolveType(BinaryTypeBinding.java:243)
	at org.eclipse.jdt.internal.compiler.lookup.TypeVariableBinding.resolve(TypeVariableBinding.java:805)
	at org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.resolveType(BinaryTypeBinding.java:233)
	at org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.resolveType(BinaryTypeBinding.java:224)
	at org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.resolveTypesFor(BinaryTypeBinding.java:1666)
	at org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.methods(BinaryTypeBinding.java:1610)
	at org.eclipse.jdt.internal.compiler.lookup.TypeVariableBinding.computeUniqueKey(TypeVariableBinding.java:387)
	at org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding.computeUniqueKey(ParameterizedTypeBinding.java:372)
	at org.eclipse.jdt.internal.compiler.lookup.ArrayBinding.computeUniqueKey(ArrayBinding.java:150)
	at org.eclipse.jdt.internal.compiler.lookup.Binding.computeUniqueKey(Binding.java:135)
	at org.eclipse.jdt.core.dom.TypeBinding.getKey(TypeBinding.java:593)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:85)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerMethodBinding.<init>(DesignerMethodBinding.java:53)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:87)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:160)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:106)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerMethodBinding.<init>(DesignerMethodBinding.java:53)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:87)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:160)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:146)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:114)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:122)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:130)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:106)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:146)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:114)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerMethodBinding.<init>(DesignerMethodBinding.java:53)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:87)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:160)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:106)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerMethodBinding.<init>(DesignerMethodBinding.java:59)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:87)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:160)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:106)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerMethodBinding.<init>(DesignerMethodBinding.java:53)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:87)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:160)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:146)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:114)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerMethodBinding.<init>(DesignerMethodBinding.java:59)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:87)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:160)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:106)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerMethodBinding.<init>(DesignerMethodBinding.java:53)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:87)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:160)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:152)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:114)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:152)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerMethodBinding.<init>(DesignerMethodBinding.java:53)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:87)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:160)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:152)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerMethodBinding.<init>(DesignerMethodBinding.java:59)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:87)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:160)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:146)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:146)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerMethodBinding.<init>(DesignerMethodBinding.java:67)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:87)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:160)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:146)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:145)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.AstParser$3.postVisit(AstParser.java:946)
	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2974)
	at org.eclipse.jdt.core.dom.ASTNode.acceptChild(ASTNode.java:3019)
	at org.eclipse.jdt.core.dom.TypeDeclaration.accept0(TypeDeclaration.java:443)
	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2971)
	at org.eclipse.wb.internal.core.utils.ast.AstParser.copyBindings(AstParser.java:925)
	at org.eclipse.wb.internal.core.utils.ast.AstParser.findNode0(AstParser.java:827)
	at org.eclipse.wb.internal.core.utils.ast.AstParser.findNode(AstParser.java:770)
	... 56 more

!ENTRY org.eclipse.jdt.core 4 4 2020-09-30 21:12:02.686
!MESSAGE Could not retrieve interfaces
!STACK 0
org.eclipse.jdt.internal.compiler.problem.AbortCompilation: Pb(324) The type java.lang.annotation.Annotation cannot be resolved. It is indirectly referenced from required .class files
	at org.eclipse.jdt.internal.compiler.problem.ProblemHandler.handle(ProblemHandler.java:162)
	at org.eclipse.jdt.internal.compiler.problem.ProblemHandler.handle(ProblemHandler.java:229)
	at org.eclipse.jdt.internal.compiler.problem.ProblemReporter.handle(ProblemReporter.java:2611)
	at org.eclipse.jdt.internal.compiler.problem.ProblemReporter.isClassPathCorrect(ProblemReporter.java:5068)
	at org.eclipse.jdt.internal.compiler.lookup.UnresolvedReferenceBinding.resolve(UnresolvedReferenceBinding.java:123)
	at org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.resolveType(BinaryTypeBinding.java:243)
	at org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.superInterfaces(BinaryTypeBinding.java:2174)
	at org.eclipse.jdt.core.dom.TypeBinding.getInterfaces(TypeBinding.java:512)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:148)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerMethodBinding.<init>(DesignerMethodBinding.java:59)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:87)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:160)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:146)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerMethodBinding.<init>(DesignerMethodBinding.java:53)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:87)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:160)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:145)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:48)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:152)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:146)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.binding.DesignerTypeBinding.<init>(DesignerTypeBinding.java:146)
	at org.eclipse.wb.internal.core.utils.ast.binding.BindingContext.get(BindingContext.java:70)
	at org.eclipse.wb.internal.core.utils.ast.AstParser$3.postVisit(AstParser.java:946)
	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2974)
	at org.eclipse.jdt.core.dom.ASTNode.acceptChild(ASTNode.java:3019)
	at org.eclipse.jdt.core.dom.QualifiedName.accept0(QualifiedName.java:163)
	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2971)
	at org.eclipse.jdt.core.dom.ASTNode.acceptChild(ASTNode.java:3019)
	at org.eclipse.jdt.core.dom.SimpleType.accept0(SimpleType.java:195)
	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2971)
	at org.eclipse.jdt.core.dom.ASTNode.acceptChild(ASTNode.java:3019)
	at org.eclipse.jdt.core.dom.FieldDeclaration.accept0(FieldDeclaration.java:272)
	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2971)
	at org.eclipse.wb.internal.core.utils.ast.AstParser.copyBindings(AstParser.java:925)
	at org.eclipse.wb.internal.core.utils.ast.AstParser.findNode0(AstParser.java:827)
	at org.eclipse.wb.internal.core.utils.ast.AstParser.findNode(AstParser.java:770)
	at org.eclipse.wb.internal.core.utils.ast.AstParser.parseBodyDeclaration(AstParser.java:179)
	at org.eclipse.wb.internal.core.utils.ast.AstEditor.addBodyDeclaration(AstEditor.java:2538)
	at org.eclipse.wb.internal.core.utils.ast.AstEditor.addFieldDeclaration(AstEditor.java:2076)
	at org.eclipse.wb.internal.core.utils.ast.AstEditor.addFieldDeclaration(AstEditor.java:2068)
	at org.eclipse.wb.internal.core.model.variable.AbstractSimpleVariableSupport.addField(AbstractSimpleVariableSupport.java:547)
	at org.eclipse.wb.internal.core.model.variable.FieldUniqueVariableSupport.add_getVariableStatementSource(FieldUniqueVariableSupport.java:229)
	at org.eclipse.wb.internal.core.model.generation.statement.AbstractInsideStatementGenerator.add(AbstractInsideStatementGenerator.java:68)
	at org.eclipse.wb.internal.core.model.generation.statement.flat.FlatStatementGenerator.add(FlatStatementGenerator.java:66)
	at org.eclipse.wb.internal.core.model.JavaInfoUtils.add(JavaInfoUtils.java:1386)
	at org.eclipse.wb.internal.core.model.JavaInfoUtils.add(JavaInfoUtils.java:1289)
	at org.eclipse.wb.internal.core.model.JavaInfoUtils.add(JavaInfoUtils.java:1225)
	at org.eclipse.wb.internal.swing.model.layout.LayoutInfo.add(LayoutInfo.java:319)
	at org.eclipse.wb.internal.swing.model.layout.absolute.AbstractAbsoluteLayoutInfo.command_CREATE(AbstractAbsoluteLayoutInfo.java:245)
	at org.eclipse.wb.internal.swing.gef.policy.layout.AbsoluteLayoutEditPolicy$3.executeEdit(AbsoluteLayoutEditPolicy.java:236)
	at org.eclipse.wb.core.gef.command.EditCommand$1.run(EditCommand.java:52)
	at org.eclipse.wb.internal.core.utils.execution.ExecutionUtils.run(ExecutionUtils.java:324)
	at org.eclipse.wb.core.gef.command.EditCommand.execute(EditCommand.java:50)
	at org.eclipse.wb.internal.gef.core.EditDomain.executeCommand(EditDomain.java:59)
	at org.eclipse.wb.gef.core.tools.Tool.executeCommand(Tool.java:209)
	at org.eclipse.wb.gef.core.tools.AbstractCreationTool.handleButtonUp(AbstractCreationTool.java:62)
	at org.eclipse.wb.gef.core.tools.Tool.mouseUp(Tool.java:395)
	at org.eclipse.wb.internal.gef.core.EditDomain.mouseUp(EditDomain.java:255)
	at org.eclipse.wb.internal.gef.graphical.EditEventManager.mouseUp(EditEventManager.java:149)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.wb.internal.draw2d.EventManager$8.invoke(EventManager.java:325)
	at com.sun.proxy.$Proxy24.mouseUp(Unknown Source)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:224)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4213)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1037)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4030)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3630)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1158)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1047)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:658)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:557)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:154)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:137)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:107)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1447)
!SESSION 2020-09-30 21:21:36.120 -----------------------------------------------
eclipse.buildId=4.16.0.I20200604-0540
java.version=14.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=fr_FR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.core.resources 2 10035 2020-09-30 21:21:44.279
!MESSAGE The workspace exited with unsaved changes in the previous session; refreshing workspace to recover changes.

!ENTRY org.eclipse.jface 2 0 2020-09-30 21:21:48.130
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2020-09-30 21:21:48.130
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@13047d3d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4b240276,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2020-09-30 21:21:54.964
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\ayadi'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.ui 4 0 2020-09-30 21:24:58.765
!MESSAGE Unhandled event loop exception
!STACK 0
org.eclipse.e4.core.di.InjectionException: org.eclipse.swt.SWTException: i/o error (java.io.FileNotFoundException: C:\Program Files\Git\mingw64\share\git\git-for-windows.ico (Le chemin d’accès spécifié est introuvable))
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:68)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:236)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4735)
	at org.eclipse.e4.ui.internal.workbench.swt.E4Application$1.syncExec(E4Application.java:219)
	at org.eclipse.e4.ui.internal.di.UIEventObjectSupplier$UIEventHandler.handleEvent(UIEventObjectSupplier.java:64)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:132)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.e4.ui.model.application.ui.impl.UIElementImpl.setVisible(UIElementImpl.java:361)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributionRecord.updateVisibility(ContributionRecord.java:113)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRendererFilter.updateElementVisibility(MenuManagerRendererFilter.java:197)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRendererFilter.updateElementVisibility(MenuManagerRendererFilter.java:208)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerShowProcessor.showMenu(MenuManagerShowProcessor.java:258)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerShowProcessor.menuAboutToHide(MenuManagerShowProcessor.java:115)
	at org.eclipse.jface.internal.MenuManagerEventHelper.showEventPostHelper(MenuManagerEventHelper.java:95)
	at org.eclipse.jface.action.MenuManager.handleAboutToShow(MenuManager.java:469)
	at org.eclipse.jface.action.MenuManager.access$1(MenuManager.java:463)
	at org.eclipse.jface.action.MenuManager$2.menuShown(MenuManager.java:495)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:259)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4213)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1037)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1042)
	at org.eclipse.swt.widgets.Control.WM_INITMENUPOPUP(Control.java:5137)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4769)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1480)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2142)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4923)
	at org.eclipse.swt.internal.win32.OS.TrackPopupMenu(Native Method)
	at org.eclipse.swt.widgets.Menu._setVisible(Menu.java:237)
	at org.eclipse.swt.widgets.Display.runPopups(Display.java:4071)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3624)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1158)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1047)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:658)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:557)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:154)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:137)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:107)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1447)
Caused by: org.eclipse.swt.SWTException: i/o error (java.io.FileNotFoundException: C:\Program Files\Git\mingw64\share\git\git-for-windows.ico (Le chemin d’accès spécifié est introuvable))
	at org.eclipse.swt.SWT.error(SWT.java:4723)
	at org.eclipse.swt.SWT.error(SWT.java:4638)
	at org.eclipse.swt.graphics.ImageLoader.load(ImageLoader.java:184)
	at org.eclipse.tm.terminal.view.ui.local.showin.ExternalExecutablesManager.loadImage(ExternalExecutablesManager.java:282)
	at org.eclipse.tm.terminal.view.ui.local.showin.DynamicContributionItems.getContributionItems(DynamicContributionItems.java:74)
	at org.eclipse.ui.actions.CompoundContributionItem.getContributionItemsToFill(CompoundContributionItem.java:83)
	at org.eclipse.ui.actions.CompoundContributionItem.fill(CompoundContributionItem.java:57)
	at org.eclipse.ui.internal.menus.DynamicMenuContributionItem.fill(DynamicMenuContributionItem.java:146)
	at org.eclipse.jface.action.MenuManager.doItemFill(MenuManager.java:729)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:806)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:673)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.scheduleManagerUpdate(MenuManagerRenderer.java:1224)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.subscribeUIElementTopicVisible(MenuManagerRenderer.java:213)
	at jdk.internal.reflect.GeneratedMethodAccessor37.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	... 63 more
Caused by: java.io.FileNotFoundException: C:\Program Files\Git\mingw64\share\git\git-for-windows.ico (Le chemin d’accès spécifié est introuvable)
	at java.base/java.io.FileInputStream.open0(Native Method)
	at java.base/java.io.FileInputStream.open(FileInputStream.java:212)
	at java.base/java.io.FileInputStream.<init>(FileInputStream.java:154)
	at java.base/java.io.FileInputStream.<init>(FileInputStream.java:109)
	at org.eclipse.swt.graphics.ImageLoader.load(ImageLoader.java:181)
	... 77 more
